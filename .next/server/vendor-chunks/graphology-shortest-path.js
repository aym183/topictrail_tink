/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-shortest-path";
exports.ids = ["vendor-chunks/graphology-shortest-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-shortest-path/astar.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-shortest-path/astar.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology A* Shortest Path\n * ==================================\n *\n * Graphology implementation of A* shortest path for weighted graphs.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar createEdgeWeightGetter =\n  (__webpack_require__(/*! graphology-utils/getters */ \"(ssr)/./node_modules/graphology-utils/getters.js\").createEdgeWeightGetter);\nvar Heap = __webpack_require__(/*! mnemonist/heap */ \"(ssr)/./node_modules/mnemonist/heap.js\");\n\n/**\n * Defaults & helpers.\n */\nvar DEFAULT_WEIGHT_ATTRIBUTE = 'weight';\n\nfunction ASTAR_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  return 0;\n}\n\n/**\n * Bidirectional A* shortest path between source & target node.\n *\n * Note that this implementation was basically copied from networkx.\n *\n * @param  {Graph}     graph          - The graphology instance.\n * @param  {string}    source         - Source node.\n * @param  {string}    target         - Target node.\n * @param  {?function} getEdgeWeight  - Name of the weight attribute or getter function.\n * @param  {?function} heuristic      - A function to estimate the distance between any node and the target. The function takes two nodes as arguments and must return a number. If the function is omitted, it is evaluated to 0, which is the same as Dijkstra's algorithm\n * @param  {?object}   options        - Options:\n * @param  {?number}     cutoff         - A cutoff value for the evaluation function.\n * @return {array}                    - The found path, if any\n */\nfunction bidirectionalAstar(\n  graph,\n  source,\n  target,\n  getEdgeWeight,\n  heuristic,\n  options\n) {\n  // Sanity checks\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-shortest-path/astar: invalid graphology instance.'\n    );\n\n  if (source && !graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path/astar: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  if (target && !graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path/astar: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  if (source === target) return [source];\n\n  heuristic =\n    heuristic ||\n    function () {\n      return 0;\n    };\n\n  options = options || {};\n\n  // The queue stores priority, node, cost to reach, and parent.\n  var count = 0;\n  var queue = new Heap(ASTAR_HEAP_COMPARATOR);\n  queue.push([0, count++, source, 0, null]);\n\n  // Maps enqueued nodes to distance of discovered paths and the\n  // computed heuristics to target. We avoid computing the heuristics\n  // more than once and inserting the node into the queue too many times.\n  var enqueued = {};\n\n  // Maps explored nodes to parent closest to the source.\n  var explored = {};\n\n  var item;\n  var curnode;\n  var entry;\n  var dist;\n  var parent;\n  var path;\n  var node;\n  var qcost;\n  var h;\n  var cost;\n  var ncost;\n  var neighbor;\n\n  function edgeCallback(edge, attr, s, t) {\n    neighbor = curnode === s ? t : s;\n    cost = getEdgeWeight(edge, attr);\n\n    if (cost === null) return;\n\n    ncost = dist + cost;\n\n    if (enqueued.hasOwnProperty(neighbor)) {\n      entry = enqueued[neighbor];\n      qcost = entry[0];\n      h = entry[1];\n\n      // if qcost <= ncost, a less costly path from the\n      // neighbor to the source was already determined.\n      // Therefore, we won't attempt to push this neighbor\n      // to the queue\n      if (qcost <= ncost) return;\n    } else {\n      h = heuristic(neighbor, target);\n    }\n\n    if (options.cutoff && ncost + h > options.cutoff) return;\n\n    enqueued[neighbor] = [ncost, h];\n    queue.push([ncost + h, count++, neighbor, ncost, curnode]);\n  }\n\n  while (queue.size !== 0) {\n    // Pop the smallest item from queue.\n    item = queue.pop();\n    curnode = item[2];\n    dist = item[3];\n    parent = item[4];\n\n    if (curnode === target) {\n      path = [curnode];\n      node = parent;\n      while (node !== null) {\n        path.push(node);\n        node = explored[node];\n      }\n      path.reverse();\n      return path;\n    }\n\n    if (explored.hasOwnProperty(curnode)) {\n      // Do not override the parent of starting node\n      if (explored[curnode] === null) continue;\n\n      // Skip bad paths that were enqueued before finding a better one\n      qcost = enqueued[curnode][0];\n      if (qcost < dist) continue;\n    }\n\n    explored[curnode] = parent;\n\n    graph.forEachOutboundEdge(curnode, edgeCallback);\n  }\n\n  // No path was found\n  return null;\n}\n\n/**\n * Exporting.\n */\nexports.bidirectional = bidirectionalAstar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2FzdGFyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvRkFBMkI7QUFDakQ7QUFDQSxFQUFFLGdJQUEwRDtBQUM1RCxXQUFXLG1CQUFPLENBQUMsOERBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLGFBQWE7QUFDekIsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9hc3Rhci5qcz8wMDI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBBKiBTaG9ydGVzdCBQYXRoXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR3JhcGhvbG9neSBpbXBsZW1lbnRhdGlvbiBvZiBBKiBzaG9ydGVzdCBwYXRoIGZvciB3ZWlnaHRlZCBncmFwaHMuXG4gKi9cbnZhciBpc0dyYXBoID0gcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCcpO1xudmFyIGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPVxuICByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMnKS5jcmVhdGVFZGdlV2VpZ2h0R2V0dGVyO1xudmFyIEhlYXAgPSByZXF1aXJlKCdtbmVtb25pc3QvaGVhcCcpO1xuXG4vKipcbiAqIERlZmF1bHRzICYgaGVscGVycy5cbiAqL1xudmFyIERFRkFVTFRfV0VJR0hUX0FUVFJJQlVURSA9ICd3ZWlnaHQnO1xuXG5mdW5jdGlvbiBBU1RBUl9IRUFQX0NPTVBBUkFUT1IoYSwgYikge1xuICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICBpZiAoYVswXSA8IGJbMF0pIHJldHVybiAtMTtcblxuICBpZiAoYVsxXSA+IGJbMV0pIHJldHVybiAxO1xuICBpZiAoYVsxXSA8IGJbMV0pIHJldHVybiAtMTtcblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBCaWRpcmVjdGlvbmFsIEEqIHNob3J0ZXN0IHBhdGggYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQgbm9kZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvbiB3YXMgYmFzaWNhbGx5IGNvcGllZCBmcm9tIG5ldHdvcmt4LlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICAgZ3JhcGggICAgICAgICAgLSBUaGUgZ3JhcGhvbG9neSBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICAgc291cmNlICAgICAgICAgLSBTb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICAgdGFyZ2V0ICAgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAgez9mdW5jdGlvbn0gZ2V0RWRnZVdlaWdodCAgLSBOYW1lIG9mIHRoZSB3ZWlnaHQgYXR0cmlidXRlIG9yIGdldHRlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSAgez9mdW5jdGlvbn0gaGV1cmlzdGljICAgICAgLSBBIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGFueSBub2RlIGFuZCB0aGUgdGFyZ2V0LiBUaGUgZnVuY3Rpb24gdGFrZXMgdHdvIG5vZGVzIGFzIGFyZ3VtZW50cyBhbmQgbXVzdCByZXR1cm4gYSBudW1iZXIuIElmIHRoZSBmdW5jdGlvbiBpcyBvbWl0dGVkLCBpdCBpcyBldmFsdWF0ZWQgdG8gMCwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgRGlqa3N0cmEncyBhbGdvcml0aG1cbiAqIEBwYXJhbSAgez9vYmplY3R9ICAgb3B0aW9ucyAgICAgICAgLSBPcHRpb25zOlxuICogQHBhcmFtICB7P251bWJlcn0gICAgIGN1dG9mZiAgICAgICAgIC0gQSBjdXRvZmYgdmFsdWUgZm9yIHRoZSBldmFsdWF0aW9uIGZ1bmN0aW9uLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgICAgICAtIFRoZSBmb3VuZCBwYXRoLCBpZiBhbnlcbiAqL1xuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEFzdGFyKFxuICBncmFwaCxcbiAgc291cmNlLFxuICB0YXJnZXQsXG4gIGdldEVkZ2VXZWlnaHQsXG4gIGhldXJpc3RpYyxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIFNhbml0eSBjaGVja3NcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2FzdGFyOiBpbnZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgaWYgKHNvdXJjZSAmJiAhZ3JhcGguaGFzTm9kZShzb3VyY2UpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LXNob3J0ZXN0LXBhdGgvYXN0YXI6IHRoZSBcIicgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAnXCIgc291cmNlIG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGdpdmVuIGdyYXBoLidcbiAgICApO1xuXG4gIGlmICh0YXJnZXQgJiYgIWdyYXBoLmhhc05vZGUodGFyZ2V0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2FzdGFyOiB0aGUgXCInICtcbiAgICAgICAgdGFyZ2V0ICtcbiAgICAgICAgJ1wiIHRhcmdldCBub2RlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBnaXZlbiBncmFwaC4nXG4gICAgKTtcblxuICBnZXRFZGdlV2VpZ2h0ID0gY3JlYXRlRWRnZVdlaWdodEdldHRlcihcbiAgICBnZXRFZGdlV2VpZ2h0IHx8IERFRkFVTFRfV0VJR0hUX0FUVFJJQlVURVxuICApLmZyb21NaW5pbWFsRW50cnk7XG5cbiAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSByZXR1cm4gW3NvdXJjZV07XG5cbiAgaGV1cmlzdGljID1cbiAgICBoZXVyaXN0aWMgfHxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIFRoZSBxdWV1ZSBzdG9yZXMgcHJpb3JpdHksIG5vZGUsIGNvc3QgdG8gcmVhY2gsIGFuZCBwYXJlbnQuXG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBxdWV1ZSA9IG5ldyBIZWFwKEFTVEFSX0hFQVBfQ09NUEFSQVRPUik7XG4gIHF1ZXVlLnB1c2goWzAsIGNvdW50KyssIHNvdXJjZSwgMCwgbnVsbF0pO1xuXG4gIC8vIE1hcHMgZW5xdWV1ZWQgbm9kZXMgdG8gZGlzdGFuY2Ugb2YgZGlzY292ZXJlZCBwYXRocyBhbmQgdGhlXG4gIC8vIGNvbXB1dGVkIGhldXJpc3RpY3MgdG8gdGFyZ2V0LiBXZSBhdm9pZCBjb21wdXRpbmcgdGhlIGhldXJpc3RpY3NcbiAgLy8gbW9yZSB0aGFuIG9uY2UgYW5kIGluc2VydGluZyB0aGUgbm9kZSBpbnRvIHRoZSBxdWV1ZSB0b28gbWFueSB0aW1lcy5cbiAgdmFyIGVucXVldWVkID0ge307XG5cbiAgLy8gTWFwcyBleHBsb3JlZCBub2RlcyB0byBwYXJlbnQgY2xvc2VzdCB0byB0aGUgc291cmNlLlxuICB2YXIgZXhwbG9yZWQgPSB7fTtcblxuICB2YXIgaXRlbTtcbiAgdmFyIGN1cm5vZGU7XG4gIHZhciBlbnRyeTtcbiAgdmFyIGRpc3Q7XG4gIHZhciBwYXJlbnQ7XG4gIHZhciBwYXRoO1xuICB2YXIgbm9kZTtcbiAgdmFyIHFjb3N0O1xuICB2YXIgaDtcbiAgdmFyIGNvc3Q7XG4gIHZhciBuY29zdDtcbiAgdmFyIG5laWdoYm9yO1xuXG4gIGZ1bmN0aW9uIGVkZ2VDYWxsYmFjayhlZGdlLCBhdHRyLCBzLCB0KSB7XG4gICAgbmVpZ2hib3IgPSBjdXJub2RlID09PSBzID8gdCA6IHM7XG4gICAgY29zdCA9IGdldEVkZ2VXZWlnaHQoZWRnZSwgYXR0cik7XG5cbiAgICBpZiAoY29zdCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgbmNvc3QgPSBkaXN0ICsgY29zdDtcblxuICAgIGlmIChlbnF1ZXVlZC5oYXNPd25Qcm9wZXJ0eShuZWlnaGJvcikpIHtcbiAgICAgIGVudHJ5ID0gZW5xdWV1ZWRbbmVpZ2hib3JdO1xuICAgICAgcWNvc3QgPSBlbnRyeVswXTtcbiAgICAgIGggPSBlbnRyeVsxXTtcblxuICAgICAgLy8gaWYgcWNvc3QgPD0gbmNvc3QsIGEgbGVzcyBjb3N0bHkgcGF0aCBmcm9tIHRoZVxuICAgICAgLy8gbmVpZ2hib3IgdG8gdGhlIHNvdXJjZSB3YXMgYWxyZWFkeSBkZXRlcm1pbmVkLlxuICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB3b24ndCBhdHRlbXB0IHRvIHB1c2ggdGhpcyBuZWlnaGJvclxuICAgICAgLy8gdG8gdGhlIHF1ZXVlXG4gICAgICBpZiAocWNvc3QgPD0gbmNvc3QpIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGhldXJpc3RpYyhuZWlnaGJvciwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jdXRvZmYgJiYgbmNvc3QgKyBoID4gb3B0aW9ucy5jdXRvZmYpIHJldHVybjtcblxuICAgIGVucXVldWVkW25laWdoYm9yXSA9IFtuY29zdCwgaF07XG4gICAgcXVldWUucHVzaChbbmNvc3QgKyBoLCBjb3VudCsrLCBuZWlnaGJvciwgbmNvc3QsIGN1cm5vZGVdKTtcbiAgfVxuXG4gIHdoaWxlIChxdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgLy8gUG9wIHRoZSBzbWFsbGVzdCBpdGVtIGZyb20gcXVldWUuXG4gICAgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgIGN1cm5vZGUgPSBpdGVtWzJdO1xuICAgIGRpc3QgPSBpdGVtWzNdO1xuICAgIHBhcmVudCA9IGl0ZW1bNF07XG5cbiAgICBpZiAoY3Vybm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICBwYXRoID0gW2N1cm5vZGVdO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IGV4cGxvcmVkW25vZGVdO1xuICAgICAgfVxuICAgICAgcGF0aC5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBpZiAoZXhwbG9yZWQuaGFzT3duUHJvcGVydHkoY3Vybm9kZSkpIHtcbiAgICAgIC8vIERvIG5vdCBvdmVycmlkZSB0aGUgcGFyZW50IG9mIHN0YXJ0aW5nIG5vZGVcbiAgICAgIGlmIChleHBsb3JlZFtjdXJub2RlXSA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIC8vIFNraXAgYmFkIHBhdGhzIHRoYXQgd2VyZSBlbnF1ZXVlZCBiZWZvcmUgZmluZGluZyBhIGJldHRlciBvbmVcbiAgICAgIHFjb3N0ID0gZW5xdWV1ZWRbY3Vybm9kZV1bMF07XG4gICAgICBpZiAocWNvc3QgPCBkaXN0KSBjb250aW51ZTtcbiAgICB9XG5cbiAgICBleHBsb3JlZFtjdXJub2RlXSA9IHBhcmVudDtcblxuICAgIGdyYXBoLmZvckVhY2hPdXRib3VuZEVkZ2UoY3Vybm9kZSwgZWRnZUNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIE5vIHBhdGggd2FzIGZvdW5kXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xuZXhwb3J0cy5iaWRpcmVjdGlvbmFsID0gYmlkaXJlY3Rpb25hbEFzdGFyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-shortest-path/astar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-shortest-path/dijkstra.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphology-shortest-path/dijkstra.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology Dijkstra Shortest Path\n * ==================================\n *\n * Graphology implementation of Dijkstra shortest path for weighted graphs.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar createEdgeWeightGetter =\n  (__webpack_require__(/*! graphology-utils/getters */ \"(ssr)/./node_modules/graphology-utils/getters.js\").createEdgeWeightGetter);\nvar Heap = __webpack_require__(/*! mnemonist/heap */ \"(ssr)/./node_modules/mnemonist/heap.js\");\n\n/**\n * Defaults & helpers.\n */\nvar DEFAULT_WEIGHT_ATTRIBUTE = 'weight';\n\nfunction DIJKSTRA_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  if (a[2] > b[2]) return 1;\n  if (a[2] < b[2]) return -1;\n\n  return 0;\n}\n\nfunction BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  if (a[2] > b[2]) return 1;\n  if (a[2] < b[2]) return -1;\n\n  if (a[3] > b[3]) return 1;\n  if (a[3] < b[3]) return -1;\n\n  return 0;\n}\n\n/**\n * Bidirectional Dijkstra shortest path between source & target node abstract.\n *\n * Note that this implementation was basically copied from networkx.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {string} source        - Source node.\n * @param  {string} target        - Target node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @param  {array}                - The found path if any and its cost.\n */\nfunction abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight) {\n  source = '' + source;\n  target = '' + target;\n\n  // Sanity checks\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: invalid graphology instance.'\n    );\n\n  if (source && !graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  if (target && !graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  if (source === target) return [0, [source]];\n\n  var distances = [{}, {}],\n    paths = [{}, {}],\n    fringe = [\n      new Heap(DIJKSTRA_HEAP_COMPARATOR),\n      new Heap(DIJKSTRA_HEAP_COMPARATOR)\n    ],\n    seen = [{}, {}];\n\n  paths[0][source] = [source];\n  paths[1][target] = [target];\n\n  seen[0][source] = 0;\n  seen[1][target] = 0;\n\n  var finalPath = [],\n    finalDistance = Infinity;\n\n  var count = 0,\n    dir = 1,\n    item,\n    edges,\n    cost,\n    d,\n    v,\n    u,\n    e,\n    i,\n    l;\n\n  fringe[0].push([0, count++, source]);\n  fringe[1].push([0, count++, target]);\n\n  while (fringe[0].size && fringe[1].size) {\n    // Swapping direction\n    dir = 1 - dir;\n\n    item = fringe[dir].pop();\n    d = item[0];\n    v = item[2];\n\n    if (v in distances[dir]) continue;\n\n    distances[dir][v] = d;\n\n    // Shortest path is found?\n    if (v in distances[1 - dir]) return [finalDistance, finalPath];\n\n    edges = dir === 1 ? graph.inboundEdges(v) : graph.outboundEdges(v);\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      e = edges[i];\n      u = graph.opposite(v, e);\n      cost = distances[dir][v] + getEdgeWeight(e, graph.getEdgeAttributes(e));\n\n      if (u in distances[dir] && cost < distances[dir][u]) {\n        throw Error(\n          'graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?'\n        );\n      } else if (!(u in seen[dir]) || cost < seen[dir][u]) {\n        seen[dir][u] = cost;\n        fringe[dir].push([cost, count++, u]);\n        paths[dir][u] = paths[dir][v].concat(u);\n\n        if (u in seen[0] && u in seen[1]) {\n          d = seen[0][u] + seen[1][u];\n\n          if (finalPath.length === 0 || finalDistance > d) {\n            finalDistance = d;\n            finalPath = paths[0][u].concat(paths[1][u].slice(0, -1).reverse());\n          }\n        }\n      }\n    }\n  }\n\n  // No path was found\n  return [Infinity, null];\n}\n\n/**\n * Multisource Dijkstra shortest path abstract function. This function is the\n * basis of the algorithm that every other will use.\n *\n * Note that this implementation was basically copied from networkx.\n * TODO: it might be more performant to use a dedicated objet for the heap's\n * items.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {array}  sources       - A list of sources.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @param  {number} cutoff        - Maximum depth of the search.\n * @param  {string} target        - Optional target to reach.\n * @param  {object} paths         - Optional paths object to maintain.\n * @return {object}               - Returns the paths.\n */\nfunction abstractDijkstraMultisource(\n  graph,\n  sources,\n  getEdgeWeight,\n  cutoff,\n  target,\n  paths\n) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: invalid graphology instance.'\n    );\n\n  if (target && !graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  var distances = {},\n    seen = {},\n    fringe = new Heap(DIJKSTRA_HEAP_COMPARATOR);\n\n  var count = 0,\n    edges,\n    item,\n    cost,\n    v,\n    u,\n    e,\n    d,\n    i,\n    j,\n    l,\n    m;\n\n  for (i = 0, l = sources.length; i < l; i++) {\n    v = sources[i];\n    seen[v] = 0;\n    fringe.push([0, count++, v]);\n\n    if (paths) paths[v] = [v];\n  }\n\n  while (fringe.size) {\n    item = fringe.pop();\n    d = item[0];\n    v = item[2];\n\n    if (v in distances) continue;\n\n    distances[v] = d;\n\n    if (v === target) break;\n\n    edges = graph.outboundEdges(v);\n\n    for (j = 0, m = edges.length; j < m; j++) {\n      e = edges[j];\n      u = graph.opposite(v, e);\n      cost = getEdgeWeight(e, graph.getEdgeAttributes(e)) + distances[v];\n\n      if (cutoff && cost > cutoff) continue;\n\n      if (u in distances && cost < distances[u]) {\n        throw Error(\n          'graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?'\n        );\n      } else if (!(u in seen) || cost < seen[u]) {\n        seen[u] = cost;\n        fringe.push([cost, count++, u]);\n\n        if (paths) paths[u] = paths[v].concat(u);\n      }\n    }\n  }\n\n  return distances;\n}\n\n/**\n * Single source Dijkstra shortest path between given node & other nodes in\n * the graph.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {string} source        - Source node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @return {object}               - An object of found paths.\n */\nfunction singleSourceDijkstra(graph, source, getEdgeWeight) {\n  var paths = {};\n\n  abstractDijkstraMultisource(graph, [source], getEdgeWeight, 0, null, paths);\n\n  return paths;\n}\n\nfunction bidirectionalDijkstra(graph, source, target, getEdgeWeight) {\n  return abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight)[1];\n}\n\n/**\n * Function using Ulrik Brandes' method to map single source shortest paths\n * from selected node.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}  graph         - Target graph.\n * @param  {any}    source        - Source node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @return {array}                - [Stack, Paths, Sigma]\n */\nfunction brandes(graph, source, getEdgeWeight) {\n  source = '' + source;\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  var S = [],\n    P = {},\n    sigma = {};\n\n  var nodes = graph.nodes(),\n    edges,\n    item,\n    pred,\n    dist,\n    cost,\n    v,\n    w,\n    e,\n    i,\n    l;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    v = nodes[i];\n    P[v] = [];\n    sigma[v] = 0;\n  }\n\n  var D = {};\n\n  sigma[source] = 1;\n\n  var seen = {};\n  seen[source] = 0;\n\n  var count = 0;\n\n  var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);\n  Q.push([0, count++, source, source]);\n\n  while (Q.size) {\n    item = Q.pop();\n    dist = item[0];\n    pred = item[2];\n    v = item[3];\n\n    if (v in D) continue;\n\n    sigma[v] += sigma[pred];\n    S.push(v);\n    D[v] = dist;\n\n    edges = graph.outboundEdges(v);\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      e = edges[i];\n      w = graph.opposite(v, e);\n      cost = dist + getEdgeWeight(e, graph.getEdgeAttributes(e));\n\n      if (!(w in D) && (!(w in seen) || cost < seen[w])) {\n        seen[w] = cost;\n        Q.push([cost, count++, v, w]);\n        sigma[w] = 0;\n        P[w] = [v];\n      } else if (cost === seen[w]) {\n        sigma[w] += sigma[v];\n        P[w].push(v);\n      }\n    }\n  }\n\n  return [S, P, sigma];\n}\n\n/**\n * Exporting.\n */\nexports.bidirectional = bidirectionalDijkstra;\nexports.singleSource = singleSourceDijkstra;\nexports.brandes = brandes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2RpamtzdHJhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvRkFBMkI7QUFDakQ7QUFDQSxFQUFFLGdJQUEwRDtBQUM1RCxXQUFXLG1CQUFPLENBQUMsOERBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixJQUFJO0FBQ3pCLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYS5qcz9mNTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBEaWprc3RyYSBTaG9ydGVzdCBQYXRoXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR3JhcGhvbG9neSBpbXBsZW1lbnRhdGlvbiBvZiBEaWprc3RyYSBzaG9ydGVzdCBwYXRoIGZvciB3ZWlnaHRlZCBncmFwaHMuXG4gKi9cbnZhciBpc0dyYXBoID0gcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCcpO1xudmFyIGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPVxuICByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMnKS5jcmVhdGVFZGdlV2VpZ2h0R2V0dGVyO1xudmFyIEhlYXAgPSByZXF1aXJlKCdtbmVtb25pc3QvaGVhcCcpO1xuXG4vKipcbiAqIERlZmF1bHRzICYgaGVscGVycy5cbiAqL1xudmFyIERFRkFVTFRfV0VJR0hUX0FUVFJJQlVURSA9ICd3ZWlnaHQnO1xuXG5mdW5jdGlvbiBESUpLU1RSQV9IRUFQX0NPTVBBUkFUT1IoYSwgYikge1xuICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICBpZiAoYVswXSA8IGJbMF0pIHJldHVybiAtMTtcblxuICBpZiAoYVsxXSA+IGJbMV0pIHJldHVybiAxO1xuICBpZiAoYVsxXSA8IGJbMV0pIHJldHVybiAtMTtcblxuICBpZiAoYVsyXSA+IGJbMl0pIHJldHVybiAxO1xuICBpZiAoYVsyXSA8IGJbMl0pIHJldHVybiAtMTtcblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gQlJBTkRFU19ESUpLU1RSQV9IRUFQX0NPTVBBUkFUT1IoYSwgYikge1xuICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICBpZiAoYVswXSA8IGJbMF0pIHJldHVybiAtMTtcblxuICBpZiAoYVsxXSA+IGJbMV0pIHJldHVybiAxO1xuICBpZiAoYVsxXSA8IGJbMV0pIHJldHVybiAtMTtcblxuICBpZiAoYVsyXSA+IGJbMl0pIHJldHVybiAxO1xuICBpZiAoYVsyXSA8IGJbMl0pIHJldHVybiAtMTtcblxuICBpZiAoYVszXSA+IGJbM10pIHJldHVybiAxO1xuICBpZiAoYVszXSA8IGJbM10pIHJldHVybiAtMTtcblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBCaWRpcmVjdGlvbmFsIERpamtzdHJhIHNob3J0ZXN0IHBhdGggYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQgbm9kZSBhYnN0cmFjdC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBpbXBsZW1lbnRhdGlvbiB3YXMgYmFzaWNhbGx5IGNvcGllZCBmcm9tIG5ldHdvcmt4LlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggICAgICAgICAtIFRoZSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSBzb3VyY2UgICAgICAgIC0gU291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRhcmdldCAgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gZ2V0RWRnZVdlaWdodCAtIE5hbWUgb2YgdGhlIHdlaWdodCBhdHRyaWJ1dGUgb3IgZ2V0dGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7YXJyYXl9ICAgICAgICAgICAgICAgIC0gVGhlIGZvdW5kIHBhdGggaWYgYW55IGFuZCBpdHMgY29zdC5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RCaWRpcmVjdGlvbmFsRGlqa3N0cmEoZ3JhcGgsIHNvdXJjZSwgdGFyZ2V0LCBnZXRFZGdlV2VpZ2h0KSB7XG4gIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAvLyBTYW5pdHkgY2hlY2tzXG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYTogaW52YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlLidcbiAgICApO1xuXG4gIGlmIChzb3VyY2UgJiYgIWdyYXBoLmhhc05vZGUoc291cmNlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2RpamtzdHJhOiB0aGUgXCInICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ1wiIHNvdXJjZSBub2RlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBnaXZlbiBncmFwaC4nXG4gICAgKTtcblxuICBpZiAodGFyZ2V0ICYmICFncmFwaC5oYXNOb2RlKHRhcmdldCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYTogdGhlIFwiJyArXG4gICAgICAgIHRhcmdldCArXG4gICAgICAgICdcIiB0YXJnZXQgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gZ3JhcGguJ1xuICAgICk7XG5cbiAgZ2V0RWRnZVdlaWdodCA9IGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIoXG4gICAgZ2V0RWRnZVdlaWdodCB8fCBERUZBVUxUX1dFSUdIVF9BVFRSSUJVVEVcbiAgKS5mcm9tTWluaW1hbEVudHJ5O1xuXG4gIGlmIChzb3VyY2UgPT09IHRhcmdldCkgcmV0dXJuIFswLCBbc291cmNlXV07XG5cbiAgdmFyIGRpc3RhbmNlcyA9IFt7fSwge31dLFxuICAgIHBhdGhzID0gW3t9LCB7fV0sXG4gICAgZnJpbmdlID0gW1xuICAgICAgbmV3IEhlYXAoRElKS1NUUkFfSEVBUF9DT01QQVJBVE9SKSxcbiAgICAgIG5ldyBIZWFwKERJSktTVFJBX0hFQVBfQ09NUEFSQVRPUilcbiAgICBdLFxuICAgIHNlZW4gPSBbe30sIHt9XTtcblxuICBwYXRoc1swXVtzb3VyY2VdID0gW3NvdXJjZV07XG4gIHBhdGhzWzFdW3RhcmdldF0gPSBbdGFyZ2V0XTtcblxuICBzZWVuWzBdW3NvdXJjZV0gPSAwO1xuICBzZWVuWzFdW3RhcmdldF0gPSAwO1xuXG4gIHZhciBmaW5hbFBhdGggPSBbXSxcbiAgICBmaW5hbERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgdmFyIGNvdW50ID0gMCxcbiAgICBkaXIgPSAxLFxuICAgIGl0ZW0sXG4gICAgZWRnZXMsXG4gICAgY29zdCxcbiAgICBkLFxuICAgIHYsXG4gICAgdSxcbiAgICBlLFxuICAgIGksXG4gICAgbDtcblxuICBmcmluZ2VbMF0ucHVzaChbMCwgY291bnQrKywgc291cmNlXSk7XG4gIGZyaW5nZVsxXS5wdXNoKFswLCBjb3VudCsrLCB0YXJnZXRdKTtcblxuICB3aGlsZSAoZnJpbmdlWzBdLnNpemUgJiYgZnJpbmdlWzFdLnNpemUpIHtcbiAgICAvLyBTd2FwcGluZyBkaXJlY3Rpb25cbiAgICBkaXIgPSAxIC0gZGlyO1xuXG4gICAgaXRlbSA9IGZyaW5nZVtkaXJdLnBvcCgpO1xuICAgIGQgPSBpdGVtWzBdO1xuICAgIHYgPSBpdGVtWzJdO1xuXG4gICAgaWYgKHYgaW4gZGlzdGFuY2VzW2Rpcl0pIGNvbnRpbnVlO1xuXG4gICAgZGlzdGFuY2VzW2Rpcl1bdl0gPSBkO1xuXG4gICAgLy8gU2hvcnRlc3QgcGF0aCBpcyBmb3VuZD9cbiAgICBpZiAodiBpbiBkaXN0YW5jZXNbMSAtIGRpcl0pIHJldHVybiBbZmluYWxEaXN0YW5jZSwgZmluYWxQYXRoXTtcblxuICAgIGVkZ2VzID0gZGlyID09PSAxID8gZ3JhcGguaW5ib3VuZEVkZ2VzKHYpIDogZ3JhcGgub3V0Ym91bmRFZGdlcyh2KTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGUgPSBlZGdlc1tpXTtcbiAgICAgIHUgPSBncmFwaC5vcHBvc2l0ZSh2LCBlKTtcbiAgICAgIGNvc3QgPSBkaXN0YW5jZXNbZGlyXVt2XSArIGdldEVkZ2VXZWlnaHQoZSwgZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZXMoZSkpO1xuXG4gICAgICBpZiAodSBpbiBkaXN0YW5jZXNbZGlyXSAmJiBjb3N0IDwgZGlzdGFuY2VzW2Rpcl1bdV0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYTogY29udHJhZGljdG9yeSBwYXRocyBmb3VuZC4gRG8gc29tZSBvZiB5b3VyIGVkZ2VzIGhhdmUgYSBuZWdhdGl2ZSB3ZWlnaHQ/J1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghKHUgaW4gc2VlbltkaXJdKSB8fCBjb3N0IDwgc2VlbltkaXJdW3VdKSB7XG4gICAgICAgIHNlZW5bZGlyXVt1XSA9IGNvc3Q7XG4gICAgICAgIGZyaW5nZVtkaXJdLnB1c2goW2Nvc3QsIGNvdW50KyssIHVdKTtcbiAgICAgICAgcGF0aHNbZGlyXVt1XSA9IHBhdGhzW2Rpcl1bdl0uY29uY2F0KHUpO1xuXG4gICAgICAgIGlmICh1IGluIHNlZW5bMF0gJiYgdSBpbiBzZWVuWzFdKSB7XG4gICAgICAgICAgZCA9IHNlZW5bMF1bdV0gKyBzZWVuWzFdW3VdO1xuXG4gICAgICAgICAgaWYgKGZpbmFsUGF0aC5sZW5ndGggPT09IDAgfHwgZmluYWxEaXN0YW5jZSA+IGQpIHtcbiAgICAgICAgICAgIGZpbmFsRGlzdGFuY2UgPSBkO1xuICAgICAgICAgICAgZmluYWxQYXRoID0gcGF0aHNbMF1bdV0uY29uY2F0KHBhdGhzWzFdW3VdLnNsaWNlKDAsIC0xKS5yZXZlcnNlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vIHBhdGggd2FzIGZvdW5kXG4gIHJldHVybiBbSW5maW5pdHksIG51bGxdO1xufVxuXG4vKipcbiAqIE11bHRpc291cmNlIERpamtzdHJhIHNob3J0ZXN0IHBhdGggYWJzdHJhY3QgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgdGhlXG4gKiBiYXNpcyBvZiB0aGUgYWxnb3JpdGhtIHRoYXQgZXZlcnkgb3RoZXIgd2lsbCB1c2UuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgaW1wbGVtZW50YXRpb24gd2FzIGJhc2ljYWxseSBjb3BpZWQgZnJvbSBuZXR3b3JreC5cbiAqIFRPRE86IGl0IG1pZ2h0IGJlIG1vcmUgcGVyZm9ybWFudCB0byB1c2UgYSBkZWRpY2F0ZWQgb2JqZXQgZm9yIHRoZSBoZWFwJ3NcbiAqIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggICAgICAgICAtIFRoZSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICogQHBhcmFtICB7YXJyYXl9ICBzb3VyY2VzICAgICAgIC0gQSBsaXN0IG9mIHNvdXJjZXMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdldEVkZ2VXZWlnaHQgLSBOYW1lIG9mIHRoZSB3ZWlnaHQgYXR0cmlidXRlIG9yIGdldHRlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge251bWJlcn0gY3V0b2ZmICAgICAgICAtIE1heGltdW0gZGVwdGggb2YgdGhlIHNlYXJjaC5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGFyZ2V0ICAgICAgICAtIE9wdGlvbmFsIHRhcmdldCB0byByZWFjaC5cbiAqIEBwYXJhbSAge29iamVjdH0gcGF0aHMgICAgICAgICAtIE9wdGlvbmFsIHBhdGhzIG9iamVjdCB0byBtYWludGFpbi5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAtIFJldHVybnMgdGhlIHBhdGhzLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdERpamtzdHJhTXVsdGlzb3VyY2UoXG4gIGdyYXBoLFxuICBzb3VyY2VzLFxuICBnZXRFZGdlV2VpZ2h0LFxuICBjdXRvZmYsXG4gIHRhcmdldCxcbiAgcGF0aHNcbikge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LXNob3J0ZXN0LXBhdGgvZGlqa3N0cmE6IGludmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZS4nXG4gICAgKTtcblxuICBpZiAodGFyZ2V0ICYmICFncmFwaC5oYXNOb2RlKHRhcmdldCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYTogdGhlIFwiJyArXG4gICAgICAgIHRhcmdldCArXG4gICAgICAgICdcIiB0YXJnZXQgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gZ3JhcGguJ1xuICAgICk7XG5cbiAgZ2V0RWRnZVdlaWdodCA9IGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIoXG4gICAgZ2V0RWRnZVdlaWdodCB8fCBERUZBVUxUX1dFSUdIVF9BVFRSSUJVVEVcbiAgKS5mcm9tTWluaW1hbEVudHJ5O1xuXG4gIHZhciBkaXN0YW5jZXMgPSB7fSxcbiAgICBzZWVuID0ge30sXG4gICAgZnJpbmdlID0gbmV3IEhlYXAoRElKS1NUUkFfSEVBUF9DT01QQVJBVE9SKTtcblxuICB2YXIgY291bnQgPSAwLFxuICAgIGVkZ2VzLFxuICAgIGl0ZW0sXG4gICAgY29zdCxcbiAgICB2LFxuICAgIHUsXG4gICAgZSxcbiAgICBkLFxuICAgIGksXG4gICAgaixcbiAgICBsLFxuICAgIG07XG5cbiAgZm9yIChpID0gMCwgbCA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdiA9IHNvdXJjZXNbaV07XG4gICAgc2Vlblt2XSA9IDA7XG4gICAgZnJpbmdlLnB1c2goWzAsIGNvdW50KyssIHZdKTtcblxuICAgIGlmIChwYXRocykgcGF0aHNbdl0gPSBbdl07XG4gIH1cblxuICB3aGlsZSAoZnJpbmdlLnNpemUpIHtcbiAgICBpdGVtID0gZnJpbmdlLnBvcCgpO1xuICAgIGQgPSBpdGVtWzBdO1xuICAgIHYgPSBpdGVtWzJdO1xuXG4gICAgaWYgKHYgaW4gZGlzdGFuY2VzKSBjb250aW51ZTtcblxuICAgIGRpc3RhbmNlc1t2XSA9IGQ7XG5cbiAgICBpZiAodiA9PT0gdGFyZ2V0KSBicmVhaztcblxuICAgIGVkZ2VzID0gZ3JhcGgub3V0Ym91bmRFZGdlcyh2KTtcblxuICAgIGZvciAoaiA9IDAsIG0gPSBlZGdlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGUgPSBlZGdlc1tqXTtcbiAgICAgIHUgPSBncmFwaC5vcHBvc2l0ZSh2LCBlKTtcbiAgICAgIGNvc3QgPSBnZXRFZGdlV2VpZ2h0KGUsIGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGUpKSArIGRpc3RhbmNlc1t2XTtcblxuICAgICAgaWYgKGN1dG9mZiAmJiBjb3N0ID4gY3V0b2ZmKSBjb250aW51ZTtcblxuICAgICAgaWYgKHUgaW4gZGlzdGFuY2VzICYmIGNvc3QgPCBkaXN0YW5jZXNbdV0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aC9kaWprc3RyYTogY29udHJhZGljdG9yeSBwYXRocyBmb3VuZC4gRG8gc29tZSBvZiB5b3VyIGVkZ2VzIGhhdmUgYSBuZWdhdGl2ZSB3ZWlnaHQ/J1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghKHUgaW4gc2VlbikgfHwgY29zdCA8IHNlZW5bdV0pIHtcbiAgICAgICAgc2Vlblt1XSA9IGNvc3Q7XG4gICAgICAgIGZyaW5nZS5wdXNoKFtjb3N0LCBjb3VudCsrLCB1XSk7XG5cbiAgICAgICAgaWYgKHBhdGhzKSBwYXRoc1t1XSA9IHBhdGhzW3ZdLmNvbmNhdCh1KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VzO1xufVxuXG4vKipcbiAqIFNpbmdsZSBzb3VyY2UgRGlqa3N0cmEgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIGdpdmVuIG5vZGUgJiBvdGhlciBub2RlcyBpblxuICogdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggICAgICAgICAtIFRoZSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSBzb3VyY2UgICAgICAgIC0gU291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdldEVkZ2VXZWlnaHQgLSBOYW1lIG9mIHRoZSB3ZWlnaHQgYXR0cmlidXRlIG9yIGdldHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAtIEFuIG9iamVjdCBvZiBmb3VuZCBwYXRocy5cbiAqL1xuZnVuY3Rpb24gc2luZ2xlU291cmNlRGlqa3N0cmEoZ3JhcGgsIHNvdXJjZSwgZ2V0RWRnZVdlaWdodCkge1xuICB2YXIgcGF0aHMgPSB7fTtcblxuICBhYnN0cmFjdERpamtzdHJhTXVsdGlzb3VyY2UoZ3JhcGgsIFtzb3VyY2VdLCBnZXRFZGdlV2VpZ2h0LCAwLCBudWxsLCBwYXRocyk7XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsRGlqa3N0cmEoZ3JhcGgsIHNvdXJjZSwgdGFyZ2V0LCBnZXRFZGdlV2VpZ2h0KSB7XG4gIHJldHVybiBhYnN0cmFjdEJpZGlyZWN0aW9uYWxEaWprc3RyYShncmFwaCwgc291cmNlLCB0YXJnZXQsIGdldEVkZ2VXZWlnaHQpWzFdO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzaW5nIFVscmlrIEJyYW5kZXMnIG1ldGhvZCB0byBtYXAgc2luZ2xlIHNvdXJjZSBzaG9ydGVzdCBwYXRoc1xuICogZnJvbSBzZWxlY3RlZCBub2RlLlxuICpcbiAqIFtSZWZlcmVuY2VdOlxuICogVWxyaWsgQnJhbmRlczogQSBGYXN0ZXIgQWxnb3JpdGhtIGZvciBCZXR3ZWVubmVzcyBDZW50cmFsaXR5LlxuICogSm91cm5hbCBvZiBNYXRoZW1hdGljYWwgU29jaW9sb2d5IDI1KDIpOjE2My0xNzcsIDIwMDEuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICBncmFwaCAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgICAgICAgIC0gU291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdldEVkZ2VXZWlnaHQgLSBOYW1lIG9mIHRoZSB3ZWlnaHQgYXR0cmlidXRlIG9yIGdldHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAtIFtTdGFjaywgUGF0aHMsIFNpZ21hXVxuICovXG5mdW5jdGlvbiBicmFuZGVzKGdyYXBoLCBzb3VyY2UsIGdldEVkZ2VXZWlnaHQpIHtcbiAgc291cmNlID0gJycgKyBzb3VyY2U7XG5cbiAgZ2V0RWRnZVdlaWdodCA9IGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIoXG4gICAgZ2V0RWRnZVdlaWdodCB8fCBERUZBVUxUX1dFSUdIVF9BVFRSSUJVVEVcbiAgKS5mcm9tTWluaW1hbEVudHJ5O1xuXG4gIHZhciBTID0gW10sXG4gICAgUCA9IHt9LFxuICAgIHNpZ21hID0ge307XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKSxcbiAgICBlZGdlcyxcbiAgICBpdGVtLFxuICAgIHByZWQsXG4gICAgZGlzdCxcbiAgICBjb3N0LFxuICAgIHYsXG4gICAgdyxcbiAgICBlLFxuICAgIGksXG4gICAgbDtcblxuICBmb3IgKGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdiA9IG5vZGVzW2ldO1xuICAgIFBbdl0gPSBbXTtcbiAgICBzaWdtYVt2XSA9IDA7XG4gIH1cblxuICB2YXIgRCA9IHt9O1xuXG4gIHNpZ21hW3NvdXJjZV0gPSAxO1xuXG4gIHZhciBzZWVuID0ge307XG4gIHNlZW5bc291cmNlXSA9IDA7XG5cbiAgdmFyIGNvdW50ID0gMDtcblxuICB2YXIgUSA9IG5ldyBIZWFwKEJSQU5ERVNfRElKS1NUUkFfSEVBUF9DT01QQVJBVE9SKTtcbiAgUS5wdXNoKFswLCBjb3VudCsrLCBzb3VyY2UsIHNvdXJjZV0pO1xuXG4gIHdoaWxlIChRLnNpemUpIHtcbiAgICBpdGVtID0gUS5wb3AoKTtcbiAgICBkaXN0ID0gaXRlbVswXTtcbiAgICBwcmVkID0gaXRlbVsyXTtcbiAgICB2ID0gaXRlbVszXTtcblxuICAgIGlmICh2IGluIEQpIGNvbnRpbnVlO1xuXG4gICAgc2lnbWFbdl0gKz0gc2lnbWFbcHJlZF07XG4gICAgUy5wdXNoKHYpO1xuICAgIERbdl0gPSBkaXN0O1xuXG4gICAgZWRnZXMgPSBncmFwaC5vdXRib3VuZEVkZ2VzKHYpO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZSA9IGVkZ2VzW2ldO1xuICAgICAgdyA9IGdyYXBoLm9wcG9zaXRlKHYsIGUpO1xuICAgICAgY29zdCA9IGRpc3QgKyBnZXRFZGdlV2VpZ2h0KGUsIGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGUpKTtcblxuICAgICAgaWYgKCEodyBpbiBEKSAmJiAoISh3IGluIHNlZW4pIHx8IGNvc3QgPCBzZWVuW3ddKSkge1xuICAgICAgICBzZWVuW3ddID0gY29zdDtcbiAgICAgICAgUS5wdXNoKFtjb3N0LCBjb3VudCsrLCB2LCB3XSk7XG4gICAgICAgIHNpZ21hW3ddID0gMDtcbiAgICAgICAgUFt3XSA9IFt2XTtcbiAgICAgIH0gZWxzZSBpZiAoY29zdCA9PT0gc2Vlblt3XSkge1xuICAgICAgICBzaWdtYVt3XSArPSBzaWdtYVt2XTtcbiAgICAgICAgUFt3XS5wdXNoKHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbUywgUCwgc2lnbWFdO1xufVxuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xuZXhwb3J0cy5iaWRpcmVjdGlvbmFsID0gYmlkaXJlY3Rpb25hbERpamtzdHJhO1xuZXhwb3J0cy5zaW5nbGVTb3VyY2UgPSBzaW5nbGVTb3VyY2VEaWprc3RyYTtcbmV4cG9ydHMuYnJhbmRlcyA9IGJyYW5kZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-shortest-path/dijkstra.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-shortest-path/index.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-shortest-path/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology Shortest Path\n * =========================\n *\n * Library endpoint.\n */\nvar unweighted = __webpack_require__(/*! ./unweighted.js */ \"(ssr)/./node_modules/graphology-shortest-path/unweighted.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/graphology-shortest-path/utils.js\");\n\nexports.unweighted = unweighted;\nexports.dijkstra = __webpack_require__(/*! ./dijkstra.js */ \"(ssr)/./node_modules/graphology-shortest-path/dijkstra.js\");\nexports.astar = __webpack_require__(/*! ./astar.js */ \"(ssr)/./node_modules/graphology-shortest-path/astar.js\");\n\nexports.bidirectional = unweighted.bidirectional;\nexports.singleSource = unweighted.singleSource;\nexports.singleSourceLength = unweighted.singleSourceLength;\nexports.undirectedSingleSourceLength = unweighted.undirectedSingleSourceLength;\nexports.brandes = unweighted.brandes;\n\nexports.edgePathFromNodePath = utils.edgePathFromNodePath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFpQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsMEVBQVk7O0FBRWhDLGtCQUFrQjtBQUNsQix3SEFBMkM7QUFDM0MsK0dBQXFDOztBQUVyQyxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixvQ0FBb0M7QUFDcEMsZUFBZTs7QUFFZiw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL2luZGV4LmpzP2QxMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IFNob3J0ZXN0IFBhdGhcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBMaWJyYXJ5IGVuZHBvaW50LlxuICovXG52YXIgdW53ZWlnaHRlZCA9IHJlcXVpcmUoJy4vdW53ZWlnaHRlZC5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuXG5leHBvcnRzLnVud2VpZ2h0ZWQgPSB1bndlaWdodGVkO1xuZXhwb3J0cy5kaWprc3RyYSA9IHJlcXVpcmUoJy4vZGlqa3N0cmEuanMnKTtcbmV4cG9ydHMuYXN0YXIgPSByZXF1aXJlKCcuL2FzdGFyLmpzJyk7XG5cbmV4cG9ydHMuYmlkaXJlY3Rpb25hbCA9IHVud2VpZ2h0ZWQuYmlkaXJlY3Rpb25hbDtcbmV4cG9ydHMuc2luZ2xlU291cmNlID0gdW53ZWlnaHRlZC5zaW5nbGVTb3VyY2U7XG5leHBvcnRzLnNpbmdsZVNvdXJjZUxlbmd0aCA9IHVud2VpZ2h0ZWQuc2luZ2xlU291cmNlTGVuZ3RoO1xuZXhwb3J0cy51bmRpcmVjdGVkU2luZ2xlU291cmNlTGVuZ3RoID0gdW53ZWlnaHRlZC51bmRpcmVjdGVkU2luZ2xlU291cmNlTGVuZ3RoO1xuZXhwb3J0cy5icmFuZGVzID0gdW53ZWlnaHRlZC5icmFuZGVzO1xuXG5leHBvcnRzLmVkZ2VQYXRoRnJvbU5vZGVQYXRoID0gdXRpbHMuZWRnZVBhdGhGcm9tTm9kZVBhdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-shortest-path/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-shortest-path/unweighted.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphology-shortest-path/unweighted.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology Unweighted Shortest Path\n * ====================================\n *\n * Basic algorithms to find the shortest paths between nodes in a graph\n * whose edges are not weighted.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar Queue = __webpack_require__(/*! mnemonist/queue */ \"(ssr)/./node_modules/mnemonist/queue.js\");\nvar extend = __webpack_require__(/*! @yomguithereal/helpers/extend */ \"(ssr)/./node_modules/@yomguithereal/helpers/extend.js\");\n\n/**\n * Function attempting to find the shortest path in a graph between\n * given source & target or `null` if such a path does not exist.\n *\n * @param  {Graph}      graph  - Target graph.\n * @param  {any}        source - Source node.\n * @param  {any}        target - Target node.\n * @return {array|null}        - Found path or `null`.\n */\nfunction bidirectional(graph, source, target) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (arguments.length < 3)\n    throw new Error(\n      'graphology-shortest-path: invalid number of arguments. Expecting at least 3.'\n    );\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  if (!graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n  target = '' + target;\n\n  // TODO: do we need a self loop to go there?\n  if (source === target) {\n    return [source];\n  }\n\n  // Binding functions\n  var getPredecessors = graph.inboundNeighbors.bind(graph),\n    getSuccessors = graph.outboundNeighbors.bind(graph);\n\n  var predecessor = {},\n    successor = {};\n\n  // Predecessor & successor\n  predecessor[source] = null;\n  successor[target] = null;\n\n  // Fringes\n  var forwardFringe = [source],\n    reverseFringe = [target],\n    currentFringe,\n    node,\n    neighbors,\n    neighbor,\n    i,\n    j,\n    l,\n    m;\n\n  var found = false;\n\n  outer: while (forwardFringe.length && reverseFringe.length) {\n    if (forwardFringe.length <= reverseFringe.length) {\n      currentFringe = forwardFringe;\n      forwardFringe = [];\n\n      for (i = 0, l = currentFringe.length; i < l; i++) {\n        node = currentFringe[i];\n        neighbors = getSuccessors(node);\n\n        for (j = 0, m = neighbors.length; j < m; j++) {\n          neighbor = neighbors[j];\n\n          if (!(neighbor in predecessor)) {\n            forwardFringe.push(neighbor);\n            predecessor[neighbor] = node;\n          }\n\n          if (neighbor in successor) {\n            // Path is found!\n            found = true;\n            break outer;\n          }\n        }\n      }\n    } else {\n      currentFringe = reverseFringe;\n      reverseFringe = [];\n\n      for (i = 0, l = currentFringe.length; i < l; i++) {\n        node = currentFringe[i];\n        neighbors = getPredecessors(node);\n\n        for (j = 0, m = neighbors.length; j < m; j++) {\n          neighbor = neighbors[j];\n\n          if (!(neighbor in successor)) {\n            reverseFringe.push(neighbor);\n            successor[neighbor] = node;\n          }\n\n          if (neighbor in predecessor) {\n            // Path is found!\n            found = true;\n            break outer;\n          }\n        }\n      }\n    }\n  }\n\n  if (!found) return null;\n\n  var path = [];\n\n  while (neighbor) {\n    path.unshift(neighbor);\n    neighbor = predecessor[neighbor];\n  }\n\n  neighbor = successor[path[path.length - 1]];\n\n  while (neighbor) {\n    path.push(neighbor);\n    neighbor = successor[neighbor];\n  }\n\n  return path.length ? path : null;\n}\n\n/**\n * Function attempting to find the shortest path in the graph between the\n * given source node & all the other nodes.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @return {object}        - The map of found paths.\n */\n\n// TODO: cutoff option\nfunction singleSource(graph, source) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (arguments.length < 2)\n    throw new Error(\n      'graphology-shortest-path: invalid number of arguments. Expecting at least 2.'\n    );\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n\n  var nextLevel = {},\n    paths = {},\n    currentLevel,\n    neighbors,\n    v,\n    w,\n    i,\n    l;\n\n  nextLevel[source] = true;\n  paths[source] = [source];\n\n  while (Object.keys(nextLevel).length) {\n    currentLevel = nextLevel;\n    nextLevel = {};\n\n    for (v in currentLevel) {\n      neighbors = graph.outboundNeighbors(v);\n\n      for (i = 0, l = neighbors.length; i < l; i++) {\n        w = neighbors[i];\n\n        if (!paths[w]) {\n          paths[w] = paths[v].concat(w);\n          nextLevel[w] = true;\n        }\n      }\n    }\n  }\n\n  return paths;\n}\n\n/**\n * Function attempting to find the shortest path lengths in the graph between\n * the given source node & all the other nodes.\n *\n * @param  {string} method - Neighbor collection method name.\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @return {object}        - The map of found path lengths.\n */\n\n// TODO: cutoff option\nfunction asbtractSingleSourceLength(method, graph, source) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n\n  // Performing BFS to count shortest paths\n  var seen = new Set();\n\n  var lengths = {},\n    level = 0;\n\n  lengths[source] = 0;\n\n  var currentLevel = [source];\n\n  var i, l, node;\n\n  while (currentLevel.length !== 0) {\n    var nextLevel = [];\n\n    for (i = 0, l = currentLevel.length; i < l; i++) {\n      node = currentLevel[i];\n\n      if (seen.has(node)) continue;\n\n      seen.add(node);\n      extend(nextLevel, graph[method](node));\n\n      lengths[node] = level;\n    }\n\n    level++;\n    currentLevel = nextLevel;\n  }\n\n  return lengths;\n}\n\nvar singleSourceLength = asbtractSingleSourceLength.bind(\n  null,\n  'outboundNeighbors'\n);\nvar undirectedSingleSourceLength = asbtractSingleSourceLength.bind(\n  null,\n  'neighbors'\n);\n\n/**\n * Function using Ulrik Brandes' method to map single source shortest paths\n * from selected node.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}  graph      - Target graph.\n * @param  {any}    source     - Source node.\n * @return {array}             - [Stack, Paths, Sigma]\n */\nfunction brandes(graph, source) {\n  source = '' + source;\n\n  var S = [],\n    P = {},\n    sigma = {};\n\n  var nodes = graph.nodes(),\n    Dv,\n    sigmav,\n    neighbors,\n    v,\n    w,\n    i,\n    j,\n    l,\n    m;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    v = nodes[i];\n    P[v] = [];\n    sigma[v] = 0;\n  }\n\n  var D = {};\n\n  sigma[source] = 1;\n  D[source] = 0;\n\n  var queue = Queue.of(source);\n\n  while (queue.size) {\n    v = queue.dequeue();\n    S.push(v);\n\n    Dv = D[v];\n    sigmav = sigma[v];\n\n    neighbors = graph.outboundNeighbors(v);\n\n    for (j = 0, m = neighbors.length; j < m; j++) {\n      w = neighbors[j];\n\n      if (!(w in D)) {\n        queue.enqueue(w);\n        D[w] = Dv + 1;\n      }\n\n      if (D[w] === Dv + 1) {\n        sigma[w] += sigmav;\n        P[w].push(v);\n      }\n    }\n  }\n\n  return [S, P, sigma];\n}\n\n/**\n * Exporting.\n */\nexports.bidirectional = bidirectional;\nexports.singleSource = singleSource;\nexports.singleSourceLength = singleSourceLength;\nexports.undirectedSingleSourceLength = undirectedSingleSourceLength;\nexports.brandes = brandes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL3Vud2VpZ2h0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsb0ZBQTJCO0FBQ2pELFlBQVksbUJBQU8sQ0FBQyxnRUFBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDRGQUErQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsb0NBQW9DO0FBQ3BDLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL3Vud2VpZ2h0ZWQuanM/ODhlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyYXBob2xvZ3kgVW53ZWlnaHRlZCBTaG9ydGVzdCBQYXRoXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCYXNpYyBhbGdvcml0aG1zIHRvIGZpbmQgdGhlIHNob3J0ZXN0IHBhdGhzIGJldHdlZW4gbm9kZXMgaW4gYSBncmFwaFxuICogd2hvc2UgZWRnZXMgYXJlIG5vdCB3ZWlnaHRlZC5cbiAqL1xudmFyIGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCdtbmVtb25pc3QvcXVldWUnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdAeW9tZ3VpdGhlcmVhbC9oZWxwZXJzL2V4dGVuZCcpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGVtcHRpbmcgdG8gZmluZCB0aGUgc2hvcnRlc3QgcGF0aCBpbiBhIGdyYXBoIGJldHdlZW5cbiAqIGdpdmVuIHNvdXJjZSAmIHRhcmdldCBvciBgbnVsbGAgaWYgc3VjaCBhIHBhdGggZG9lcyBub3QgZXhpc3QuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgICAgZ3JhcGggIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICAgICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAqIEByZXR1cm4ge2FycmF5fG51bGx9ICAgICAgICAtIEZvdW5kIHBhdGggb3IgYG51bGxgLlxuICovXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsKGdyYXBoLCBzb3VyY2UsIHRhcmdldCkge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcignZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoOiBpbnZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJyk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LXNob3J0ZXN0LXBhdGg6IGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cy4gRXhwZWN0aW5nIGF0IGxlYXN0IDMuJ1xuICAgICk7XG5cbiAgaWYgKCFncmFwaC5oYXNOb2RlKHNvdXJjZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aDogdGhlIFwiJyArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdcIiBzb3VyY2Ugbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gZ3JhcGguJ1xuICAgICk7XG5cbiAgaWYgKCFncmFwaC5oYXNOb2RlKHRhcmdldCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aDogdGhlIFwiJyArXG4gICAgICAgIHRhcmdldCArXG4gICAgICAgICdcIiB0YXJnZXQgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gZ3JhcGguJ1xuICAgICk7XG5cbiAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gIC8vIFRPRE86IGRvIHdlIG5lZWQgYSBzZWxmIGxvb3AgdG8gZ28gdGhlcmU/XG4gIGlmIChzb3VyY2UgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBbc291cmNlXTtcbiAgfVxuXG4gIC8vIEJpbmRpbmcgZnVuY3Rpb25zXG4gIHZhciBnZXRQcmVkZWNlc3NvcnMgPSBncmFwaC5pbmJvdW5kTmVpZ2hib3JzLmJpbmQoZ3JhcGgpLFxuICAgIGdldFN1Y2Nlc3NvcnMgPSBncmFwaC5vdXRib3VuZE5laWdoYm9ycy5iaW5kKGdyYXBoKTtcblxuICB2YXIgcHJlZGVjZXNzb3IgPSB7fSxcbiAgICBzdWNjZXNzb3IgPSB7fTtcblxuICAvLyBQcmVkZWNlc3NvciAmIHN1Y2Nlc3NvclxuICBwcmVkZWNlc3Nvcltzb3VyY2VdID0gbnVsbDtcbiAgc3VjY2Vzc29yW3RhcmdldF0gPSBudWxsO1xuXG4gIC8vIEZyaW5nZXNcbiAgdmFyIGZvcndhcmRGcmluZ2UgPSBbc291cmNlXSxcbiAgICByZXZlcnNlRnJpbmdlID0gW3RhcmdldF0sXG4gICAgY3VycmVudEZyaW5nZSxcbiAgICBub2RlLFxuICAgIG5laWdoYm9ycyxcbiAgICBuZWlnaGJvcixcbiAgICBpLFxuICAgIGosXG4gICAgbCxcbiAgICBtO1xuXG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gIG91dGVyOiB3aGlsZSAoZm9yd2FyZEZyaW5nZS5sZW5ndGggJiYgcmV2ZXJzZUZyaW5nZS5sZW5ndGgpIHtcbiAgICBpZiAoZm9yd2FyZEZyaW5nZS5sZW5ndGggPD0gcmV2ZXJzZUZyaW5nZS5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnRGcmluZ2UgPSBmb3J3YXJkRnJpbmdlO1xuICAgICAgZm9yd2FyZEZyaW5nZSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gY3VycmVudEZyaW5nZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IGN1cnJlbnRGcmluZ2VbaV07XG4gICAgICAgIG5laWdoYm9ycyA9IGdldFN1Y2Nlc3NvcnMobm9kZSk7XG5cbiAgICAgICAgZm9yIChqID0gMCwgbSA9IG5laWdoYm9ycy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcblxuICAgICAgICAgIGlmICghKG5laWdoYm9yIGluIHByZWRlY2Vzc29yKSkge1xuICAgICAgICAgICAgZm9yd2FyZEZyaW5nZS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yW25laWdoYm9yXSA9IG5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5laWdoYm9yIGluIHN1Y2Nlc3Nvcikge1xuICAgICAgICAgICAgLy8gUGF0aCBpcyBmb3VuZCFcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RnJpbmdlID0gcmV2ZXJzZUZyaW5nZTtcbiAgICAgIHJldmVyc2VGcmluZ2UgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGN1cnJlbnRGcmluZ2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBjdXJyZW50RnJpbmdlW2ldO1xuICAgICAgICBuZWlnaGJvcnMgPSBnZXRQcmVkZWNlc3NvcnMobm9kZSk7XG5cbiAgICAgICAgZm9yIChqID0gMCwgbSA9IG5laWdoYm9ycy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcblxuICAgICAgICAgIGlmICghKG5laWdoYm9yIGluIHN1Y2Nlc3NvcikpIHtcbiAgICAgICAgICAgIHJldmVyc2VGcmluZ2UucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICBzdWNjZXNzb3JbbmVpZ2hib3JdID0gbm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVpZ2hib3IgaW4gcHJlZGVjZXNzb3IpIHtcbiAgICAgICAgICAgIC8vIFBhdGggaXMgZm91bmQhXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWZvdW5kKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcGF0aCA9IFtdO1xuXG4gIHdoaWxlIChuZWlnaGJvcikge1xuICAgIHBhdGgudW5zaGlmdChuZWlnaGJvcik7XG4gICAgbmVpZ2hib3IgPSBwcmVkZWNlc3NvcltuZWlnaGJvcl07XG4gIH1cblxuICBuZWlnaGJvciA9IHN1Y2Nlc3NvcltwYXRoW3BhdGgubGVuZ3RoIC0gMV1dO1xuXG4gIHdoaWxlIChuZWlnaGJvcikge1xuICAgIHBhdGgucHVzaChuZWlnaGJvcik7XG4gICAgbmVpZ2hib3IgPSBzdWNjZXNzb3JbbmVpZ2hib3JdO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgubGVuZ3RoID8gcGF0aCA6IG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0ZW1wdGluZyB0byBmaW5kIHRoZSBzaG9ydGVzdCBwYXRoIGluIHRoZSBncmFwaCBiZXR3ZWVuIHRoZVxuICogZ2l2ZW4gc291cmNlIG5vZGUgJiBhbGwgdGhlIG90aGVyIG5vZGVzLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIC0gVGhlIG1hcCBvZiBmb3VuZCBwYXRocy5cbiAqL1xuXG4vLyBUT0RPOiBjdXRvZmYgb3B0aW9uXG5mdW5jdGlvbiBzaW5nbGVTb3VyY2UoZ3JhcGgsIHNvdXJjZSkge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcignZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoOiBpbnZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJyk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LXNob3J0ZXN0LXBhdGg6IGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cy4gRXhwZWN0aW5nIGF0IGxlYXN0IDIuJ1xuICAgICk7XG5cbiAgaWYgKCFncmFwaC5oYXNOb2RlKHNvdXJjZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktc2hvcnRlc3QtcGF0aDogdGhlIFwiJyArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdcIiBzb3VyY2Ugbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gZ3JhcGguJ1xuICAgICk7XG5cbiAgc291cmNlID0gJycgKyBzb3VyY2U7XG5cbiAgdmFyIG5leHRMZXZlbCA9IHt9LFxuICAgIHBhdGhzID0ge30sXG4gICAgY3VycmVudExldmVsLFxuICAgIG5laWdoYm9ycyxcbiAgICB2LFxuICAgIHcsXG4gICAgaSxcbiAgICBsO1xuXG4gIG5leHRMZXZlbFtzb3VyY2VdID0gdHJ1ZTtcbiAgcGF0aHNbc291cmNlXSA9IFtzb3VyY2VdO1xuXG4gIHdoaWxlIChPYmplY3Qua2V5cyhuZXh0TGV2ZWwpLmxlbmd0aCkge1xuICAgIGN1cnJlbnRMZXZlbCA9IG5leHRMZXZlbDtcbiAgICBuZXh0TGV2ZWwgPSB7fTtcblxuICAgIGZvciAodiBpbiBjdXJyZW50TGV2ZWwpIHtcbiAgICAgIG5laWdoYm9ycyA9IGdyYXBoLm91dGJvdW5kTmVpZ2hib3JzKHYpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB3ID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgIGlmICghcGF0aHNbd10pIHtcbiAgICAgICAgICBwYXRoc1t3XSA9IHBhdGhzW3ZdLmNvbmNhdCh3KTtcbiAgICAgICAgICBuZXh0TGV2ZWxbd10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGVtcHRpbmcgdG8gZmluZCB0aGUgc2hvcnRlc3QgcGF0aCBsZW5ndGhzIGluIHRoZSBncmFwaCBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gc291cmNlIG5vZGUgJiBhbGwgdGhlIG90aGVyIG5vZGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kIC0gTmVpZ2hib3IgY29sbGVjdGlvbiBtZXRob2QgbmFtZS5cbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIC0gVGhlIG1hcCBvZiBmb3VuZCBwYXRoIGxlbmd0aHMuXG4gKi9cblxuLy8gVE9ETzogY3V0b2ZmIG9wdGlvblxuZnVuY3Rpb24gYXNidHJhY3RTaW5nbGVTb3VyY2VMZW5ndGgobWV0aG9kLCBncmFwaCwgc291cmNlKSB7XG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmFwaG9sb2d5LXNob3J0ZXN0LXBhdGg6IGludmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZS4nKTtcblxuICBpZiAoIWdyYXBoLmhhc05vZGUoc291cmNlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoOiB0aGUgXCInICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ1wiIHNvdXJjZSBub2RlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBnaXZlbiBncmFwaC4nXG4gICAgKTtcblxuICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcblxuICAvLyBQZXJmb3JtaW5nIEJGUyB0byBjb3VudCBzaG9ydGVzdCBwYXRoc1xuICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcblxuICB2YXIgbGVuZ3RocyA9IHt9LFxuICAgIGxldmVsID0gMDtcblxuICBsZW5ndGhzW3NvdXJjZV0gPSAwO1xuXG4gIHZhciBjdXJyZW50TGV2ZWwgPSBbc291cmNlXTtcblxuICB2YXIgaSwgbCwgbm9kZTtcblxuICB3aGlsZSAoY3VycmVudExldmVsLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBuZXh0TGV2ZWwgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBjdXJyZW50TGV2ZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBub2RlID0gY3VycmVudExldmVsW2ldO1xuXG4gICAgICBpZiAoc2Vlbi5oYXMobm9kZSkpIGNvbnRpbnVlO1xuXG4gICAgICBzZWVuLmFkZChub2RlKTtcbiAgICAgIGV4dGVuZChuZXh0TGV2ZWwsIGdyYXBoW21ldGhvZF0obm9kZSkpO1xuXG4gICAgICBsZW5ndGhzW25vZGVdID0gbGV2ZWw7XG4gICAgfVxuXG4gICAgbGV2ZWwrKztcbiAgICBjdXJyZW50TGV2ZWwgPSBuZXh0TGV2ZWw7XG4gIH1cblxuICByZXR1cm4gbGVuZ3Rocztcbn1cblxudmFyIHNpbmdsZVNvdXJjZUxlbmd0aCA9IGFzYnRyYWN0U2luZ2xlU291cmNlTGVuZ3RoLmJpbmQoXG4gIG51bGwsXG4gICdvdXRib3VuZE5laWdoYm9ycydcbik7XG52YXIgdW5kaXJlY3RlZFNpbmdsZVNvdXJjZUxlbmd0aCA9IGFzYnRyYWN0U2luZ2xlU291cmNlTGVuZ3RoLmJpbmQoXG4gIG51bGwsXG4gICduZWlnaGJvcnMnXG4pO1xuXG4vKipcbiAqIEZ1bmN0aW9uIHVzaW5nIFVscmlrIEJyYW5kZXMnIG1ldGhvZCB0byBtYXAgc2luZ2xlIHNvdXJjZSBzaG9ydGVzdCBwYXRoc1xuICogZnJvbSBzZWxlY3RlZCBub2RlLlxuICpcbiAqIFtSZWZlcmVuY2VdOlxuICogVWxyaWsgQnJhbmRlczogQSBGYXN0ZXIgQWxnb3JpdGhtIGZvciBCZXR3ZWVubmVzcyBDZW50cmFsaXR5LlxuICogSm91cm5hbCBvZiBNYXRoZW1hdGljYWwgU29jaW9sb2d5IDI1KDIpOjE2My0xNzcsIDIwMDEuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICBncmFwaCAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgICAgIC0gU291cmNlIG5vZGUuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgLSBbU3RhY2ssIFBhdGhzLCBTaWdtYV1cbiAqL1xuZnVuY3Rpb24gYnJhbmRlcyhncmFwaCwgc291cmNlKSB7XG4gIHNvdXJjZSA9ICcnICsgc291cmNlO1xuXG4gIHZhciBTID0gW10sXG4gICAgUCA9IHt9LFxuICAgIHNpZ21hID0ge307XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKSxcbiAgICBEdixcbiAgICBzaWdtYXYsXG4gICAgbmVpZ2hib3JzLFxuICAgIHYsXG4gICAgdyxcbiAgICBpLFxuICAgIGosXG4gICAgbCxcbiAgICBtO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2ID0gbm9kZXNbaV07XG4gICAgUFt2XSA9IFtdO1xuICAgIHNpZ21hW3ZdID0gMDtcbiAgfVxuXG4gIHZhciBEID0ge307XG5cbiAgc2lnbWFbc291cmNlXSA9IDE7XG4gIERbc291cmNlXSA9IDA7XG5cbiAgdmFyIHF1ZXVlID0gUXVldWUub2Yoc291cmNlKTtcblxuICB3aGlsZSAocXVldWUuc2l6ZSkge1xuICAgIHYgPSBxdWV1ZS5kZXF1ZXVlKCk7XG4gICAgUy5wdXNoKHYpO1xuXG4gICAgRHYgPSBEW3ZdO1xuICAgIHNpZ21hdiA9IHNpZ21hW3ZdO1xuXG4gICAgbmVpZ2hib3JzID0gZ3JhcGgub3V0Ym91bmROZWlnaGJvcnModik7XG5cbiAgICBmb3IgKGogPSAwLCBtID0gbmVpZ2hib3JzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgdyA9IG5laWdoYm9yc1tqXTtcblxuICAgICAgaWYgKCEodyBpbiBEKSkge1xuICAgICAgICBxdWV1ZS5lbnF1ZXVlKHcpO1xuICAgICAgICBEW3ddID0gRHYgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoRFt3XSA9PT0gRHYgKyAxKSB7XG4gICAgICAgIHNpZ21hW3ddICs9IHNpZ21hdjtcbiAgICAgICAgUFt3XS5wdXNoKHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbUywgUCwgc2lnbWFdO1xufVxuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xuZXhwb3J0cy5iaWRpcmVjdGlvbmFsID0gYmlkaXJlY3Rpb25hbDtcbmV4cG9ydHMuc2luZ2xlU291cmNlID0gc2luZ2xlU291cmNlO1xuZXhwb3J0cy5zaW5nbGVTb3VyY2VMZW5ndGggPSBzaW5nbGVTb3VyY2VMZW5ndGg7XG5leHBvcnRzLnVuZGlyZWN0ZWRTaW5nbGVTb3VyY2VMZW5ndGggPSB1bmRpcmVjdGVkU2luZ2xlU291cmNlTGVuZ3RoO1xuZXhwb3J0cy5icmFuZGVzID0gYnJhbmRlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-shortest-path/unweighted.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-shortest-path/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-shortest-path/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Graphology Shortest Path Utils\n * ===============================\n *\n * Miscellaneous shortest-path helper functions.\n */\nvar returnTrue = function () {\n  return true;\n};\n\nexports.edgePathFromNodePath = function (graph, nodePath) {\n  var l = nodePath.length;\n\n  var i, source, target, edge;\n\n  // Self loops\n  if (l < 2) {\n    source = nodePath[0];\n\n    edge = graph.multi\n      ? graph.findEdge(source, source, returnTrue)\n      : graph.edge(source, source);\n\n    if (edge) return [edge];\n\n    return [];\n  }\n\n  l--;\n\n  var edgePath = new Array(l);\n\n  for (i = 0; i < l; i++) {\n    source = nodePath[i];\n    target = nodePath[i + 1];\n\n    edge = graph.multi\n      ? graph.findOutboundEdge(source, target, returnTrue)\n      : graph.edge(source, target);\n\n    if (edge === undefined)\n      throw new Error(\n        'graphology-shortest-path: given path is impossible in given graph.'\n      );\n\n    edgePath[i] = edge;\n  }\n\n  return edgePath;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoL3V0aWxzLmpzPzE0ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IFNob3J0ZXN0IFBhdGggVXRpbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBNaXNjZWxsYW5lb3VzIHNob3J0ZXN0LXBhdGggaGVscGVyIGZ1bmN0aW9ucy5cbiAqL1xudmFyIHJldHVyblRydWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5lZGdlUGF0aEZyb21Ob2RlUGF0aCA9IGZ1bmN0aW9uIChncmFwaCwgbm9kZVBhdGgpIHtcbiAgdmFyIGwgPSBub2RlUGF0aC5sZW5ndGg7XG5cbiAgdmFyIGksIHNvdXJjZSwgdGFyZ2V0LCBlZGdlO1xuXG4gIC8vIFNlbGYgbG9vcHNcbiAgaWYgKGwgPCAyKSB7XG4gICAgc291cmNlID0gbm9kZVBhdGhbMF07XG5cbiAgICBlZGdlID0gZ3JhcGgubXVsdGlcbiAgICAgID8gZ3JhcGguZmluZEVkZ2Uoc291cmNlLCBzb3VyY2UsIHJldHVyblRydWUpXG4gICAgICA6IGdyYXBoLmVkZ2Uoc291cmNlLCBzb3VyY2UpO1xuXG4gICAgaWYgKGVkZ2UpIHJldHVybiBbZWRnZV07XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBsLS07XG5cbiAgdmFyIGVkZ2VQYXRoID0gbmV3IEFycmF5KGwpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBzb3VyY2UgPSBub2RlUGF0aFtpXTtcbiAgICB0YXJnZXQgPSBub2RlUGF0aFtpICsgMV07XG5cbiAgICBlZGdlID0gZ3JhcGgubXVsdGlcbiAgICAgID8gZ3JhcGguZmluZE91dGJvdW5kRWRnZShzb3VyY2UsIHRhcmdldCwgcmV0dXJuVHJ1ZSlcbiAgICAgIDogZ3JhcGguZWRnZShzb3VyY2UsIHRhcmdldCk7XG5cbiAgICBpZiAoZWRnZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZ3JhcGhvbG9neS1zaG9ydGVzdC1wYXRoOiBnaXZlbiBwYXRoIGlzIGltcG9zc2libGUgaW4gZ2l2ZW4gZ3JhcGguJ1xuICAgICAgKTtcblxuICAgIGVkZ2VQYXRoW2ldID0gZWRnZTtcbiAgfVxuXG4gIHJldHVybiBlZGdlUGF0aDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-shortest-path/utils.js\n");

/***/ })

};
;