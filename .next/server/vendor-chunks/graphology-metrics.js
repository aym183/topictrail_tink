/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-metrics";
exports.ids = ["vendor-chunks/graphology-metrics"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-metrics/centrality/degree.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphology-metrics/centrality/degree.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology Degree Centrality\n * =============================\n *\n * Function computing degree centrality.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\n\n/**\n * Asbtract function to perform any kind of degree centrality.\n *\n * Intuitively, the degree centrality of a node is the fraction of nodes it\n * is connected to.\n *\n * @param  {boolean} assign           - Whether to assign the result to the nodes.\n * @param  {string}  method           - Method of the graph to get the degree.\n * @param  {Graph}   graph            - A graphology instance.\n * @param  {object}  [options]        - Options:\n * @param  {string}    [nodeCentralityAttribute] - Name of the attribute to assign.\n * @return {object|void}\n */\nfunction abstractDegreeCentrality(assign, method, graph, options) {\n  var name = method + 'Centrality';\n\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-centrality/' +\n        name +\n        ': the given graph is not a valid graphology instance.'\n    );\n\n  if (method !== 'degree' && graph.type === 'undirected')\n    throw new Error(\n      'graphology-centrality/' +\n        name +\n        ': cannot compute ' +\n        method +\n        ' centrality on an undirected graph.'\n    );\n\n  // Solving options\n  options = options || {};\n\n  var centralityAttribute = options.nodeCentralityAttribute || name;\n\n  var ratio = graph.order - 1;\n  var getDegree = graph[method].bind(graph);\n\n  if (assign) {\n    graph.updateEachNodeAttributes(\n      function (node, attr) {\n        attr[centralityAttribute] = getDegree(node) / ratio;\n        return attr;\n      },\n      {attributes: [centralityAttribute]}\n    );\n\n    return;\n  }\n\n  var centralities = {};\n\n  graph.forEachNode(function (node) {\n    centralities[node] = getDegree(node) / ratio;\n  });\n\n  return centralities;\n}\n\n/**\n * Building various functions to export.\n */\nvar degreeCentrality = abstractDegreeCentrality.bind(null, false, 'degree');\nvar inDegreeCentrality = abstractDegreeCentrality.bind(null, false, 'inDegree');\nvar outDegreeCentrality = abstractDegreeCentrality.bind(\n  null,\n  false,\n  'outDegree'\n);\n\ndegreeCentrality.assign = abstractDegreeCentrality.bind(null, true, 'degree');\ninDegreeCentrality.assign = abstractDegreeCentrality.bind(\n  null,\n  true,\n  'inDegree'\n);\noutDegreeCentrality.assign = abstractDegreeCentrality.bind(\n  null,\n  true,\n  'outDegree'\n);\n\n/**\n * Exporting.\n */\nexports.degreeCentrality = degreeCentrality;\nexports.inDegreeCentrality = inDegreeCentrality;\nexports.outDegreeCentrality = outDegreeCentrality;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1tZXRyaWNzL2NlbnRyYWxpdHkvZGVncmVlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvRkFBMkI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFdBQVc7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQiwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1tZXRyaWNzL2NlbnRyYWxpdHkvZGVncmVlLmpzPzZjZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IERlZ3JlZSBDZW50cmFsaXR5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIGNvbXB1dGluZyBkZWdyZWUgY2VudHJhbGl0eS5cbiAqL1xudmFyIGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG5cbi8qKlxuICogQXNidHJhY3QgZnVuY3Rpb24gdG8gcGVyZm9ybSBhbnkga2luZCBvZiBkZWdyZWUgY2VudHJhbGl0eS5cbiAqXG4gKiBJbnR1aXRpdmVseSwgdGhlIGRlZ3JlZSBjZW50cmFsaXR5IG9mIGEgbm9kZSBpcyB0aGUgZnJhY3Rpb24gb2Ygbm9kZXMgaXRcbiAqIGlzIGNvbm5lY3RlZCB0by5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSBhc3NpZ24gICAgICAgICAgIC0gV2hldGhlciB0byBhc3NpZ24gdGhlIHJlc3VsdCB0byB0aGUgbm9kZXMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBtZXRob2QgICAgICAgICAgIC0gTWV0aG9kIG9mIHRoZSBncmFwaCB0byBnZXQgdGhlIGRlZ3JlZS5cbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoICAgICAgICAgICAgLSBBIGdyYXBob2xvZ3kgaW5zdGFuY2UuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbb3B0aW9uc10gICAgICAgIC0gT3B0aW9uczpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgW25vZGVDZW50cmFsaXR5QXR0cmlidXRlXSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBhc3NpZ24uXG4gKiBAcmV0dXJuIHtvYmplY3R8dm9pZH1cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3REZWdyZWVDZW50cmFsaXR5KGFzc2lnbiwgbWV0aG9kLCBncmFwaCwgb3B0aW9ucykge1xuICB2YXIgbmFtZSA9IG1ldGhvZCArICdDZW50cmFsaXR5JztcblxuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWNlbnRyYWxpdHkvJyArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAnOiB0aGUgZ2l2ZW4gZ3JhcGggaXMgbm90IGEgdmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZS4nXG4gICAgKTtcblxuICBpZiAobWV0aG9kICE9PSAnZGVncmVlJyAmJiBncmFwaC50eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktY2VudHJhbGl0eS8nICtcbiAgICAgICAgbmFtZSArXG4gICAgICAgICc6IGNhbm5vdCBjb21wdXRlICcgK1xuICAgICAgICBtZXRob2QgK1xuICAgICAgICAnIGNlbnRyYWxpdHkgb24gYW4gdW5kaXJlY3RlZCBncmFwaC4nXG4gICAgKTtcblxuICAvLyBTb2x2aW5nIG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNlbnRyYWxpdHlBdHRyaWJ1dGUgPSBvcHRpb25zLm5vZGVDZW50cmFsaXR5QXR0cmlidXRlIHx8IG5hbWU7XG5cbiAgdmFyIHJhdGlvID0gZ3JhcGgub3JkZXIgLSAxO1xuICB2YXIgZ2V0RGVncmVlID0gZ3JhcGhbbWV0aG9kXS5iaW5kKGdyYXBoKTtcblxuICBpZiAoYXNzaWduKSB7XG4gICAgZ3JhcGgudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzKFxuICAgICAgZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgYXR0cltjZW50cmFsaXR5QXR0cmlidXRlXSA9IGdldERlZ3JlZShub2RlKSAvIHJhdGlvO1xuICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgIH0sXG4gICAgICB7YXR0cmlidXRlczogW2NlbnRyYWxpdHlBdHRyaWJ1dGVdfVxuICAgICk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2VudHJhbGl0aWVzID0ge307XG5cbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBjZW50cmFsaXRpZXNbbm9kZV0gPSBnZXREZWdyZWUobm9kZSkgLyByYXRpbztcbiAgfSk7XG5cbiAgcmV0dXJuIGNlbnRyYWxpdGllcztcbn1cblxuLyoqXG4gKiBCdWlsZGluZyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBleHBvcnQuXG4gKi9cbnZhciBkZWdyZWVDZW50cmFsaXR5ID0gYWJzdHJhY3REZWdyZWVDZW50cmFsaXR5LmJpbmQobnVsbCwgZmFsc2UsICdkZWdyZWUnKTtcbnZhciBpbkRlZ3JlZUNlbnRyYWxpdHkgPSBhYnN0cmFjdERlZ3JlZUNlbnRyYWxpdHkuYmluZChudWxsLCBmYWxzZSwgJ2luRGVncmVlJyk7XG52YXIgb3V0RGVncmVlQ2VudHJhbGl0eSA9IGFic3RyYWN0RGVncmVlQ2VudHJhbGl0eS5iaW5kKFxuICBudWxsLFxuICBmYWxzZSxcbiAgJ291dERlZ3JlZSdcbik7XG5cbmRlZ3JlZUNlbnRyYWxpdHkuYXNzaWduID0gYWJzdHJhY3REZWdyZWVDZW50cmFsaXR5LmJpbmQobnVsbCwgdHJ1ZSwgJ2RlZ3JlZScpO1xuaW5EZWdyZWVDZW50cmFsaXR5LmFzc2lnbiA9IGFic3RyYWN0RGVncmVlQ2VudHJhbGl0eS5iaW5kKFxuICBudWxsLFxuICB0cnVlLFxuICAnaW5EZWdyZWUnXG4pO1xub3V0RGVncmVlQ2VudHJhbGl0eS5hc3NpZ24gPSBhYnN0cmFjdERlZ3JlZUNlbnRyYWxpdHkuYmluZChcbiAgbnVsbCxcbiAgdHJ1ZSxcbiAgJ291dERlZ3JlZSdcbik7XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG5leHBvcnRzLmRlZ3JlZUNlbnRyYWxpdHkgPSBkZWdyZWVDZW50cmFsaXR5O1xuZXhwb3J0cy5pbkRlZ3JlZUNlbnRyYWxpdHkgPSBpbkRlZ3JlZUNlbnRyYWxpdHk7XG5leHBvcnRzLm91dERlZ3JlZUNlbnRyYWxpdHkgPSBvdXREZWdyZWVDZW50cmFsaXR5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-metrics/centrality/degree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-metrics/centrality/pagerank.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphology-metrics/centrality/pagerank.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology Pagerank\n * ====================\n *\n * JavaScript implementation of the pagerank algorithm for graphology.\n *\n * [Reference]:\n * Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\n * The PageRank citation ranking: Bringing order to the Web. 1999\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ \"(ssr)/./node_modules/graphology-utils/defaults.js\");\nvar WeightedNeighborhoodIndex =\n  (__webpack_require__(/*! graphology-indices/neighborhood */ \"(ssr)/./node_modules/graphology-indices/neighborhood.js\").WeightedNeighborhoodIndex);\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodePagerankAttribute: 'pagerank',\n  getEdgeWeight: 'weight',\n  alpha: 0.85,\n  maxIterations: 100,\n  tolerance: 1e-6\n};\n\n/**\n * Abstract function applying the pagerank algorithm to the given graph.\n *\n * @param  {boolean}  assign        - Should we assign the result to nodes.\n * @param  {Graph}    graph         - Target graph.\n * @param  {?object}  option        - Options:\n * @param  {?object}    attributes  - Custom attribute names:\n * @param  {?string}      pagerank  - Name of the pagerank attribute to assign.\n * @param  {?string}      weight    - Name of the weight algorithm.\n * @param  {?number}  alpha         - Damping parameter.\n * @param  {?number}  maxIterations - Maximum number of iterations to perform.\n * @param  {?number}  tolerance     - Error tolerance when checking for convergence.\n * @param  {?boolean} weighted      - Should we use the graph's weights.\n * @return {object|undefined}\n */\nfunction abstractPagerank(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-metrics/centrality/pagerank: the given graph is not a valid graphology instance.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var alpha = options.alpha;\n  var maxIterations = options.maxIterations;\n  var tolerance = options.tolerance;\n\n  var pagerankAttribute = options.nodePagerankAttribute;\n\n  var N = graph.order;\n  var p = 1 / N;\n\n  var index = new WeightedNeighborhoodIndex(graph, options.getEdgeWeight);\n\n  var i, j, l, d;\n\n  var x = new Float64Array(graph.order);\n\n  // Normalizing edge weights & indexing dangling nodes\n  var normalizedEdgeWeights = new Float64Array(index.weights.length);\n  var danglingNodes = [];\n\n  for (i = 0; i < N; i++) {\n    x[i] = p;\n    l = index.starts[i + 1];\n    d = index.outDegrees[i];\n\n    if (d === 0) danglingNodes.push(i);\n\n    for (j = index.starts[i]; j < l; j++) {\n      normalizedEdgeWeights[j] = index.weights[j] / d;\n    }\n  }\n\n  // Power iterations\n  var iteration = 0;\n  var error = 0;\n  var dangleSum, neighbor, xLast;\n  var converged = false;\n\n  while (iteration < maxIterations) {\n    xLast = x;\n    x = new Float64Array(graph.order); // TODO: it should be possible to swap two arrays to avoid allocations (bench)\n\n    dangleSum = 0;\n\n    for (i = 0, l = danglingNodes.length; i < l; i++)\n      dangleSum += xLast[danglingNodes[i]];\n\n    dangleSum *= alpha;\n\n    for (i = 0; i < N; i++) {\n      l = index.starts[i + 1];\n\n      for (j = index.starts[i]; j < l; j++) {\n        neighbor = index.neighborhood[j];\n        x[neighbor] += alpha * xLast[i] * normalizedEdgeWeights[j];\n      }\n\n      x[i] += dangleSum * p + (1 - alpha) * p;\n    }\n\n    // Checking convergence\n    error = 0;\n\n    for (i = 0; i < N; i++) {\n      error += Math.abs(x[i] - xLast[i]);\n    }\n\n    if (error < N * tolerance) {\n      converged = true;\n      break;\n    }\n\n    iteration++;\n  }\n\n  if (!converged)\n    throw Error('graphology-metrics/centrality/pagerank: failed to converge.');\n\n  if (assign) {\n    index.assign(pagerankAttribute, x);\n    return;\n  }\n\n  return index.collect(x);\n}\n\n/**\n * Exporting.\n */\nvar pagerank = abstractPagerank.bind(null, false);\npagerank.assign = abstractPagerank.bind(null, true);\n\nmodule.exports = pagerank;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1tZXRyaWNzL2NlbnRyYWxpdHkvcGFnZXJhbmsuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9GQUEyQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBMkI7QUFDekQ7QUFDQSxFQUFFLGlKQUFvRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7O0FBRUE7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1tZXRyaWNzL2NlbnRyYWxpdHkvcGFnZXJhbmsuanM/NDIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyYXBob2xvZ3kgUGFnZXJhbmtcbiAqID09PT09PT09PT09PT09PT09PT09XG4gKlxuICogSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcGFnZXJhbmsgYWxnb3JpdGhtIGZvciBncmFwaG9sb2d5LlxuICpcbiAqIFtSZWZlcmVuY2VdOlxuICogUGFnZSwgTGF3cmVuY2U7IEJyaW4sIFNlcmdleTsgTW90d2FuaSwgUmFqZWV2IGFuZCBXaW5vZ3JhZCwgVGVycnksXG4gKiBUaGUgUGFnZVJhbmsgY2l0YXRpb24gcmFua2luZzogQnJpbmdpbmcgb3JkZXIgdG8gdGhlIFdlYi4gMTk5OVxuICovXG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcbnZhciByZXNvbHZlRGVmYXVsdHMgPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2RlZmF1bHRzJyk7XG52YXIgV2VpZ2h0ZWROZWlnaGJvcmhvb2RJbmRleCA9XG4gIHJlcXVpcmUoJ2dyYXBob2xvZ3ktaW5kaWNlcy9uZWlnaGJvcmhvb2QnKS5XZWlnaHRlZE5laWdoYm9yaG9vZEluZGV4O1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gIG5vZGVQYWdlcmFua0F0dHJpYnV0ZTogJ3BhZ2VyYW5rJyxcbiAgZ2V0RWRnZVdlaWdodDogJ3dlaWdodCcsXG4gIGFscGhhOiAwLjg1LFxuICBtYXhJdGVyYXRpb25zOiAxMDAsXG4gIHRvbGVyYW5jZTogMWUtNlxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBmdW5jdGlvbiBhcHBseWluZyB0aGUgcGFnZXJhbmsgYWxnb3JpdGhtIHRvIHRoZSBnaXZlbiBncmFwaC5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYXNzaWduICAgICAgICAtIFNob3VsZCB3ZSBhc3NpZ24gdGhlIHJlc3VsdCB0byBub2Rlcy5cbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbiAgICAgICAgLSBPcHRpb25zOlxuICogQHBhcmFtICB7P29iamVjdH0gICAgYXR0cmlidXRlcyAgLSBDdXN0b20gYXR0cmlidXRlIG5hbWVzOlxuICogQHBhcmFtICB7P3N0cmluZ30gICAgICBwYWdlcmFuayAgLSBOYW1lIG9mIHRoZSBwYWdlcmFuayBhdHRyaWJ1dGUgdG8gYXNzaWduLlxuICogQHBhcmFtICB7P3N0cmluZ30gICAgICB3ZWlnaHQgICAgLSBOYW1lIG9mIHRoZSB3ZWlnaHQgYWxnb3JpdGhtLlxuICogQHBhcmFtICB7P251bWJlcn0gIGFscGhhICAgICAgICAgLSBEYW1waW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSAgez9udW1iZXJ9ICBtYXhJdGVyYXRpb25zIC0gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLlxuICogQHBhcmFtICB7P251bWJlcn0gIHRvbGVyYW5jZSAgICAgLSBFcnJvciB0b2xlcmFuY2Ugd2hlbiBjaGVja2luZyBmb3IgY29udmVyZ2VuY2UuXG4gKiBAcGFyYW0gIHs/Ym9vbGVhbn0gd2VpZ2h0ZWQgICAgICAtIFNob3VsZCB3ZSB1c2UgdGhlIGdyYXBoJ3Mgd2VpZ2h0cy5cbiAqIEByZXR1cm4ge29iamVjdHx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0UGFnZXJhbmsoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LW1ldHJpY3MvY2VudHJhbGl0eS9wYWdlcmFuazogdGhlIGdpdmVuIGdyYXBoIGlzIG5vdCBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgb3B0aW9ucyA9IHJlc29sdmVEZWZhdWx0cyhvcHRpb25zLCBERUZBVUxUUyk7XG5cbiAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSBvcHRpb25zLm1heEl0ZXJhdGlvbnM7XG4gIHZhciB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZTtcblxuICB2YXIgcGFnZXJhbmtBdHRyaWJ1dGUgPSBvcHRpb25zLm5vZGVQYWdlcmFua0F0dHJpYnV0ZTtcblxuICB2YXIgTiA9IGdyYXBoLm9yZGVyO1xuICB2YXIgcCA9IDEgLyBOO1xuXG4gIHZhciBpbmRleCA9IG5ldyBXZWlnaHRlZE5laWdoYm9yaG9vZEluZGV4KGdyYXBoLCBvcHRpb25zLmdldEVkZ2VXZWlnaHQpO1xuXG4gIHZhciBpLCBqLCBsLCBkO1xuXG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheShncmFwaC5vcmRlcik7XG5cbiAgLy8gTm9ybWFsaXppbmcgZWRnZSB3ZWlnaHRzICYgaW5kZXhpbmcgZGFuZ2xpbmcgbm9kZXNcbiAgdmFyIG5vcm1hbGl6ZWRFZGdlV2VpZ2h0cyA9IG5ldyBGbG9hdDY0QXJyYXkoaW5kZXgud2VpZ2h0cy5sZW5ndGgpO1xuICB2YXIgZGFuZ2xpbmdOb2RlcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB4W2ldID0gcDtcbiAgICBsID0gaW5kZXguc3RhcnRzW2kgKyAxXTtcbiAgICBkID0gaW5kZXgub3V0RGVncmVlc1tpXTtcblxuICAgIGlmIChkID09PSAwKSBkYW5nbGluZ05vZGVzLnB1c2goaSk7XG5cbiAgICBmb3IgKGogPSBpbmRleC5zdGFydHNbaV07IGogPCBsOyBqKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRFZGdlV2VpZ2h0c1tqXSA9IGluZGV4LndlaWdodHNbal0gLyBkO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBvd2VyIGl0ZXJhdGlvbnNcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBlcnJvciA9IDA7XG4gIHZhciBkYW5nbGVTdW0sIG5laWdoYm9yLCB4TGFzdDtcbiAgdmFyIGNvbnZlcmdlZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgeExhc3QgPSB4O1xuICAgIHggPSBuZXcgRmxvYXQ2NEFycmF5KGdyYXBoLm9yZGVyKTsgLy8gVE9ETzogaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHN3YXAgdHdvIGFycmF5cyB0byBhdm9pZCBhbGxvY2F0aW9ucyAoYmVuY2gpXG5cbiAgICBkYW5nbGVTdW0gPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhbmdsaW5nTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgZGFuZ2xlU3VtICs9IHhMYXN0W2RhbmdsaW5nTm9kZXNbaV1dO1xuXG4gICAgZGFuZ2xlU3VtICo9IGFscGhhO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgbCA9IGluZGV4LnN0YXJ0c1tpICsgMV07XG5cbiAgICAgIGZvciAoaiA9IGluZGV4LnN0YXJ0c1tpXTsgaiA8IGw7IGorKykge1xuICAgICAgICBuZWlnaGJvciA9IGluZGV4Lm5laWdoYm9yaG9vZFtqXTtcbiAgICAgICAgeFtuZWlnaGJvcl0gKz0gYWxwaGEgKiB4TGFzdFtpXSAqIG5vcm1hbGl6ZWRFZGdlV2VpZ2h0c1tqXTtcbiAgICAgIH1cblxuICAgICAgeFtpXSArPSBkYW5nbGVTdW0gKiBwICsgKDEgLSBhbHBoYSkgKiBwO1xuICAgIH1cblxuICAgIC8vIENoZWNraW5nIGNvbnZlcmdlbmNlXG4gICAgZXJyb3IgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgZXJyb3IgKz0gTWF0aC5hYnMoeFtpXSAtIHhMYXN0W2ldKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IgPCBOICogdG9sZXJhbmNlKSB7XG4gICAgICBjb252ZXJnZWQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9uKys7XG4gIH1cblxuICBpZiAoIWNvbnZlcmdlZClcbiAgICB0aHJvdyBFcnJvcignZ3JhcGhvbG9neS1tZXRyaWNzL2NlbnRyYWxpdHkvcGFnZXJhbms6IGZhaWxlZCB0byBjb252ZXJnZS4nKTtcblxuICBpZiAoYXNzaWduKSB7XG4gICAgaW5kZXguYXNzaWduKHBhZ2VyYW5rQXR0cmlidXRlLCB4KTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gaW5kZXguY29sbGVjdCh4KTtcbn1cblxuLyoqXG4gKiBFeHBvcnRpbmcuXG4gKi9cbnZhciBwYWdlcmFuayA9IGFic3RyYWN0UGFnZXJhbmsuYmluZChudWxsLCBmYWxzZSk7XG5wYWdlcmFuay5hc3NpZ24gPSBhYnN0cmFjdFBhZ2VyYW5rLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZXJhbms7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-metrics/centrality/pagerank.js\n");

/***/ })

};
;