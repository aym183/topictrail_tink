"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ellipsize";
exports.ids = ["vendor-chunks/ellipsize"];
exports.modules = {

/***/ "(ssr)/./node_modules/ellipsize/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ellipsize/src/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\nvar defaults = {\n    ellipse: \"…\",\n    chars: [\" \", \"-\"],\n    max: 140,\n    truncate: true,\n};\n\n/**\n * \"mac-style\" or \"harmonica\" ellipsize.\n * Ellipsizes a string in the middle instead of the end.\n *\n * Examples:\n *\n *      These are a few of my favourite things\n *      These are … my faourite things\n *      These are … faourite things\n *      hese … things\n *\n * @param {string} str\n * @param {Number} max\n * @param {string} ellipse\n * @param {string[]} chars\n * @returns {string} ellipsized\n */\n\nfunction ellipsizeMiddle(str, max, ellipse, chars) {\n    if (str <= max) return str;\n    if (max < 2) return str.slice(0, max - ellipse.length) + ellipse;\n\n    var maxLen = max - ellipse.length;\n    var middle = Math.floor(maxLen / 2);\n\n    var left = middle;\n    var right = str.length - middle;\n\n    for (var i = 0; i < middle; i++) {\n        var charLeft = str.charAt(i);\n        var posRight = str.length - i;\n\n        var charRight = str.charAt(posRight);\n\n        if (chars.indexOf(charLeft) !== -1) left = i;\n        if (chars.indexOf(charRight) !== -1) right = posRight;\n    }\n\n    return str.slice(0, left) + ellipse + str.slice(right);\n}\n\n/**\n *\n * @param {string} str\n * @param {number} max\n * @param {string} ellipse\n * @param {string[]} chars\n * @param {boolean} truncate\n * @returns\n */\nfunction ellipsize(str, max, ellipse, chars, truncate) {\n    if (str.length <= max) return str;\n\n    var maxLen = max - ellipse.length;\n    var end = maxLen;\n\n    for (var i = 0; i <= maxLen; i++) {\n        var char = str.charAt(i);\n        if (chars.indexOf(char) !== -1) end = i;\n    }\n\n    // no breakpoint found, but truncate\n    // was not allowed.\n    if (!truncate && end == maxLen) return \"\";\n\n    return str.slice(0, end) + ellipse;\n}\n\n/**\n * Ellipsize a string. Produces a string that is max lenght,\n * including the ellipse character.\n *\n * @param {string} str - String to ellipsize\n * @param {number} max - Max length including ellipsis\n * @param {Record<string, any>} [opts] - See additional options\n * @returns {string} ellipsized string\n */\nmodule.exports = function (str, max, opts) {\n    if (typeof str !== \"string\" || str.length === 0) return \"\";\n    if (max === 0) return \"\";\n\n    opts = opts || {};\n\n    for (var key in defaults) {\n        if (opts[key] === null || typeof opts[key] === \"undefined\") {\n            opts[key] = defaults[key];\n        }\n    }\n\n    opts.max = max || opts.max;\n\n    if (opts.truncate == \"middle\")\n        return ellipsizeMiddle(str, opts.max, opts.ellipse, opts.chars);\n\n    return ellipsize(str, opts.max, opts.ellipse, opts.chars, opts.truncate);\n};\n\nmodule.exports.ellipsizeMiddle = ellipsizeMiddle;\nmodule.exports.ellipsize = ellipsize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWxsaXBzaXplL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9lbGxpcHNpemUvc3JjL2luZGV4LmpzPzc3MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBlbGxpcHNlOiBcIuKAplwiLFxuICAgIGNoYXJzOiBbXCIgXCIsIFwiLVwiXSxcbiAgICBtYXg6IDE0MCxcbiAgICB0cnVuY2F0ZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogXCJtYWMtc3R5bGVcIiBvciBcImhhcm1vbmljYVwiIGVsbGlwc2l6ZS5cbiAqIEVsbGlwc2l6ZXMgYSBzdHJpbmcgaW4gdGhlIG1pZGRsZSBpbnN0ZWFkIG9mIHRoZSBlbmQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBUaGVzZSBhcmUgYSBmZXcgb2YgbXkgZmF2b3VyaXRlIHRoaW5nc1xuICogICAgICBUaGVzZSBhcmUg4oCmIG15IGZhb3VyaXRlIHRoaW5nc1xuICogICAgICBUaGVzZSBhcmUg4oCmIGZhb3VyaXRlIHRoaW5nc1xuICogICAgICBoZXNlIOKApiB0aGluZ3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBAcGFyYW0ge3N0cmluZ30gZWxsaXBzZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gY2hhcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVsbGlwc2l6ZWRcbiAqL1xuXG5mdW5jdGlvbiBlbGxpcHNpemVNaWRkbGUoc3RyLCBtYXgsIGVsbGlwc2UsIGNoYXJzKSB7XG4gICAgaWYgKHN0ciA8PSBtYXgpIHJldHVybiBzdHI7XG4gICAgaWYgKG1heCA8IDIpIHJldHVybiBzdHIuc2xpY2UoMCwgbWF4IC0gZWxsaXBzZS5sZW5ndGgpICsgZWxsaXBzZTtcblxuICAgIHZhciBtYXhMZW4gPSBtYXggLSBlbGxpcHNlLmxlbmd0aDtcbiAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihtYXhMZW4gLyAyKTtcblxuICAgIHZhciBsZWZ0ID0gbWlkZGxlO1xuICAgIHZhciByaWdodCA9IHN0ci5sZW5ndGggLSBtaWRkbGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pZGRsZTsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyTGVmdCA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBwb3NSaWdodCA9IHN0ci5sZW5ndGggLSBpO1xuXG4gICAgICAgIHZhciBjaGFyUmlnaHQgPSBzdHIuY2hhckF0KHBvc1JpZ2h0KTtcblxuICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihjaGFyTGVmdCkgIT09IC0xKSBsZWZ0ID0gaTtcbiAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YoY2hhclJpZ2h0KSAhPT0gLTEpIHJpZ2h0ID0gcG9zUmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBsZWZ0KSArIGVsbGlwc2UgKyBzdHIuc2xpY2UocmlnaHQpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge3N0cmluZ30gZWxsaXBzZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gY2hhcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJ1bmNhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVsbGlwc2l6ZShzdHIsIG1heCwgZWxsaXBzZSwgY2hhcnMsIHRydW5jYXRlKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbWF4KSByZXR1cm4gc3RyO1xuXG4gICAgdmFyIG1heExlbiA9IG1heCAtIGVsbGlwc2UubGVuZ3RoO1xuICAgIHZhciBlbmQgPSBtYXhMZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBtYXhMZW47IGkrKykge1xuICAgICAgICB2YXIgY2hhciA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoYXIpICE9PSAtMSkgZW5kID0gaTtcbiAgICB9XG5cbiAgICAvLyBubyBicmVha3BvaW50IGZvdW5kLCBidXQgdHJ1bmNhdGVcbiAgICAvLyB3YXMgbm90IGFsbG93ZWQuXG4gICAgaWYgKCF0cnVuY2F0ZSAmJiBlbmQgPT0gbWF4TGVuKSByZXR1cm4gXCJcIjtcblxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgZW5kKSArIGVsbGlwc2U7XG59XG5cbi8qKlxuICogRWxsaXBzaXplIGEgc3RyaW5nLiBQcm9kdWNlcyBhIHN0cmluZyB0aGF0IGlzIG1heCBsZW5naHQsXG4gKiBpbmNsdWRpbmcgdGhlIGVsbGlwc2UgY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZWxsaXBzaXplXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gTWF4IGxlbmd0aCBpbmNsdWRpbmcgZWxsaXBzaXNcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW29wdHNdIC0gU2VlIGFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gZWxsaXBzaXplZCBzdHJpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBtYXgsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIiB8fCBzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgICBpZiAobWF4ID09PSAwKSByZXR1cm4gXCJcIjtcblxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChvcHRzW2tleV0gPT09IG51bGwgfHwgdHlwZW9mIG9wdHNba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3B0c1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wdHMubWF4ID0gbWF4IHx8IG9wdHMubWF4O1xuXG4gICAgaWYgKG9wdHMudHJ1bmNhdGUgPT0gXCJtaWRkbGVcIilcbiAgICAgICAgcmV0dXJuIGVsbGlwc2l6ZU1pZGRsZShzdHIsIG9wdHMubWF4LCBvcHRzLmVsbGlwc2UsIG9wdHMuY2hhcnMpO1xuXG4gICAgcmV0dXJuIGVsbGlwc2l6ZShzdHIsIG9wdHMubWF4LCBvcHRzLmVsbGlwc2UsIG9wdHMuY2hhcnMsIG9wdHMudHJ1bmNhdGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZWxsaXBzaXplTWlkZGxlID0gZWxsaXBzaXplTWlkZGxlO1xubW9kdWxlLmV4cG9ydHMuZWxsaXBzaXplID0gZWxsaXBzaXplO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ellipsize/src/index.js\n");

/***/ })

};
;