/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-indices";
exports.ids = ["vendor-chunks/graphology-indices"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-indices/neighborhood.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphology-indices/neighborhood.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Graphology Neighborhood Indices\n * ================================\n */\nvar typed = __webpack_require__(/*! mnemonist/utils/typed-arrays */ \"(ssr)/./node_modules/mnemonist/utils/typed-arrays.js\");\nvar createEdgeWeightGetter =\n  (__webpack_require__(/*! graphology-utils/getters */ \"(ssr)/./node_modules/graphology-utils/getters.js\").createEdgeWeightGetter);\n\nfunction upperBoundPerMethod(method, graph) {\n  if (method === 'outbound' || method === 'inbound')\n    return graph.directedSize + graph.undirectedSize * 2;\n\n  if (method === 'in' || method === 'out' || method === 'directed')\n    return graph.directedSize;\n\n  return graph.undirectedSize * 2;\n}\n\nfunction NeighborhoodIndex(graph, method) {\n  method = method || 'outbound';\n  var getNeighbors = graph[method + 'Neighbors'].bind(graph);\n\n  var upperBound = upperBoundPerMethod(method, graph);\n\n  var NeighborhoodPointerArray = typed.getPointerArray(upperBound);\n  var NodesPointerArray = typed.getPointerArray(graph.order);\n\n  // NOTE: directedSize + undirectedSize * 2 is an upper bound for\n  // neighborhood size\n  this.graph = graph;\n  this.neighborhood = new NodesPointerArray(upperBound);\n\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n\n  this.nodes = graph.nodes();\n\n  var ids = {};\n\n  var i, l, j, m, node, neighbors;\n\n  var n = 0;\n\n  for (i = 0, l = graph.order; i < l; i++) ids[this.nodes[i]] = i;\n\n  for (i = 0, l = graph.order; i < l; i++) {\n    node = this.nodes[i];\n    neighbors = getNeighbors(node);\n\n    this.starts[i] = n;\n\n    for (j = 0, m = neighbors.length; j < m; j++)\n      this.neighborhood[n++] = ids[neighbors[j]];\n  }\n\n  // NOTE: we keep one more index as upper bound to simplify iteration\n  this.starts[i] = upperBound;\n}\n\nNeighborhoodIndex.prototype.bounds = function (i) {\n  return [this.starts[i], this.starts[i + 1]];\n};\n\nNeighborhoodIndex.prototype.project = function () {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.forEach(function (node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.starts[i + 1])\n    ).map(function (j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nNeighborhoodIndex.prototype.collect = function (results) {\n  var i, l;\n\n  var o = {};\n\n  for (i = 0, l = results.length; i < l; i++) o[this.nodes[i]] = results[i];\n\n  return o;\n};\n\nNeighborhoodIndex.prototype.assign = function (prop, results) {\n  var i = 0;\n\n  this.graph.updateEachNodeAttributes(\n    function (_, attr) {\n      attr[prop] = results[i++];\n\n      return attr;\n    },\n    {attributes: [prop]}\n  );\n};\n\nexports.NeighborhoodIndex = NeighborhoodIndex;\n\nfunction WeightedNeighborhoodIndex(graph, getEdgeWeight, method) {\n  method = method || 'outbound';\n  var getEdges = graph[method + 'Edges'].bind(graph);\n\n  var upperBound = upperBoundPerMethod(method, graph);\n\n  var NeighborhoodPointerArray = typed.getPointerArray(upperBound);\n  var NodesPointerArray = typed.getPointerArray(graph.order);\n\n  var weightGetter = createEdgeWeightGetter(getEdgeWeight).fromMinimalEntry;\n\n  // NOTE: directedSize + undirectedSize * 2 is an upper bound for\n  // neighborhood size\n  this.graph = graph;\n  this.neighborhood = new NodesPointerArray(upperBound);\n  this.weights = new Float64Array(upperBound);\n  this.outDegrees = new Float64Array(graph.order);\n\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n\n  this.nodes = graph.nodes();\n\n  var ids = {};\n\n  var i, l, j, m, node, neighbor, edges, edge, weight;\n\n  var n = 0;\n\n  for (i = 0, l = graph.order; i < l; i++) ids[this.nodes[i]] = i;\n\n  for (i = 0, l = graph.order; i < l; i++) {\n    node = this.nodes[i];\n    edges = getEdges(node);\n\n    this.starts[i] = n;\n\n    for (j = 0, m = edges.length; j < m; j++) {\n      edge = edges[j];\n      neighbor = graph.opposite(node, edge);\n      weight = weightGetter(edge, graph.getEdgeAttributes(edge));\n\n      // NOTE: for weighted mixed beware of merging weights if twice the same neighbor\n      this.neighborhood[n] = ids[neighbor];\n      this.weights[n++] = weight;\n      this.outDegrees[i] += weight;\n    }\n  }\n\n  // NOTE: we keep one more index as upper bound to simplify iteration\n  this.starts[i] = upperBound;\n}\n\nWeightedNeighborhoodIndex.prototype.bounds = NeighborhoodIndex.prototype.bounds;\nWeightedNeighborhoodIndex.prototype.project =\n  NeighborhoodIndex.prototype.project;\nWeightedNeighborhoodIndex.prototype.collect =\n  NeighborhoodIndex.prototype.collect;\nWeightedNeighborhoodIndex.prototype.assign = NeighborhoodIndex.prototype.assign;\n\nexports.WeightedNeighborhoodIndex = WeightedNeighborhoodIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1pbmRpY2VzL25laWdoYm9yaG9vZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQywwRkFBOEI7QUFDbEQ7QUFDQSxFQUFFLGdJQUEwRDs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsT0FBTzs7QUFFdEMsK0JBQStCLE9BQU87QUFDdEM7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxPQUFPOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixPQUFPOztBQUV0QywrQkFBK0IsT0FBTztBQUN0QztBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1pbmRpY2VzL25laWdoYm9yaG9vZC5qcz84ZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBOZWlnaGJvcmhvb2QgSW5kaWNlc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHR5cGVkID0gcmVxdWlyZSgnbW5lbW9uaXN0L3V0aWxzL3R5cGVkLWFycmF5cycpO1xudmFyIGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPVxuICByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMnKS5jcmVhdGVFZGdlV2VpZ2h0R2V0dGVyO1xuXG5mdW5jdGlvbiB1cHBlckJvdW5kUGVyTWV0aG9kKG1ldGhvZCwgZ3JhcGgpIHtcbiAgaWYgKG1ldGhvZCA9PT0gJ291dGJvdW5kJyB8fCBtZXRob2QgPT09ICdpbmJvdW5kJylcbiAgICByZXR1cm4gZ3JhcGguZGlyZWN0ZWRTaXplICsgZ3JhcGgudW5kaXJlY3RlZFNpemUgKiAyO1xuXG4gIGlmIChtZXRob2QgPT09ICdpbicgfHwgbWV0aG9kID09PSAnb3V0JyB8fCBtZXRob2QgPT09ICdkaXJlY3RlZCcpXG4gICAgcmV0dXJuIGdyYXBoLmRpcmVjdGVkU2l6ZTtcblxuICByZXR1cm4gZ3JhcGgudW5kaXJlY3RlZFNpemUgKiAyO1xufVxuXG5mdW5jdGlvbiBOZWlnaGJvcmhvb2RJbmRleChncmFwaCwgbWV0aG9kKSB7XG4gIG1ldGhvZCA9IG1ldGhvZCB8fCAnb3V0Ym91bmQnO1xuICB2YXIgZ2V0TmVpZ2hib3JzID0gZ3JhcGhbbWV0aG9kICsgJ05laWdoYm9ycyddLmJpbmQoZ3JhcGgpO1xuXG4gIHZhciB1cHBlckJvdW5kID0gdXBwZXJCb3VuZFBlck1ldGhvZChtZXRob2QsIGdyYXBoKTtcblxuICB2YXIgTmVpZ2hib3Job29kUG9pbnRlckFycmF5ID0gdHlwZWQuZ2V0UG9pbnRlckFycmF5KHVwcGVyQm91bmQpO1xuICB2YXIgTm9kZXNQb2ludGVyQXJyYXkgPSB0eXBlZC5nZXRQb2ludGVyQXJyYXkoZ3JhcGgub3JkZXIpO1xuXG4gIC8vIE5PVEU6IGRpcmVjdGVkU2l6ZSArIHVuZGlyZWN0ZWRTaXplICogMiBpcyBhbiB1cHBlciBib3VuZCBmb3JcbiAgLy8gbmVpZ2hib3Job29kIHNpemVcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLm5laWdoYm9yaG9vZCA9IG5ldyBOb2Rlc1BvaW50ZXJBcnJheSh1cHBlckJvdW5kKTtcblxuICB0aGlzLnN0YXJ0cyA9IG5ldyBOZWlnaGJvcmhvb2RQb2ludGVyQXJyYXkoZ3JhcGgub3JkZXIgKyAxKTtcblxuICB0aGlzLm5vZGVzID0gZ3JhcGgubm9kZXMoKTtcblxuICB2YXIgaWRzID0ge307XG5cbiAgdmFyIGksIGwsIGosIG0sIG5vZGUsIG5laWdoYm9ycztcblxuICB2YXIgbiA9IDA7XG5cbiAgZm9yIChpID0gMCwgbCA9IGdyYXBoLm9yZGVyOyBpIDwgbDsgaSsrKSBpZHNbdGhpcy5ub2Rlc1tpXV0gPSBpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBncmFwaC5vcmRlcjsgaSA8IGw7IGkrKykge1xuICAgIG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuICAgIG5laWdoYm9ycyA9IGdldE5laWdoYm9ycyhub2RlKTtcblxuICAgIHRoaXMuc3RhcnRzW2ldID0gbjtcblxuICAgIGZvciAoaiA9IDAsIG0gPSBuZWlnaGJvcnMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgdGhpcy5uZWlnaGJvcmhvb2RbbisrXSA9IGlkc1tuZWlnaGJvcnNbal1dO1xuICB9XG5cbiAgLy8gTk9URTogd2Uga2VlcCBvbmUgbW9yZSBpbmRleCBhcyB1cHBlciBib3VuZCB0byBzaW1wbGlmeSBpdGVyYXRpb25cbiAgdGhpcy5zdGFydHNbaV0gPSB1cHBlckJvdW5kO1xufVxuXG5OZWlnaGJvcmhvb2RJbmRleC5wcm90b3R5cGUuYm91bmRzID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIFt0aGlzLnN0YXJ0c1tpXSwgdGhpcy5zdGFydHNbaSArIDFdXTtcbn07XG5cbk5laWdoYm9yaG9vZEluZGV4LnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHByb2plY3Rpb24gPSB7fTtcblxuICBzZWxmLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICBwcm9qZWN0aW9uW25vZGVdID0gQXJyYXkuZnJvbShcbiAgICAgIHNlbGYubmVpZ2hib3Job29kLnNsaWNlKHNlbGYuc3RhcnRzW2ldLCBzZWxmLnN0YXJ0c1tpICsgMV0pXG4gICAgKS5tYXAoZnVuY3Rpb24gKGopIHtcbiAgICAgIHJldHVybiBzZWxmLm5vZGVzW2pdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcHJvamVjdGlvbjtcbn07XG5cbk5laWdoYm9yaG9vZEluZGV4LnByb3RvdHlwZS5jb2xsZWN0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgdmFyIGksIGw7XG5cbiAgdmFyIG8gPSB7fTtcblxuICBmb3IgKGkgPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpKyspIG9bdGhpcy5ub2Rlc1tpXV0gPSByZXN1bHRzW2ldO1xuXG4gIHJldHVybiBvO1xufTtcblxuTmVpZ2hib3Job29kSW5kZXgucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uIChwcm9wLCByZXN1bHRzKSB7XG4gIHZhciBpID0gMDtcblxuICB0aGlzLmdyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyhcbiAgICBmdW5jdGlvbiAoXywgYXR0cikge1xuICAgICAgYXR0cltwcm9wXSA9IHJlc3VsdHNbaSsrXTtcblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSxcbiAgICB7YXR0cmlidXRlczogW3Byb3BdfVxuICApO1xufTtcblxuZXhwb3J0cy5OZWlnaGJvcmhvb2RJbmRleCA9IE5laWdoYm9yaG9vZEluZGV4O1xuXG5mdW5jdGlvbiBXZWlnaHRlZE5laWdoYm9yaG9vZEluZGV4KGdyYXBoLCBnZXRFZGdlV2VpZ2h0LCBtZXRob2QpIHtcbiAgbWV0aG9kID0gbWV0aG9kIHx8ICdvdXRib3VuZCc7XG4gIHZhciBnZXRFZGdlcyA9IGdyYXBoW21ldGhvZCArICdFZGdlcyddLmJpbmQoZ3JhcGgpO1xuXG4gIHZhciB1cHBlckJvdW5kID0gdXBwZXJCb3VuZFBlck1ldGhvZChtZXRob2QsIGdyYXBoKTtcblxuICB2YXIgTmVpZ2hib3Job29kUG9pbnRlckFycmF5ID0gdHlwZWQuZ2V0UG9pbnRlckFycmF5KHVwcGVyQm91bmQpO1xuICB2YXIgTm9kZXNQb2ludGVyQXJyYXkgPSB0eXBlZC5nZXRQb2ludGVyQXJyYXkoZ3JhcGgub3JkZXIpO1xuXG4gIHZhciB3ZWlnaHRHZXR0ZXIgPSBjcmVhdGVFZGdlV2VpZ2h0R2V0dGVyKGdldEVkZ2VXZWlnaHQpLmZyb21NaW5pbWFsRW50cnk7XG5cbiAgLy8gTk9URTogZGlyZWN0ZWRTaXplICsgdW5kaXJlY3RlZFNpemUgKiAyIGlzIGFuIHVwcGVyIGJvdW5kIGZvclxuICAvLyBuZWlnaGJvcmhvb2Qgc2l6ZVxuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMubmVpZ2hib3Job29kID0gbmV3IE5vZGVzUG9pbnRlckFycmF5KHVwcGVyQm91bmQpO1xuICB0aGlzLndlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KHVwcGVyQm91bmQpO1xuICB0aGlzLm91dERlZ3JlZXMgPSBuZXcgRmxvYXQ2NEFycmF5KGdyYXBoLm9yZGVyKTtcblxuICB0aGlzLnN0YXJ0cyA9IG5ldyBOZWlnaGJvcmhvb2RQb2ludGVyQXJyYXkoZ3JhcGgub3JkZXIgKyAxKTtcblxuICB0aGlzLm5vZGVzID0gZ3JhcGgubm9kZXMoKTtcblxuICB2YXIgaWRzID0ge307XG5cbiAgdmFyIGksIGwsIGosIG0sIG5vZGUsIG5laWdoYm9yLCBlZGdlcywgZWRnZSwgd2VpZ2h0O1xuXG4gIHZhciBuID0gMDtcblxuICBmb3IgKGkgPSAwLCBsID0gZ3JhcGgub3JkZXI7IGkgPCBsOyBpKyspIGlkc1t0aGlzLm5vZGVzW2ldXSA9IGk7XG5cbiAgZm9yIChpID0gMCwgbCA9IGdyYXBoLm9yZGVyOyBpIDwgbDsgaSsrKSB7XG4gICAgbm9kZSA9IHRoaXMubm9kZXNbaV07XG4gICAgZWRnZXMgPSBnZXRFZGdlcyhub2RlKTtcblxuICAgIHRoaXMuc3RhcnRzW2ldID0gbjtcblxuICAgIGZvciAoaiA9IDAsIG0gPSBlZGdlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgIG5laWdoYm9yID0gZ3JhcGgub3Bwb3NpdGUobm9kZSwgZWRnZSk7XG4gICAgICB3ZWlnaHQgPSB3ZWlnaHRHZXR0ZXIoZWRnZSwgZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZXMoZWRnZSkpO1xuXG4gICAgICAvLyBOT1RFOiBmb3Igd2VpZ2h0ZWQgbWl4ZWQgYmV3YXJlIG9mIG1lcmdpbmcgd2VpZ2h0cyBpZiB0d2ljZSB0aGUgc2FtZSBuZWlnaGJvclxuICAgICAgdGhpcy5uZWlnaGJvcmhvb2Rbbl0gPSBpZHNbbmVpZ2hib3JdO1xuICAgICAgdGhpcy53ZWlnaHRzW24rK10gPSB3ZWlnaHQ7XG4gICAgICB0aGlzLm91dERlZ3JlZXNbaV0gKz0gd2VpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIE5PVEU6IHdlIGtlZXAgb25lIG1vcmUgaW5kZXggYXMgdXBwZXIgYm91bmQgdG8gc2ltcGxpZnkgaXRlcmF0aW9uXG4gIHRoaXMuc3RhcnRzW2ldID0gdXBwZXJCb3VuZDtcbn1cblxuV2VpZ2h0ZWROZWlnaGJvcmhvb2RJbmRleC5wcm90b3R5cGUuYm91bmRzID0gTmVpZ2hib3Job29kSW5kZXgucHJvdG90eXBlLmJvdW5kcztcbldlaWdodGVkTmVpZ2hib3Job29kSW5kZXgucHJvdG90eXBlLnByb2plY3QgPVxuICBOZWlnaGJvcmhvb2RJbmRleC5wcm90b3R5cGUucHJvamVjdDtcbldlaWdodGVkTmVpZ2hib3Job29kSW5kZXgucHJvdG90eXBlLmNvbGxlY3QgPVxuICBOZWlnaGJvcmhvb2RJbmRleC5wcm90b3R5cGUuY29sbGVjdDtcbldlaWdodGVkTmVpZ2hib3Job29kSW5kZXgucHJvdG90eXBlLmFzc2lnbiA9IE5laWdoYm9yaG9vZEluZGV4LnByb3RvdHlwZS5hc3NpZ247XG5cbmV4cG9ydHMuV2VpZ2h0ZWROZWlnaGJvcmhvb2RJbmRleCA9IFdlaWdodGVkTmVpZ2hib3Job29kSW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-indices/neighborhood.js\n");

/***/ })

};
;