/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-layout-noverlap";
exports.ids = ["vendor-chunks/graphology-layout-noverlap"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-layout-noverlap/defaults.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/defaults.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/**\n * Graphology Noverlap Layout Default Settings\n * ============================================\n */\nmodule.exports = {\n  gridSize: 20,\n  margin: 5,\n  expansion: 1.1,\n  ratio: 1.0,\n  speed: 3\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1ub3ZlcmxhcC9kZWZhdWx0cy5qcz81MGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBOb3ZlcmxhcCBMYXlvdXQgRGVmYXVsdCBTZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdyaWRTaXplOiAyMCxcbiAgbWFyZ2luOiA1LFxuICBleHBhbnNpb246IDEuMSxcbiAgcmF0aW86IDEuMCxcbiAgc3BlZWQ6IDNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-noverlap/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-noverlap/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Graphology Noverlap Helpers\n * ============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if (\n    ('gridSize' in settings && typeof settings.gridSize !== 'number') ||\n    settings.gridSize <= 0\n  )\n    return {message: 'the `gridSize` setting should be a positive number.'};\n\n  if (\n    ('margin' in settings && typeof settings.margin !== 'number') ||\n    settings.margin < 0\n  )\n    return {\n      message: 'the `margin` setting should be 0 or a positive number.'\n    };\n\n  if (\n    ('expansion' in settings && typeof settings.expansion !== 'number') ||\n    settings.expansion <= 0\n  )\n    return {message: 'the `expansion` setting should be a positive number.'};\n\n  if (\n    ('ratio' in settings && typeof settings.ratio !== 'number') ||\n    settings.ratio <= 0\n  )\n    return {message: 'the `ratio` setting should be a positive number.'};\n\n  if (\n    ('speed' in settings && typeof settings.speed !== 'number') ||\n    settings.speed <= 0\n  )\n    return {message: 'the `speed` setting should be a positive number.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for the given graph's nodes.\n *\n * @param  {Graph}        graph   - Target graph.\n * @param  {function}     reducer - Node reducer function.\n * @return {Float32Array}         - The node matrix.\n */\nexports.graphToByteArray = function (graph, reducer) {\n  var order = graph.order;\n\n  var matrix = new Float32Array(order * PPN);\n\n  var j = 0;\n\n  graph.forEachNode(function (node, attr) {\n    if (typeof reducer === 'function') attr = reducer(node, attr);\n\n    matrix[j] = attr.x;\n    matrix[j + 1] = attr.y;\n    matrix[j + 2] = attr.size || 1;\n    j += PPN;\n  });\n\n  return matrix;\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n * @param {function}     reducer    - Reducing function.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    graph.mergeNodeAttributes(node, pos);\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}        graph      - Target graph.\n * @param  {Float32Array} NodeMatrix - Node matrix.\n * @param  {function}     reducer    - Reducing function.\n * @return {object}                  - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, reducer) {\n  var positions = {};\n\n  var i = 0;\n\n  graph.forEachNode(function (node) {\n    var pos = {\n      x: NodeMatrix[i],\n      y: NodeMatrix[i + 1]\n    };\n\n    if (typeof reducer === 'function') pos = reducer(node, pos);\n\n    positions[node] = pos;\n\n    i += PPN;\n  });\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVk7QUFDWjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekI7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZO0FBQ1o7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktbGF5b3V0LW5vdmVybGFwL2hlbHBlcnMuanM/ZTRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyYXBob2xvZ3kgTm92ZXJsYXAgSGVscGVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIE1pc2NlbGxhbmVvdXMgaGVscGVyIGZ1bmN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xudmFyIFBQTiA9IDM7XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byB2YWxpZGF0ZSB0aGUgZ2l2ZW4gc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgIHNldHRpbmdzIC0gU2V0dGluZ3MgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH1cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gIGlmIChcbiAgICAoJ2dyaWRTaXplJyBpbiBzZXR0aW5ncyAmJiB0eXBlb2Ygc2V0dGluZ3MuZ3JpZFNpemUgIT09ICdudW1iZXInKSB8fFxuICAgIHNldHRpbmdzLmdyaWRTaXplIDw9IDBcbiAgKVxuICAgIHJldHVybiB7bWVzc2FnZTogJ3RoZSBgZ3JpZFNpemVgIHNldHRpbmcgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLid9O1xuXG4gIGlmIChcbiAgICAoJ21hcmdpbicgaW4gc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLm1hcmdpbiAhPT0gJ251bWJlcicpIHx8XG4gICAgc2V0dGluZ3MubWFyZ2luIDwgMFxuICApXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6ICd0aGUgYG1hcmdpbmAgc2V0dGluZyBzaG91bGQgYmUgMCBvciBhIHBvc2l0aXZlIG51bWJlci4nXG4gICAgfTtcblxuICBpZiAoXG4gICAgKCdleHBhbnNpb24nIGluIHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5leHBhbnNpb24gIT09ICdudW1iZXInKSB8fFxuICAgIHNldHRpbmdzLmV4cGFuc2lvbiA8PSAwXG4gIClcbiAgICByZXR1cm4ge21lc3NhZ2U6ICd0aGUgYGV4cGFuc2lvbmAgc2V0dGluZyBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJ307XG5cbiAgaWYgKFxuICAgICgncmF0aW8nIGluIHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5yYXRpbyAhPT0gJ251bWJlcicpIHx8XG4gICAgc2V0dGluZ3MucmF0aW8gPD0gMFxuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGByYXRpb2Agc2V0dGluZyBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJ307XG5cbiAgaWYgKFxuICAgICgnc3BlZWQnIGluIHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5zcGVlZCAhPT0gJ251bWJlcicpIHx8XG4gICAgc2V0dGluZ3Muc3BlZWQgPD0gMFxuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBzcGVlZGAgc2V0dGluZyBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJ307XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGdlbmVyYXRpbmcgYSBmbGF0IG1hdHJpeCBmb3IgdGhlIGdpdmVuIGdyYXBoJ3Mgbm9kZXMuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgICAgICBncmFwaCAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICByZWR1Y2VyIC0gTm9kZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgICAgICAgIC0gVGhlIG5vZGUgbWF0cml4LlxuICovXG5leHBvcnRzLmdyYXBoVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoZ3JhcGgsIHJlZHVjZXIpIHtcbiAgdmFyIG9yZGVyID0gZ3JhcGgub3JkZXI7XG5cbiAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkob3JkZXIgKiBQUE4pO1xuXG4gIHZhciBqID0gMDtcblxuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gJ2Z1bmN0aW9uJykgYXR0ciA9IHJlZHVjZXIobm9kZSwgYXR0cik7XG5cbiAgICBtYXRyaXhbal0gPSBhdHRyLng7XG4gICAgbWF0cml4W2ogKyAxXSA9IGF0dHIueTtcbiAgICBtYXRyaXhbaiArIDJdID0gYXR0ci5zaXplIHx8IDE7XG4gICAgaiArPSBQUE47XG4gIH0pO1xuXG4gIHJldHVybiBtYXRyaXg7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGFwcGx5aW5nIHRoZSBsYXlvdXQgYmFjayB0byB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gICAgICAgIGdyYXBoICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gTm9kZU1hdHJpeCAtIE5vZGUgbWF0cml4LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgIHJlZHVjZXIgICAgLSBSZWR1Y2luZyBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0cy5hc3NpZ25MYXlvdXRDaGFuZ2VzID0gZnVuY3Rpb24gKGdyYXBoLCBOb2RlTWF0cml4LCByZWR1Y2VyKSB7XG4gIHZhciBpID0gMDtcblxuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBwb3MgPSB7XG4gICAgICB4OiBOb2RlTWF0cml4W2ldLFxuICAgICAgeTogTm9kZU1hdHJpeFtpICsgMV1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSAnZnVuY3Rpb24nKSBwb3MgPSByZWR1Y2VyKG5vZGUsIHBvcyk7XG5cbiAgICBncmFwaC5tZXJnZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHBvcyk7XG5cbiAgICBpICs9IFBQTjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGNvbGxlY3RpbmcgdGhlIGxheW91dCBwb3NpdGlvbnMuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgICAgICBncmFwaCAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBOb2RlTWF0cml4IC0gTm9kZSBtYXRyaXguXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIHJlZHVjZXIgICAgLSBSZWR1Y2luZyBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAtIE1hcCB0byBub2RlIHBvc2l0aW9ucy5cbiAqL1xuZXhwb3J0cy5jb2xsZWN0TGF5b3V0Q2hhbmdlcyA9IGZ1bmN0aW9uIChncmFwaCwgTm9kZU1hdHJpeCwgcmVkdWNlcikge1xuICB2YXIgcG9zaXRpb25zID0ge307XG5cbiAgdmFyIGkgPSAwO1xuXG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IE5vZGVNYXRyaXhbaV0sXG4gICAgICB5OiBOb2RlTWF0cml4W2kgKyAxXVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIgPT09ICdmdW5jdGlvbicpIHBvcyA9IHJlZHVjZXIobm9kZSwgcG9zKTtcblxuICAgIHBvc2l0aW9uc1tub2RlXSA9IHBvcztcblxuICAgIGkgKz0gUFBOO1xuICB9KTtcblxuICByZXR1cm4gcG9zaXRpb25zO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSB3ZWIgd29ya2VyIGZyb20gdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgZm4gLSBGdW5jdGlvbiBmb3IgdGhlIHdvcmtlci5cbiAqIEByZXR1cm4ge0RPTVN0cmluZ31cbiAqL1xuZXhwb3J0cy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgdmFyIHhVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gIHZhciBjb2RlID0gZm4udG9TdHJpbmcoKTtcbiAgdmFyIG9iamVjdFVybCA9IHhVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgIG5ldyBCbG9iKFsnKCcgKyBjb2RlICsgJykuY2FsbCh0aGlzKTsnXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSlcbiAgKTtcbiAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgeFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcblxuICByZXR1cm4gd29ya2VyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-noverlap/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-noverlap/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology Noverlap Layout\n * ===========================\n *\n * Library endpoint.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar iterate = __webpack_require__(/*! ./iterate.js */ \"(ssr)/./node_modules/graphology-layout-noverlap/iterate.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/graphology-layout-noverlap/helpers.js\");\n\nvar DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ \"(ssr)/./node_modules/graphology-layout-noverlap/defaults.js\");\nvar DEFAULT_MAX_ITERATIONS = 500;\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.maxIterations, else:\n * @param  {number}          maxIterations - Maximum number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-noverlap: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {maxIterations: params};\n  else params = params || {};\n\n  var maxIterations = params.maxIterations || DEFAULT_MAX_ITERATIONS;\n\n  if (typeof maxIterations !== 'number' || maxIterations <= 0)\n    throw new Error(\n      'graphology-layout-force: you should provide a positive number of maximum iterations.'\n    );\n\n  // Validating settings\n  var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings),\n    validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error('graphology-layout-noverlap: ' + validationError.message);\n\n  // Building matrices\n  var matrix = helpers.graphToByteArray(graph, params.inputReducer),\n    converged = false,\n    i;\n\n  // Iterating\n  for (i = 0; i < maxIterations && !converged; i++)\n    converged = iterate(settings, matrix).converged;\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrix, params.outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrix, params.outputReducer);\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\n\nmodule.exports = synchronousLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9GQUEyQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsZ0ZBQWM7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLGdGQUFjOztBQUVwQyx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBZTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxlQUFlO0FBQzNCLFlBQVksZUFBZTtBQUMzQixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvaW5kZXguanM/MmY3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyYXBob2xvZ3kgTm92ZXJsYXAgTGF5b3V0XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBMaWJyYXJ5IGVuZHBvaW50LlxuICovXG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi9pdGVyYXRlLmpzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xuXG52YXIgREVGQVVMVF9TRVRUSU5HUyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMuanMnKTtcbnZhciBERUZBVUxUX01BWF9JVEVSQVRJT05TID0gNTAwO1xuXG4vKipcbiAqIEFzYnRyYWN0IGZ1bmN0aW9uIHVzZWQgdG8gcnVuIGEgY2VydGFpbiBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSAgICAgICBhc3NpZ24gICAgICAgLSBXaGV0aGVyIHRvIGFzc2lnbiBwb3NpdGlvbnMuXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgICAgICBncmFwaCAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtvYmplY3R8bnVtYmVyfSBwYXJhbXMgICAgICAgLSBJZiBudW1iZXIsIHBhcmFtcy5tYXhJdGVyYXRpb25zLCBlbHNlOlxuICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICBtYXhJdGVyYXRpb25zIC0gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgW3NldHRpbmdzXSAtIFNldHRpbmdzLlxuICogQHJldHVybiB7b2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RTeW5jaHJvbm91c0xheW91dChhc3NpZ24sIGdyYXBoLCBwYXJhbXMpIHtcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXA6IHRoZSBnaXZlbiBncmFwaCBpcyBub3QgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlLidcbiAgICApO1xuXG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJykgcGFyYW1zID0ge21heEl0ZXJhdGlvbnM6IHBhcmFtc307XG4gIGVsc2UgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBtYXhJdGVyYXRpb25zID0gcGFyYW1zLm1heEl0ZXJhdGlvbnMgfHwgREVGQVVMVF9NQVhfSVRFUkFUSU9OUztcblxuICBpZiAodHlwZW9mIG1heEl0ZXJhdGlvbnMgIT09ICdudW1iZXInIHx8IG1heEl0ZXJhdGlvbnMgPD0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2U6IHlvdSBzaG91bGQgcHJvdmlkZSBhIHBvc2l0aXZlIG51bWJlciBvZiBtYXhpbXVtIGl0ZXJhdGlvbnMuJ1xuICAgICk7XG5cbiAgLy8gVmFsaWRhdGluZyBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBwYXJhbXMuc2V0dGluZ3MpLFxuICAgIHZhbGlkYXRpb25FcnJvciA9IGhlbHBlcnMudmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG5cbiAgaWYgKHZhbGlkYXRpb25FcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBob2xvZ3ktbGF5b3V0LW5vdmVybGFwOiAnICsgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2UpO1xuXG4gIC8vIEJ1aWxkaW5nIG1hdHJpY2VzXG4gIHZhciBtYXRyaXggPSBoZWxwZXJzLmdyYXBoVG9CeXRlQXJyYXkoZ3JhcGgsIHBhcmFtcy5pbnB1dFJlZHVjZXIpLFxuICAgIGNvbnZlcmdlZCA9IGZhbHNlLFxuICAgIGk7XG5cbiAgLy8gSXRlcmF0aW5nXG4gIGZvciAoaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zICYmICFjb252ZXJnZWQ7IGkrKylcbiAgICBjb252ZXJnZWQgPSBpdGVyYXRlKHNldHRpbmdzLCBtYXRyaXgpLmNvbnZlcmdlZDtcblxuICAvLyBBcHBseWluZ1xuICBpZiAoYXNzaWduKSB7XG4gICAgaGVscGVycy5hc3NpZ25MYXlvdXRDaGFuZ2VzKGdyYXBoLCBtYXRyaXgsIHBhcmFtcy5vdXRwdXRSZWR1Y2VyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5jb2xsZWN0TGF5b3V0Q2hhbmdlcyhncmFwaCwgbWF0cml4LCBwYXJhbXMub3V0cHV0UmVkdWNlcik7XG59XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG52YXIgc3luY2hyb25vdXNMYXlvdXQgPSBhYnN0cmFjdFN5bmNocm9ub3VzTGF5b3V0LmJpbmQobnVsbCwgZmFsc2UpO1xuc3luY2hyb25vdXNMYXlvdXQuYXNzaWduID0gYWJzdHJhY3RTeW5jaHJvbm91c0xheW91dC5iaW5kKG51bGwsIHRydWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN5bmNocm9ub3VzTGF5b3V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-noverlap/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-noverlap/iterate.js":
/*!************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/iterate.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n * Graphology Noverlap Iteration\n * ==============================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0,\n  NODE_Y = 1,\n  NODE_SIZE = 2;\n\n/**\n * Constants.\n */\nvar PPN = 3;\n\n/**\n * Helpers.\n */\nfunction hashPair(a, b) {\n  return a + '§' + b;\n}\n\nfunction jitter() {\n  return 0.01 * (0.5 - Math.random());\n}\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix) {\n  // Caching options\n  var margin = options.margin;\n  var ratio = options.ratio;\n  var expansion = options.expansion;\n  var gridSize = options.gridSize; // TODO: decrease grid size when few nodes?\n  var speed = options.speed;\n\n  // Generic iteration variables\n  var i, j, x, y, l, size;\n  var converged = true;\n\n  var length = NodeMatrix.length;\n  var order = (length / PPN) | 0;\n\n  var deltaX = new Float32Array(order);\n  var deltaY = new Float32Array(order);\n\n  // Finding the extents of our space\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    xMin = Math.min(xMin, x - size);\n    xMax = Math.max(xMax, x + size);\n    yMin = Math.min(yMin, y - size);\n    yMax = Math.max(yMax, y + size);\n  }\n\n  var width = xMax - xMin;\n  var height = yMax - yMin;\n  var xCenter = (xMin + xMax) / 2;\n  var yCenter = (yMin + yMax) / 2;\n\n  xMin = xCenter - (expansion * width) / 2;\n  xMax = xCenter + (expansion * width) / 2;\n  yMin = yCenter - (expansion * height) / 2;\n  yMax = yCenter + (expansion * height) / 2;\n\n  // Building grid\n  var grid = new Array(gridSize * gridSize),\n    gridLength = grid.length,\n    c;\n\n  for (c = 0; c < gridLength; c++) grid[c] = [];\n\n  var nxMin, nxMax, nyMin, nyMax;\n  var xMinBox, xMaxBox, yMinBox, yMaxBox;\n\n  var col, row;\n\n  for (i = 0; i < length; i += PPN) {\n    x = NodeMatrix[i + NODE_X];\n    y = NodeMatrix[i + NODE_Y];\n    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;\n\n    nxMin = x - size;\n    nxMax = x + size;\n    nyMin = y - size;\n    nyMax = y + size;\n\n    xMinBox = Math.floor((gridSize * (nxMin - xMin)) / (xMax - xMin));\n    xMaxBox = Math.floor((gridSize * (nxMax - xMin)) / (xMax - xMin));\n    yMinBox = Math.floor((gridSize * (nyMin - yMin)) / (yMax - yMin));\n    yMaxBox = Math.floor((gridSize * (nyMax - yMin)) / (yMax - yMin));\n\n    for (col = xMinBox; col <= xMaxBox; col++) {\n      for (row = yMinBox; row <= yMaxBox; row++) {\n        grid[col * gridSize + row].push(i);\n      }\n    }\n  }\n\n  // Computing collisions\n  var cell;\n\n  var collisions = new Set();\n\n  var n1, n2, x1, x2, y1, y2, s1, s2, h;\n\n  var xDist, yDist, dist, collision;\n\n  for (c = 0; c < gridLength; c++) {\n    cell = grid[c];\n\n    for (i = 0, l = cell.length; i < l; i++) {\n      n1 = cell[i];\n\n      x1 = NodeMatrix[n1 + NODE_X];\n      y1 = NodeMatrix[n1 + NODE_Y];\n      s1 = NodeMatrix[n1 + NODE_SIZE];\n\n      for (j = i + 1; j < l; j++) {\n        n2 = cell[j];\n        h = hashPair(n1, n2);\n\n        if (gridLength > 1 && collisions.has(h)) continue;\n\n        if (gridLength > 1) collisions.add(h);\n\n        x2 = NodeMatrix[n2 + NODE_X];\n        y2 = NodeMatrix[n2 + NODE_Y];\n        s2 = NodeMatrix[n2 + NODE_SIZE];\n\n        xDist = x2 - x1;\n        yDist = y2 - y1;\n        dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        collision = dist < s1 * ratio + margin + (s2 * ratio + margin);\n\n        if (collision) {\n          converged = false;\n\n          n2 = (n2 / PPN) | 0;\n\n          if (dist > 0) {\n            deltaX[n2] += (xDist / dist) * (1 + s1);\n            deltaY[n2] += (yDist / dist) * (1 + s1);\n          } else {\n            // Nodes are on the exact same spot, we need to jitter a bit\n            deltaX[n2] += width * jitter();\n            deltaY[n2] += height * jitter();\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0, j = 0; i < length; i += PPN, j++) {\n    NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;\n    NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;\n  }\n\n  return {converged: converged};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvaXRlcmF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdCQUFnQjs7QUFFOUI7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEMsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBLGlDQUFpQyxPQUFPO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtbm92ZXJsYXAvaXRlcmF0ZS5qcz8zY2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBOb3ZlcmxhcCBJdGVyYXRpb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gcGVyZm9ybSBhIHNpbmdsZSBpdGVyYXRpb24gb2YgdGhlIGFsZ29yaXRobS5cbiAqL1xuXG4vKipcbiAqIE1hdHJpY2VzIHByb3BlcnRpZXMgYWNjZXNzb3JzLlxuICovXG52YXIgTk9ERV9YID0gMCxcbiAgTk9ERV9ZID0gMSxcbiAgTk9ERV9TSVpFID0gMjtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBQUE4gPSAzO1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cbmZ1bmN0aW9uIGhhc2hQYWlyKGEsIGIpIHtcbiAgcmV0dXJuIGEgKyAnwqcnICsgYjtcbn1cblxuZnVuY3Rpb24gaml0dGVyKCkge1xuICByZXR1cm4gMC4wMSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaW50ZXJhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAtIExheW91dCBvcHRpb25zLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBOb2RlTWF0cml4IC0gTm9kZSBkYXRhLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gU29tZSBtZXRhZGF0YS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlKG9wdGlvbnMsIE5vZGVNYXRyaXgpIHtcbiAgLy8gQ2FjaGluZyBvcHRpb25zXG4gIHZhciBtYXJnaW4gPSBvcHRpb25zLm1hcmdpbjtcbiAgdmFyIHJhdGlvID0gb3B0aW9ucy5yYXRpbztcbiAgdmFyIGV4cGFuc2lvbiA9IG9wdGlvbnMuZXhwYW5zaW9uO1xuICB2YXIgZ3JpZFNpemUgPSBvcHRpb25zLmdyaWRTaXplOyAvLyBUT0RPOiBkZWNyZWFzZSBncmlkIHNpemUgd2hlbiBmZXcgbm9kZXM/XG4gIHZhciBzcGVlZCA9IG9wdGlvbnMuc3BlZWQ7XG5cbiAgLy8gR2VuZXJpYyBpdGVyYXRpb24gdmFyaWFibGVzXG4gIHZhciBpLCBqLCB4LCB5LCBsLCBzaXplO1xuICB2YXIgY29udmVyZ2VkID0gdHJ1ZTtcblxuICB2YXIgbGVuZ3RoID0gTm9kZU1hdHJpeC5sZW5ndGg7XG4gIHZhciBvcmRlciA9IChsZW5ndGggLyBQUE4pIHwgMDtcblxuICB2YXIgZGVsdGFYID0gbmV3IEZsb2F0MzJBcnJheShvcmRlcik7XG4gIHZhciBkZWx0YVkgPSBuZXcgRmxvYXQzMkFycmF5KG9yZGVyKTtcblxuICAvLyBGaW5kaW5nIHRoZSBleHRlbnRzIG9mIG91ciBzcGFjZVxuICB2YXIgeE1pbiA9IEluZmluaXR5O1xuICB2YXIgeU1pbiA9IEluZmluaXR5O1xuICB2YXIgeE1heCA9IC1JbmZpbml0eTtcbiAgdmFyIHlNYXggPSAtSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBQUE4pIHtcbiAgICB4ID0gTm9kZU1hdHJpeFtpICsgTk9ERV9YXTtcbiAgICB5ID0gTm9kZU1hdHJpeFtpICsgTk9ERV9ZXTtcbiAgICBzaXplID0gTm9kZU1hdHJpeFtpICsgTk9ERV9TSVpFXSAqIHJhdGlvICsgbWFyZ2luO1xuXG4gICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHggLSBzaXplKTtcbiAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgeCArIHNpemUpO1xuICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCB5IC0gc2l6ZSk7XG4gICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHkgKyBzaXplKTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHhNYXggLSB4TWluO1xuICB2YXIgaGVpZ2h0ID0geU1heCAtIHlNaW47XG4gIHZhciB4Q2VudGVyID0gKHhNaW4gKyB4TWF4KSAvIDI7XG4gIHZhciB5Q2VudGVyID0gKHlNaW4gKyB5TWF4KSAvIDI7XG5cbiAgeE1pbiA9IHhDZW50ZXIgLSAoZXhwYW5zaW9uICogd2lkdGgpIC8gMjtcbiAgeE1heCA9IHhDZW50ZXIgKyAoZXhwYW5zaW9uICogd2lkdGgpIC8gMjtcbiAgeU1pbiA9IHlDZW50ZXIgLSAoZXhwYW5zaW9uICogaGVpZ2h0KSAvIDI7XG4gIHlNYXggPSB5Q2VudGVyICsgKGV4cGFuc2lvbiAqIGhlaWdodCkgLyAyO1xuXG4gIC8vIEJ1aWxkaW5nIGdyaWRcbiAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoZ3JpZFNpemUgKiBncmlkU2l6ZSksXG4gICAgZ3JpZExlbmd0aCA9IGdyaWQubGVuZ3RoLFxuICAgIGM7XG5cbiAgZm9yIChjID0gMDsgYyA8IGdyaWRMZW5ndGg7IGMrKykgZ3JpZFtjXSA9IFtdO1xuXG4gIHZhciBueE1pbiwgbnhNYXgsIG55TWluLCBueU1heDtcbiAgdmFyIHhNaW5Cb3gsIHhNYXhCb3gsIHlNaW5Cb3gsIHlNYXhCb3g7XG5cbiAgdmFyIGNvbCwgcm93O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gUFBOKSB7XG4gICAgeCA9IE5vZGVNYXRyaXhbaSArIE5PREVfWF07XG4gICAgeSA9IE5vZGVNYXRyaXhbaSArIE5PREVfWV07XG4gICAgc2l6ZSA9IE5vZGVNYXRyaXhbaSArIE5PREVfU0laRV0gKiByYXRpbyArIG1hcmdpbjtcblxuICAgIG54TWluID0geCAtIHNpemU7XG4gICAgbnhNYXggPSB4ICsgc2l6ZTtcbiAgICBueU1pbiA9IHkgLSBzaXplO1xuICAgIG55TWF4ID0geSArIHNpemU7XG5cbiAgICB4TWluQm94ID0gTWF0aC5mbG9vcigoZ3JpZFNpemUgKiAobnhNaW4gLSB4TWluKSkgLyAoeE1heCAtIHhNaW4pKTtcbiAgICB4TWF4Qm94ID0gTWF0aC5mbG9vcigoZ3JpZFNpemUgKiAobnhNYXggLSB4TWluKSkgLyAoeE1heCAtIHhNaW4pKTtcbiAgICB5TWluQm94ID0gTWF0aC5mbG9vcigoZ3JpZFNpemUgKiAobnlNaW4gLSB5TWluKSkgLyAoeU1heCAtIHlNaW4pKTtcbiAgICB5TWF4Qm94ID0gTWF0aC5mbG9vcigoZ3JpZFNpemUgKiAobnlNYXggLSB5TWluKSkgLyAoeU1heCAtIHlNaW4pKTtcblxuICAgIGZvciAoY29sID0geE1pbkJveDsgY29sIDw9IHhNYXhCb3g7IGNvbCsrKSB7XG4gICAgICBmb3IgKHJvdyA9IHlNaW5Cb3g7IHJvdyA8PSB5TWF4Qm94OyByb3crKykge1xuICAgICAgICBncmlkW2NvbCAqIGdyaWRTaXplICsgcm93XS5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGluZyBjb2xsaXNpb25zXG4gIHZhciBjZWxsO1xuXG4gIHZhciBjb2xsaXNpb25zID0gbmV3IFNldCgpO1xuXG4gIHZhciBuMSwgbjIsIHgxLCB4MiwgeTEsIHkyLCBzMSwgczIsIGg7XG5cbiAgdmFyIHhEaXN0LCB5RGlzdCwgZGlzdCwgY29sbGlzaW9uO1xuXG4gIGZvciAoYyA9IDA7IGMgPCBncmlkTGVuZ3RoOyBjKyspIHtcbiAgICBjZWxsID0gZ3JpZFtjXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBjZWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbjEgPSBjZWxsW2ldO1xuXG4gICAgICB4MSA9IE5vZGVNYXRyaXhbbjEgKyBOT0RFX1hdO1xuICAgICAgeTEgPSBOb2RlTWF0cml4W24xICsgTk9ERV9ZXTtcbiAgICAgIHMxID0gTm9kZU1hdHJpeFtuMSArIE5PREVfU0laRV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIG4yID0gY2VsbFtqXTtcbiAgICAgICAgaCA9IGhhc2hQYWlyKG4xLCBuMik7XG5cbiAgICAgICAgaWYgKGdyaWRMZW5ndGggPiAxICYmIGNvbGxpc2lvbnMuaGFzKGgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoZ3JpZExlbmd0aCA+IDEpIGNvbGxpc2lvbnMuYWRkKGgpO1xuXG4gICAgICAgIHgyID0gTm9kZU1hdHJpeFtuMiArIE5PREVfWF07XG4gICAgICAgIHkyID0gTm9kZU1hdHJpeFtuMiArIE5PREVfWV07XG4gICAgICAgIHMyID0gTm9kZU1hdHJpeFtuMiArIE5PREVfU0laRV07XG5cbiAgICAgICAgeERpc3QgPSB4MiAtIHgxO1xuICAgICAgICB5RGlzdCA9IHkyIC0geTE7XG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoeERpc3QgKiB4RGlzdCArIHlEaXN0ICogeURpc3QpO1xuICAgICAgICBjb2xsaXNpb24gPSBkaXN0IDwgczEgKiByYXRpbyArIG1hcmdpbiArIChzMiAqIHJhdGlvICsgbWFyZ2luKTtcblxuICAgICAgICBpZiAoY29sbGlzaW9uKSB7XG4gICAgICAgICAgY29udmVyZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICBuMiA9IChuMiAvIFBQTikgfCAwO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBkZWx0YVhbbjJdICs9ICh4RGlzdCAvIGRpc3QpICogKDEgKyBzMSk7XG4gICAgICAgICAgICBkZWx0YVlbbjJdICs9ICh5RGlzdCAvIGRpc3QpICogKDEgKyBzMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vZGVzIGFyZSBvbiB0aGUgZXhhY3Qgc2FtZSBzcG90LCB3ZSBuZWVkIHRvIGppdHRlciBhIGJpdFxuICAgICAgICAgICAgZGVsdGFYW24yXSArPSB3aWR0aCAqIGppdHRlcigpO1xuICAgICAgICAgICAgZGVsdGFZW24yXSArPSBoZWlnaHQgKiBqaXR0ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGxlbmd0aDsgaSArPSBQUE4sIGorKykge1xuICAgIE5vZGVNYXRyaXhbaSArIE5PREVfWF0gKz0gZGVsdGFYW2pdICogMC4xICogc3BlZWQ7XG4gICAgTm9kZU1hdHJpeFtpICsgTk9ERV9ZXSArPSBkZWx0YVlbal0gKiAwLjEgKiBzcGVlZDtcbiAgfVxuXG4gIHJldHVybiB7Y29udmVyZ2VkOiBjb252ZXJnZWR9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-noverlap/iterate.js\n");

/***/ })

};
;