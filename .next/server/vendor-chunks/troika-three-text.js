"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlyphsGeometry: () => (/* binding */ GlyphsGeometry),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   configureTextBuilder: () => (/* binding */ configureTextBuilder),\n/* harmony export */   createTextDerivedMaterial: () => (/* binding */ createTextDerivedMaterial),\n/* harmony export */   dumpSDFTextures: () => (/* binding */ dumpSDFTextures),\n/* harmony export */   getCaretAtPoint: () => (/* binding */ getCaretAtPoint),\n/* harmony export */   getSelectionRects: () => (/* binding */ getSelectionRects),\n/* harmony export */   preloadFont: () => (/* binding */ preloadFont),\n/* harmony export */   typesetterWorkerModule: () => (/* binding */ typesetterWorkerModule)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n * a standardized structure giving access to the font and its glyphs:\n *   {\n *     unitsPerEm: number,\n *     ascender: number,\n *     descender: number,\n *     capHeight: number,\n *     xHeight: number,\n *     lineGap: number,\n *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n *       //invokes callback for each glyph to render, passing it an object:\n *       callback({\n *         index: number,\n *         advanceWidth: number,\n *         xMin: number,\n *         yMin: number,\n *         xMax: number,\n *         yMax: number,\n *         path: string,\n *         pathCommandCount: number\n *       })\n *     }\n *   }\n * @param {object} bidi - the bidi.js implementation object\n * @param {Object} config\n * @return {Object}\n */\nfunction createTypesetter(fontParser, bidi, config) {\n\n  const {\n    defaultFontURL\n  } = config;\n\n  /**\n   * Holds parsed font objects by url\n   */\n  const fonts = Object.create(null);\n\n  const INF = Infinity;\n\n  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n  // eslint-disable-next-line no-misleading-character-class\n  const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n  // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n  const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n  // Incomplete set of characters that allow line breaking after them\n  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    function tryLoad() {\n      const onError = err => {\n        console.error(`Failure loading font ${url}${url === defaultFontURL ? '' : '; trying fallback'}`, err);\n        if (url !== defaultFontURL) {\n          url = defaultFontURL;\n          tryLoad();\n        }\n      };\n      try {\n        const request = new XMLHttpRequest();\n        request.open('get', url, true);\n        request.responseType = 'arraybuffer';\n        request.onload = function () {\n          if (request.status >= 400) {\n            onError(new Error(request.statusText));\n          }\n          else if (request.status > 0) {\n            try {\n              const fontObj = fontParser(request.response);\n              callback(fontObj);\n            } catch (e) {\n              onError(e);\n            }\n          }\n        };\n        request.onerror = onError;\n        request.send();\n      } catch(err) {\n        onError(err);\n      }\n    }\n    tryLoad();\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   */\n  function loadFont(fontUrl, callback) {\n    if (!fontUrl) fontUrl = defaultFontURL;\n    let font = fonts[fontUrl];\n    if (font) {\n      // if currently loading font, add to callbacks, otherwise execute immediately\n      if (font.pending) {\n        font.pending.push(callback);\n      } else {\n        callback(font);\n      }\n    } else {\n      fonts[fontUrl] = {pending: [callback]};\n      doLoadFont(fontUrl, fontObj => {\n        let callbacks = fonts[fontUrl].pending;\n        fonts[fontUrl] = fontObj;\n        callbacks.forEach(cb => cb(fontObj));\n      });\n    }\n  }\n\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   */\n  function typeset(\n    {\n      text='',\n      font=defaultFontURL,\n      sdfGlyphSize=64,\n      fontSize=1,\n      letterSpacing=0,\n      lineHeight='normal',\n      maxWidth=INF,\n      direction,\n      textAlign='left',\n      textIndent=0,\n      whiteSpace='normal',\n      overflowWrap='normal',\n      anchorX = 0,\n      anchorY = 0,\n      includeCaretPositions=false,\n      chunkedBoundsSize=8192,\n      colorRanges=null\n    },\n    callback,\n    metricsOnly=false\n  ) {\n    const mainStart = now();\n    const timings = {fontLoad: 0, typesetting: 0};\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    // Ensure we've got numbers not strings\n    fontSize = +fontSize;\n    letterSpacing = +letterSpacing;\n    maxWidth = +maxWidth;\n    lineHeight = lineHeight || 'normal';\n    textIndent = +textIndent;\n\n    loadFont(font, fontObj => {\n      const hasMaxWidth = isFinite(maxWidth);\n      let glyphIds = null;\n      let glyphPositions = null;\n      let glyphData = null;\n      let glyphColors = null;\n      let caretPositions = null;\n      let visibleBounds = null;\n      let chunkedBounds = null;\n      let maxLineWidth = 0;\n      let renderableGlyphCount = 0;\n      let canWrap = whiteSpace !== 'nowrap';\n      const {ascender, descender, unitsPerEm, lineGap, capHeight, xHeight} = fontObj;\n      timings.fontLoad = now() - mainStart;\n      const typesetStart = now();\n\n      // Find conversion between native font units and fontSize units; this will already be done\n      // for the gx/gy values below but everything else we'll need to convert\n      const fontSizeMult = fontSize / unitsPerEm;\n\n      // Determine appropriate value for 'normal' line height based on the font's actual metrics\n      // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n      if (lineHeight === 'normal') {\n        lineHeight = (ascender - descender + lineGap) / unitsPerEm;\n      }\n\n      // Determine line height and leading adjustments\n      lineHeight = lineHeight * fontSize;\n      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n      const topBaseline = -(ascender * fontSizeMult + halfLeading);\n      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n\n      // Distribute glyphs into lines based on wrapping\n      let lineXOffset = textIndent;\n      let currentLine = new TextLine();\n      const lines = [currentLine];\n\n      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {\n        const char = text.charAt(charIndex);\n        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n        const curLineCount = currentLine.count;\n        let nextLine;\n\n        // Calc isWhitespace and isEmpty once per glyphObj\n        if (!('isEmpty' in glyphObj)) {\n          glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n        }\n        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n          renderableGlyphCount++;\n        }\n\n        // If a non-whitespace character overflows the max width, we need to soft-wrap\n        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n          // If it's the first char after a whitespace, start a new line\n          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n            nextLine = new TextLine();\n            lineXOffset = -glyphX;\n          } else {\n            // Back up looking for a whitespace character to wrap at\n            for (let i = curLineCount; i--;) {\n              // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n              if (i === 0 && overflowWrap === 'break-word') {\n                nextLine = new TextLine();\n                lineXOffset = -glyphX;\n                break\n              }\n              // Found a soft break point; move all chars since it to a new line\n              else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                nextLine = currentLine.splitAt(i + 1);\n                const adjustX = nextLine.glyphAt(0).x;\n                lineXOffset -= adjustX;\n                for (let j = nextLine.count; j--;) {\n                  nextLine.glyphAt(j).x -= adjustX;\n                }\n                break\n              }\n            }\n          }\n          if (nextLine) {\n            currentLine.isSoftWrapped = true;\n            currentLine = nextLine;\n            lines.push(currentLine);\n            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n          }\n        }\n\n        let fly = currentLine.glyphAt(currentLine.count);\n        fly.glyphObj = glyphObj;\n        fly.x = glyphX + lineXOffset;\n        fly.width = glyphWidth;\n        fly.charIndex = charIndex;\n\n        // Handle hard line breaks\n        if (char === '\\n') {\n          currentLine = new TextLine();\n          lines.push(currentLine);\n          lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n        }\n      });\n\n      // Calculate width of each line (excluding trailing whitespace) and maximum block width\n      lines.forEach(line => {\n        for (let i = line.count; i--;) {\n          let {glyphObj, x, width} = line.glyphAt(i);\n          if (!glyphObj.isWhitespace) {\n            line.width = x + width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            return\n          }\n        }\n      });\n\n      // Find overall position adjustments for anchoring\n      let anchorXOffset = 0;\n      let anchorYOffset = 0;\n      if (anchorX) {\n        if (typeof anchorX === 'number') {\n          anchorXOffset = -anchorX;\n        }\n        else if (typeof anchorX === 'string') {\n          anchorXOffset = -maxLineWidth * (\n            anchorX === 'left' ? 0 :\n            anchorX === 'center' ? 0.5 :\n            anchorX === 'right' ? 1 :\n            parsePercent(anchorX)\n          );\n        }\n      }\n      if (anchorY) {\n        if (typeof anchorY === 'number') {\n          anchorYOffset = -anchorY;\n        }\n        else if (typeof anchorY === 'string') {\n          let height = lines.length * lineHeight;\n          anchorYOffset = anchorY === 'top' ? 0 :\n            anchorY === 'top-baseline' ? -topBaseline :\n            anchorY === 'top-cap' ? -topBaseline - capHeight * fontSizeMult :\n            anchorY === 'top-ex' ? -topBaseline - xHeight * fontSizeMult :\n            anchorY === 'middle' ? height / 2 :\n            anchorY === 'bottom' ? height :\n            anchorY === 'bottom-baseline' ? height - halfLeading + descender * fontSizeMult :\n            parsePercent(anchorY) * height;\n        }\n      }\n\n      if (!metricsOnly) {\n        // Resolve bidi levels\n        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        glyphIds = new Uint16Array(renderableGlyphCount);\n        glyphPositions = new Float32Array(renderableGlyphCount * 2);\n        glyphData = {};\n        visibleBounds = [INF, INF, -INF, -INF];\n        chunkedBounds = [];\n        let lineYOffset = topBaseline;\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 3);\n        }\n        if (colorRanges) {\n          glyphColors = new Uint8Array(renderableGlyphCount * 3);\n        }\n        let renderableGlyphIndex = 0;\n        let prevCharIndex = -1;\n        let colorCharIndex = -1;\n        let chunk;\n        let currentColor;\n        lines.forEach((line, lineIndex) => {\n          let {count:lineGlyphCount, width:lineWidth} = line;\n\n          // Ignore empty lines\n          if (lineGlyphCount > 0) {\n            // Count trailing whitespaces, we want to ignore these for certain things\n            let trailingWhitespaceCount = 0;\n            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n              trailingWhitespaceCount++;\n            }\n\n            // Apply horizontal alignment adjustments\n            let lineXOffset = 0;\n            let justifyAdjust = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify' && line.isSoftWrapped) {\n              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n              let whitespaceCount = 0;\n              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                  whitespaceCount++;\n                }\n              }\n              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n            }\n            if (justifyAdjust || lineXOffset) {\n              let justifyOffset = 0;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                const glyphObj = glyphInfo.glyphObj;\n                glyphInfo.x += lineXOffset + justifyOffset;\n                // Expand non-trailing whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                  justifyOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n              }\n            }\n\n            // Perform bidi range flipping\n            const flips = bidi.getReorderSegments(\n              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n            );\n            for (let fi = 0; fi < flips.length; fi++) {\n              const [start, end] = flips[fi];\n              // Map start/end string indices to indices in the line\n              let left = Infinity, right = -Infinity;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                  let startInLine = i, endInLine = i;\n                  for (; endInLine < lineGlyphCount; endInLine++) {\n                    let info = line.glyphAt(endInLine);\n                    if (info.charIndex > end) {\n                      break\n                    }\n                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                      left = Math.min(left, info.x);\n                      right = Math.max(right, info.x + info.width);\n                    }\n                  }\n                  for (let j = startInLine; j < endInLine; j++) {\n                    const glyphInfo = line.glyphAt(j);\n                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                  }\n                  break\n                }\n              }\n            }\n\n            // Assemble final data arrays\n            let glyphObj;\n            const setGlyphObj = g => glyphObj = g;\n            for (let i = 0; i < lineGlyphCount; i++) {\n              let glyphInfo = line.glyphAt(i);\n              glyphObj = glyphInfo.glyphObj;\n              const glyphId = glyphObj.index;\n\n              // Replace mirrored characters in rtl\n              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n              if (rtl) {\n                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                if (mirrored) {\n                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                }\n              }\n\n              // Add caret positions\n              if (includeCaretPositions) {\n                const {charIndex} = glyphInfo;\n                const caretLeft = glyphInfo.x + anchorXOffset;\n                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x\n                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                // positions for those missing char indices; currently this uses a best-guess by dividing\n                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                // table to get better interior caret positions.\n                const ligCount = charIndex - prevCharIndex;\n                if (ligCount > 1) {\n                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Track current color range\n              if (colorRanges) {\n                const {charIndex} = glyphInfo;\n                while(charIndex > colorCharIndex) {\n                  colorCharIndex++;\n                  if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                    currentColor = colorRanges[colorCharIndex];\n                  }\n                }\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                const idx = renderableGlyphIndex++;\n\n                // Add this glyph's path data\n                if (!glyphData[glyphId]) {\n                  glyphData[glyphId] = {\n                    path: glyphObj.path,\n                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                  };\n                }\n\n                // Determine final glyph position and add to glyphPositions array\n                const glyphX = glyphInfo.x + anchorXOffset;\n                const glyphY = lineYOffset + anchorYOffset;\n                glyphPositions[idx * 2] = glyphX;\n                glyphPositions[idx * 2 + 1] = glyphY;\n\n                // Track total visible bounds\n                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                // Track bounding rects for each chunk of N glyphs\n                if (idx % chunkedBoundsSize === 0) {\n                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                  chunkedBounds.push(chunk);\n                }\n                chunk.end++;\n                const chunkRect = chunk.rect;\n                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                // Add to glyph ids array\n                glyphIds[idx] = glyphId;\n\n                // Add colors\n                if (colorRanges) {\n                  const start = idx * 3;\n                  glyphColors[start] = currentColor >> 16 & 255;\n                  glyphColors[start + 1] = currentColor >> 8 & 255;\n                  glyphColors[start + 2] = currentColor & 255;\n                }\n              }\n            }\n          }\n\n          // Increment y offset for next line\n          lineYOffset -= lineHeight;\n        });\n\n        // Fill in remaining caret positions in case the final character was a ligature\n        if (caretPositions) {\n          const ligCount = text.length - prevCharIndex;\n          if (ligCount > 1) {\n            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n          }\n        }\n      }\n\n      // Timing stats\n      timings.typesetting = now() - typesetStart;\n\n      callback({\n        glyphIds, //font indices for each glyph\n        glyphPositions, //x,y of each glyph's origin in layout\n        glyphData, //dict holding data about each glyph appearing in the text\n        caretPositions, //startX,endX,bottomY caret positions for each char\n        caretHeight, //height of cursor from bottom to top\n        glyphColors, //color for each glyph, if color ranges supplied\n        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n        fontSize, //calculated em height\n        unitsPerEm, //font units per em\n        ascender: ascender * fontSizeMult, //font ascender\n        descender: descender * fontSizeMult, //font descender\n        capHeight: capHeight * fontSizeMult, //font cap-height\n        xHeight: xHeight * fontSizeMult, //font x-height\n        lineHeight, //computed line height\n        topBaseline, //y coordinate of the top line's baseline\n        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n          anchorXOffset,\n          anchorYOffset - lines.length * lineHeight,\n          anchorXOffset + maxLineWidth,\n          anchorYOffset\n        ],\n        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n        timings\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    typeset(args, (result) => {\n      const [x0, y0, x1, y1] = result.blockBounds;\n      callback({\n        width: x1 - x0,\n        height: y1 - y0\n      });\n    }, {metricsOnly: true});\n  }\n\n  function parsePercent(str) {\n    let match = str.match(/^([\\d.]+)%$/);\n    let pct = match ? parseFloat(match[1]) : NaN;\n    return isNaN(pct) ? 0 : pct / 100\n  }\n\n  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n    const ligStartX = caretPositions[ligStartIndex * 3];\n    const ligEndX = caretPositions[ligStartIndex * 3 + 1];\n    const ligY = caretPositions[ligStartIndex * 3 + 2];\n    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n    for (let i = 0; i < ligCount; i++) {\n      const startIndex = (ligStartIndex + i) * 3;\n      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n      caretPositions[startIndex + 2] = ligY;\n    }\n  }\n\n  function now() {\n    return (self.performance || Date).now()\n  }\n\n  // Array-backed structure for a single line's glyphs data\n  function TextLine() {\n    this.data = [];\n  }\n  const textLineProps = ['glyphObj', 'x', 'width', 'charIndex'];\n  TextLine.prototype = {\n    width: 0,\n    isSoftWrapped: false,\n    get count() {\n      return Math.ceil(this.data.length / textLineProps.length)\n    },\n    glyphAt(i) {\n      let fly = TextLine.flyweight;\n      fly.data = this.data;\n      fly.index = i;\n      return fly\n    },\n    splitAt(i) {\n      let newLine = new TextLine();\n      newLine.data = this.data.splice(i * textLineProps.length);\n      return newLine\n    }\n  };\n  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n    Object.defineProperty(obj, prop, {\n      get() {\n        return this.data[this.index * textLineProps.length + i]\n      },\n      set(val) {\n        this.data[this.index * textLineProps.length + i] = val;\n      }\n    });\n    return obj\n  }, {data: null, index: 0});\n\n\n  return {\n    typeset,\n    measure,\n    loadFont\n  }\n}\n\nconst now = () => (self.performance || Date).now();\n\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\nlet warned;\n\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */\nfunction generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n  // Allow opt-out\n  if (!useWebGL) {\n    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n  }\n\n  // Attempt GPU-accelerated generation first\n  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n    null,\n    err => {\n      // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n      if (!warned) {\n        console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n        warned = true;\n      }\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n  )\n}\n\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\n\nfunction nextChunk() {\n  const start = now();\n  while (queue.length && now() - start < chunkTimeBudget) {\n    queue.shift()();\n  }\n  timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */\nconst generateSDF_GL = (...args) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => {\n      const start = now();\n      try {\n        mainThreadGenerator.webgl.generateIntoCanvas(...args);\n        resolve({ timing: now() - start });\n      } catch (err) {\n        reject(err);\n      }\n    });\n    if (!timer) {\n      timer = setTimeout(nextChunk, 0);\n    }\n  })\n};\n\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */\nfunction generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n  let thread = threads[workerId];\n  if (!thread) {\n    thread = threads[workerId] = {\n      workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n        name: workerId,\n        workerId,\n        dependencies: [\n          webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          now\n        ],\n        init(_createSDFGenerator, now) {\n          const generate = _createSDFGenerator().javascript.generate;\n          return function (...args) {\n            const start = now();\n            const textureData = generate(...args);\n            return {\n              textureData,\n              timing: now() - start\n            }\n          }\n        },\n        getTransferables(result) {\n          return [result.textureData.buffer]\n        }\n      }),\n      requests: 0,\n      idleTimer: null\n    };\n  }\n\n  thread.requests++;\n  clearTimeout(thread.idleTimer);\n  return thread.workerModule(width, height, path, viewBox, distance, exponent)\n    .then(({ textureData, timing }) => {\n      // copy result data into the canvas\n      const start = now();\n      // expand single-channel data into rgba\n      const imageData = new Uint8Array(textureData.length * 4);\n      for (let i = 0; i < textureData.length; i++) {\n        imageData[i * 4 + channel] = textureData[i];\n      }\n      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n      timing += now() - start;\n\n      // clean up workers after a while\n      if (--thread.requests === 0) {\n        thread.idleTimer = setTimeout(() => { (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId); }, idleTimeout);\n      }\n      return { timing }\n    })\n}\n\nfunction warmUpSDFCanvas(canvas) {\n  if (!canvas._warm) {\n    mainThreadGenerator.webgl.isSupported(canvas);\n    canvas._warm = true;\n  }\n}\n\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/\nfunction typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},f=0;f<o;f++){var d=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[d]={offset:u,length:l};}for(f=0;f<s.length;f++){var v=s[f];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var f=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return f}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var f=s.readUshort(r,t);t+=2;var d=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+f),i.featureList=e._lctf.readFeatureList(r,h+d),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=n.readUshort(r,t);t+=2;var d=e._lctf.readLookupTable(r,o+f,a);s.push(d);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,f=0;f<i;f++){var d=n.readUshort(r,t);t+=2;var u=a(r,h,o+d,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var f=a.readUshort(r,t);t+=2;for(h=0;h<f;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2;var d=e._lctf.readFeatureTable(r,n+f);d.tag=h.trim(),o.push(d);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+f);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,o.default=e._lctf.readLangSysTable(r,n+s);var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[f.trim()]=e._lctf.readLangSysTable(r,n+d);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var f=[];for(i=0;i<h.length-1;i++)f.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var d=f[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,d),d.CharStrings){t=d.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));d.CharStrings=v;}if(d.ROS){t=d.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),d.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),d.FDArray.push(p);}t+=c[c.length-1],t=d.FDSelect,d.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)d.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return d.Encoding&&(d.Encoding=e.CFF.readEncoding(r,d.Encoding,d.CharStrings.length)),d.charset&&(d.charset=e.CFF.readCharset(r,d.charset,d.CharStrings.length)),e.CFF._readFDict(r,d,l),d},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var f=0;1==s?(f=r[t],t++):(f=n.readUshort(r,t),t+=2);for(i=0;i<=f;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,f=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(f=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(f=o-139,i=1),247<=o&&o<=250&&(f=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(f=256*-(o-251)-s-108,i=2),255==o&&(f=n.readInt(r,t+1)/65535,i=5),a.val=null!=f?f:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;i<=20&&(d=i,f=1),12==i&&(d=100*i+h,f=2),19!=i&&20!=i||(d=i,f=2),21<=i&&i<=27&&(d=i,f=1),28==i&&(u=o.readShort(r,t+1),f=3),29<=i&&i<=31&&(d=i,f=1),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i&&(u=o.readInt(r,t+1)/65535,f=5),s.push(null!=u?u:\"o\"+d),t+=f;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;if(28==i&&(u=n.readShort(r,t+1),f=3),29==i&&(u=n.readInt(r,t+1),f=5),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i)throw u=n.readInt(r,t+1)/65535,f=5,\"unknown number\";if(30==i){var l=[];for(f=1;;){var v=r[t+f];f++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(d=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],f=1,12==i)d=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],f=2;null!=d?(o[d]=1==s.length?s[0]:s,s=[]):s.push(u),t+=f;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var f=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+f+\"e\"+d,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,f,d,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var f=0;f<h;f++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),f=a.readUint(r,i+4),d=a.readUint(r,i+8);n.groups.push([h,f,d]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var f=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<f;i++){var d=n[o];if(o++,s.flags.push(d),0!=(8&d)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(d),i++;}}s.xs=[];for(i=0;i<f;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<f;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<f;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var f=o.readUshort(r,a);a+=2;var d=e._lctf.numOfOnes(f);0!=f&&(i.pos=e.GPOS.readValueRecord(r,a,f));}else if(2==t&&i.fmt>=1&&i.fmt<=2){f=o.readUshort(r,a);a+=2;var u=o.readUshort(r,a);a+=2;d=e._lctf.numOfOnes(f);var l=e._lctf.numOfOnes(u);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,p,u),p+=2*l),g.push({gid2:m,val1:x,val2:P});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var _=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var C=[];for(S=0;S<_;S++){var x=null,P=null;0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,a,u),a+=2*l),C.push({val1:x,val2:P});}i.matrix.push(C);}}}else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var f=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,f),a+=2*i.newg.length;}}else if(4==t){i.vals=[];f=o.readUshort(r,a);a+=2;for(var d=0;d<f;d++){var u=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+u));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var l=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+l),i.scset=[];var v=o.readUshort(r,a);a+=2;for(d=0;d<v;d++){var c=o.readUshort(r,a);a+=2,i.scset.push(0==c?null:e.GSUB.readSubClassSet(r,s+c));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(d=0;d<3;d++){f=o.readUshort(r,a);a+=2;for(var p=[],U=0;U<f;U++)p.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*U)));a+=2*f,0==d&&(i.backCvg=p),1==d&&(i.inptCvg=p),2==d&&(i.ahedCvg=p);}f=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,f);}}else {if(7==t&&1==i.fmt){var g=o.readUshort(r,a);a+=2;var S=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=g;else if(n.ltype!=g)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+S)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,f=0;f<n.maxp.numGlyphs;f++)f<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},f=0;f<i;f++){t+=2;a=o.readUshort(r,t);t+=2;var d=o.readUshort(r,t);t+=2;var u=d>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var f=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var d=f>>>8;if(0!=(d&=15))throw \"unknown kern table format: \"+d;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var d=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(f),u.vals.push(d),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var f=0;f<h;f++)s.push(o.readUshort(r,t+(f<<1))<<1);if(1==i)for(f=0;f<h;f++)s.push(o.readUint(r,t+(f<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],f=t+=2,d=0;d<s;d++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=f+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,f=1&r.flags[s],d=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(f){if(!d){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else d?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);f?d&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var f=o.crds[h],d=o.crds[h+1];a.crds.push(f*i.a+d*i.b+i.tx),a.crds.push(f*i.c+d*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U.getPairAdjustment=function(r,t,a){var n=!1;if(r.GPOS)for(var o=r.GPOS,s=o.lookupList,i=o.featureList,h=[],f=0;f<i.length;f++){var d=i[f];if(\"kern\"==d.tag){n=!0;for(var u=0;u<d.tab.length;u++)if(!h[d.tab[u]]){h[d.tab[u]]=!0;for(var l=s[d.tab[u]],v=0;v<l.tabs.length;v++)if(null!=l.tabs[v]){var c,p=l.tabs[v];if(!p.coverage||-1!=(c=e._lctf.coverageIndex(p.coverage,t)))if(1==l.ltype);else if(2==l.ltype){var U=null;if(1==p.fmt){var g=p.pairsets[c];for(f=0;f<g.length;f++)g[f].gid2==a&&(U=g[f]);}else if(2==p.fmt){var S=e.U._getGlyphClass(t,p.classDef1),m=e.U._getGlyphClass(a,p.classDef2);U=p.matrix[S][m];}if(U){var b=0;return U.val1&&U.val1[2]&&(b+=U.val1[2]),U.val2&&U.val2[0]&&(b+=U.val2[0]),b}}}}}}if(r.kern&&!n){var y=r.kern.glyph1.indexOf(t);if(-1!=y){var F=r.kern.rval[y].glyph2.indexOf(a);if(-1!=F)return r.kern.rval[y].vals[F]}}return 0},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var f=h.vals[i],d=0;d<f.length;d++){var u=f[d],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var _=b.substLookupRecords;for(d=0;d<_.length;d+=2)_[d],_[d+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var C=h.lookupRec;for(m=0;m<C.length;m+=2){U=C[m];var x=n[C[m+1]];e.U._applySubs(r,t+U,x,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,f=e.U.glyphToPath(r,i),d=0;d<f.crds.length;d+=2)n.crds.push(f.crds[d]+o),n.crds.push(f.crds[d+1]);a&&n.cmds.push(a);for(d=0;d<f.cmds.length;d++)n.cmds.push(f.cmds[d]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,_=0,C={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,C);var x=C.val;if(u+=C.size,\"o1\"==x||\"o18\"==x)s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==x||\"o23\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),d&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),d=!0;else if(\"o5\"==x)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==x||\"o7\"==x)for(var P=s.length,I=\"o6\"==x,w=0;w<P;w++){var O=s.shift();I?l+=O:v+=O,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==x||\"o24\"==x){P=s.length;for(var T=0;T+6<=P;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),T+=6;\"o24\"==x&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==x)break;if(\"o1234\"==x||\"o1235\"==x||\"o1236\"==x||\"o1237\"==x)\"o1234\"==x&&(p=v,U=(c=l+s.shift())+s.shift(),_=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),_=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==x){if(s.length>0&&!h&&(f=s.shift()+a.nominalWidthX,h=!0),4==s.length){var k=s.shift(),G=s.shift(),D=s.shift(),B=s.shift(),L=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[L],t,a,n,o),t.x=k,t.y=G,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}d&&(e.U.P.closePath(o),d=!1);}else if(\"o19\"==x||\"o20\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==x)s.length>2&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o22\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o25\"==x){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==x)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==x)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==x||\"o29\"==x){var A=\"o10\"==x?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=A.Subrs[W+A.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open;}}else if(\"o30\"==x||\"o31\"==x){var V=s.length,N=(T=0,\"o31\"==x);for(T+=V-(P=-3&V);T<P;)N?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),P-T==5?(l=U+s.shift(),T++):l=U,N=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),P-T==5?(v=g+s.shift(),T++):v=g,N=!0),e.U.P.curveTo(o,c,p,U,g,l,v),T+=4;}else {if(\"o\"==(x+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+x,r),x;s.push(x);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/\nfunction woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */\n\nfunction parserFactory(Typr, woff2otf) {\n  const cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  // {joinType: \"skip+step,...\"}\n  const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n  let joiningTypeMap;\n  function getCharJoiningType(ch) {\n    if (!joiningTypeMap) {\n      const m = {\n        R: JT_RIGHT,\n        L: JT_LEFT,\n        D: JT_DUAL,\n        C: JT_JOIN_CAUSING,\n        U: JT_NON_JOINING,\n        T: JT_TRANSPARENT\n      };\n      joiningTypeMap = new Map();\n      for (let type in joiningTypeRawData) {\n        let lastCode = 0;\n        joiningTypeRawData[type].split(',').forEach(range => {\n          let [skip, step] = range.split('+');\n          skip = parseInt(skip,36);\n          step = step ? parseInt(step, 36) : 0;\n          joiningTypeMap.set(lastCode += skip, m[type]);\n          for (let i = step; i--;) {\n            joiningTypeMap.set(++lastCode, m[type]);\n          }\n        });\n      }\n    }\n    return joiningTypeMap.get(ch) || JT_NON_JOINING\n  }\n\n  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n  function detectJoiningForms(str) {\n    // This implements the algorithm described here:\n    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n    const joiningForms = new Uint8Array(str.length);\n    let prevJoiningType = JT_NON_JOINING;\n    let prevForm = ISOL;\n    let prevIndex = -1;\n    for (let i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n      let joiningType = getCharJoiningType(code) | 0;\n      let form = ISOL;\n      if (joiningType & JT_TRANSPARENT) {\n        continue\n      }\n      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n          form = FINA;\n          // isol->init, fina->medi\n          if (prevForm === ISOL || prevForm === FINA) {\n            joiningForms[prevIndex]++;\n          }\n        }\n        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n      }\n      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n        // medi->fina, init->isol\n        if (prevForm === INIT || prevForm === MEDI) {\n          joiningForms[prevIndex]--;\n        }\n      }\n      prevForm = joiningForms[i] = form;\n      prevJoiningType = joiningType;\n      prevIndex = i;\n      if (code > 0xffff) i++;\n    }\n    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n    return joiningForms\n  }\n\n  function stringToGlyphs (font, str) {\n    const glyphIds = [];\n    for (let i = 0; i < str.length; i++) {\n      const cc = str.codePointAt(i);\n      if (cc > 0xffff) i++;\n      glyphIds.push(Typr.U.codeToGlyph(font, cc));\n    }\n\n    const gsub = font['GSUB'];\n    if (gsub) {\n      const {lookupList, featureList} = gsub;\n      let joiningForms;\n      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;\n      const usedLookups = [];\n      featureList.forEach(feature => {\n        if (supportedFeatures.test(feature.tag)) {\n          for (let ti = 0; ti < feature.tab.length; ti++) {\n            if (usedLookups[feature.tab[ti]]) continue\n            usedLookups[feature.tab[ti]] = true;\n            const tab = lookupList[feature.tab[ti]];\n            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n            if (isJoiningFeature && !joiningForms) { //lazy\n              joiningForms = detectJoiningForms(str);\n            }\n            for (let ci = 0; ci < glyphIds.length; ci++) {\n              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n              }\n            }\n          }\n        }\n      });\n    }\n\n    return glyphIds\n  }\n\n  function firstNum(...args) {\n    for (let i = 0; i < args.length; i++) {\n      if (typeof args[i] === 'number') {\n        return args[i]\n      }\n    }\n  }\n\n  function wrapFontObj(typrFont) {\n    const glyphMap = Object.create(null);\n\n    const os2 = typrFont['OS/2'];\n    const hhea = typrFont.hhea;\n    const unitsPerEm = typrFont.head.unitsPerEm;\n    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n    const fontObj = {\n      unitsPerEm,\n      ascender,\n      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n      capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n      xHeight: firstNum(os2 && os2.sxHeight, ascender),\n      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n      forEachGlyph(text, fontSize, letterSpacing, callback) {\n        let glyphX = 0;\n        const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        const glyphIndices = stringToGlyphs(typrFont, text);\n        let charIndex = 0;\n        let prevGlyphIndex = -1;\n        glyphIndices.forEach((glyphIndex, i) => {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphIndex !== -1) {\n            let glyphObj = glyphMap[glyphIndex];\n            if (!glyphObj) {\n              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphIndex);\n\n              // Build path string\n              let path = '';\n              let crdsIdx = 0;\n              for (let i = 0, len = cmds.length; i < len; i++) {\n                const numArgs = cmdArgLengths[cmds[i]];\n                path += cmds[i];\n                for (let j = 1; j <= numArgs; j++) {\n                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                }\n              }\n\n              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n              // normalize the two, so it's simplest just to iterate ourselves.\n              let xMin, yMin, xMax, yMax;\n              if (crds.length) {\n                xMin = yMin = Infinity;\n                xMax = yMax = -Infinity;\n                for (let i = 0, len = crds.length; i < len; i += 2) {\n                  let x = crds[i];\n                  let y = crds[i + 1];\n                  if (x < xMin) xMin = x;\n                  if (y < yMin) yMin = y;\n                  if (x > xMax) xMax = x;\n                  if (y > yMax) yMax = y;\n                }\n              } else {\n                xMin = xMax = yMin = yMax = 0;\n              }\n\n              glyphObj = glyphMap[glyphIndex] = {\n                index: glyphIndex,\n                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                xMin,\n                yMin,\n                xMax,\n                yMax,\n                path,\n                pathCommandCount: cmds.length,\n                // forEachPathCommand(callback) {\n                //   let argsIndex = 0\n                //   const argsArray = []\n                //   for (let i = 0, len = cmds.length; i < len; i++) {\n                //     const numArgs = cmdArgLengths[cmds[i]]\n                //     argsArray.length = 1 + numArgs\n                //     argsArray[0] = cmds[i]\n                //     for (let j = 1; j <= numArgs; j++) {\n                //       argsArray[j] = crds[argsIndex++]\n                //     }\n                //     callback.apply(null, argsArray)\n                //   }\n                // }\n              };\n            }\n\n            // Kerning\n            if (prevGlyphIndex !== -1) {\n              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;\n            }\n\n            callback.call(null, glyphObj, glyphX, charIndex);\n\n            if (glyphObj.advanceWidth) {\n              glyphX += glyphObj.advanceWidth * fontScale;\n            }\n            if (letterSpacing) {\n              glyphX += letterSpacing * fontSize;\n            }\n\n            prevGlyphIndex = glyphIndex;\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n        return glyphX\n      }\n    };\n\n    return fontObj\n  }\n\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    const peek = new Uint8Array(buffer, 0, 4);\n    const tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer)[0])\n  }\n}\n\n\nconst workerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typr Font Parser',\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init(typrFactory, woff2otfFactory, parserFactory) {\n    const Typr = typrFactory();\n    const woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\nconst CONFIG = {\n  defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular\n  sdfGlyphSize: 64,\n  sdfMargin: 1 / 16,\n  sdfExponent: 9,\n  textureWidth: 2048\n};\nconst tempColor = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\n\nfunction now$1() {\n  return (self.performance || Date).now()\n}\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n */\nfunction configureTextBuilder(config) {\n  if (hasRequested) {\n    console.warn('configureTextBuilder called after first font request; will be ignored.');\n  } else {\n    assign(CONFIG, config);\n  }\n}\n\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */\nconst atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {object} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           three elements: the starting X, the ending X, and the bottom Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {object} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  hasRequested = true;\n  args = assign({}, args);\n  const totalStart = now$1();\n\n  // Apply default font here to avoid a 'null' atlas, and convert relative\n  // URLs to absolute so they can be resolved in the worker\n  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n\n  // Normalize colors\n  if (args.colorRanges != null) {\n    let colors = {};\n    for (let key in args.colorRanges) {\n      if (args.colorRanges.hasOwnProperty(key)) {\n        let val = args.colorRanges[key];\n        if (typeof val !== 'number') {\n          val = tempColor.set(val).getHex();\n        }\n        colors[key] = val;\n      }\n    }\n    args.colorRanges = colors;\n  }\n\n  Object.freeze(args);\n\n  // Init the atlas if needed\n  const {textureWidth, sdfExponent} = CONFIG;\n  const {sdfGlyphSize} = args;\n  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n  let atlas = atlases[sdfGlyphSize];\n  if (!atlas) {\n    const canvas = document.createElement('canvas');\n    canvas.width = textureWidth;\n    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n    atlas = atlases[sdfGlyphSize] = {\n      glyphCount: 0,\n      sdfGlyphSize,\n      sdfCanvas: canvas,\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(\n        canvas,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter\n      ),\n      contextLost: false,\n      glyphsByFont: new Map()\n    };\n    atlas.sdfTexture.generateMipmaps = false;\n    initContextLossHandling(atlas);\n  }\n\n  const {sdfTexture, sdfCanvas} = atlas;\n  let fontGlyphs = atlas.glyphsByFont.get(args.font);\n  if (!fontGlyphs) {\n    atlas.glyphsByFont.set(args.font, fontGlyphs = new Map());\n  }\n\n  // Issue request to the typesetting engine in the worker\n  typesetInWorker(args).then(result => {\n    const {glyphIds, glyphPositions, fontSize, unitsPerEm, timings} = result;\n    const neededSDFs = [];\n    const glyphBounds = new Float32Array(glyphIds.length * 4);\n    const fontSizeMult = fontSize / unitsPerEm;\n    let boundsIdx = 0;\n    let positionsIdx = 0;\n    const quadsStart = now$1();\n    glyphIds.forEach((glyphId, i) => {\n      let glyphInfo = fontGlyphs.get(glyphId);\n\n      // If this is a glyphId not seen before, add it to the atlas\n      if (!glyphInfo) {\n        const {path, pathBounds} = result.glyphData[glyphId];\n\n        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n        // useful interpolated values and will be ignored anyway.\n        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n        const atlasIndex = atlas.glyphCount++;\n        const sdfViewBox = [\n          pathBounds[0] - fontUnitsMargin,\n          pathBounds[1] - fontUnitsMargin,\n          pathBounds[2] + fontUnitsMargin,\n          pathBounds[3] + fontUnitsMargin,\n        ];\n        fontGlyphs.set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n        // Collect those that need SDF generation\n        neededSDFs.push(glyphInfo);\n      }\n\n      // Calculate bounds for renderable quads\n      // TODO can we get this back off the main thread?\n      const {sdfViewBox} = glyphInfo;\n      const posX = glyphPositions[positionsIdx++];\n      const posY = glyphPositions[positionsIdx++];\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n      // Convert glyphId to SDF index for the shader\n      glyphIds[i] = glyphInfo.atlasIndex;\n    });\n    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n    const sdfStart = now$1();\n    timings.sdf = {};\n\n    // Grow the texture height by power of 2 if needed\n    const currentHeight = sdfCanvas.height;\n    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n    if (neededHeight > currentHeight) {\n      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n      sdfTexture.dispose();\n    }\n\n    Promise.all(neededSDFs.map(glyphInfo =>\n      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n        timings.sdf[glyphInfo.atlasIndex] = timing;\n      })\n    )).then(() => {\n      if (neededSDFs.length && !atlas.contextLost) {\n        safariPre15Workaround(atlas);\n        sdfTexture.needsUpdate = true;\n      }\n      timings.sdfTotal = now$1() - sdfStart;\n      timings.total = now$1() - totalStart;\n      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture,\n        sdfGlyphSize,\n        sdfExponent,\n        glyphBounds,\n        glyphAtlasIndices: glyphIds,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        caretHeight: result.caretHeight,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        capHeight: result.capHeight,\n        xHeight: result.xHeight,\n        topBaseline: result.topBaseline,\n        blockBounds: result.blockBounds,\n        visibleBounds: result.visibleBounds,\n        timings: result.timings,\n      }));\n    });\n  });\n\n  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n  // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n  // a head start on that process before SDFs actually start getting processed.\n  Promise.resolve().then(() => {\n    if (!atlas.contextLost) {\n      warmUpSDFCanvas(sdfCanvas);\n    }\n  });\n}\n\nfunction generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n  if (contextLost) {\n    // If the context is lost there's nothing we can do, just quit silently and let it\n    // get regenerated when the context is restored\n    return Promise.resolve({timing: -1})\n  }\n  const {textureWidth, sdfExponent} = CONFIG;\n  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n  const squareIndex = Math.floor(atlasIndex / 4);\n  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n  const channel = atlasIndex % 4;\n  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n}\n\nfunction initContextLossHandling(atlas) {\n  const canvas = atlas.sdfCanvas;\n\n  /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */\n\n  canvas.addEventListener('webglcontextlost', (event) => {\n    console.log('Context Lost', event);\n    event.preventDefault();\n    atlas.contextLost = true;\n  });\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    console.log('Context Restored', event);\n    atlas.contextLost = false;\n    // Regenerate all glyphs into the restored canvas:\n    const promises = [];\n    atlas.glyphsByFont.forEach(glyphMap => {\n      glyphMap.forEach(glyph => {\n        promises.push(generateGlyphSDF(glyph, atlas, true));\n      });\n    });\n    Promise.all(promises).then(() => {\n      safariPre15Workaround(atlas);\n      atlas.sdfTexture.needsUpdate = true;\n    });\n  });\n}\n\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */\nfunction preloadFont({font, characters, sdfGlyphSize}, callback) {\n  let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n}\n\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (let key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n  if (!linkEl) {\n    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n  }\n  linkEl.href = path;\n  return linkEl.href\n}\n\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */\nfunction safariPre15Workaround(atlas) {\n  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n  // have supported it for a long while so any false positives should be minimal.\n  if (typeof createImageBitmap !== 'function') {\n    console.info('Safari<15: applying SDF canvas workaround');\n    const {sdfCanvas, sdfTexture} = atlas;\n    const {width, height} = sdfCanvas;\n    const gl = atlas.sdfCanvas.getContext('webgl');\n    let pixels = sdfTexture.image.data;\n    if (!pixels || pixels.length !== width * height * 4) {\n      pixels = new Uint8Array(width * height * 4);\n      sdfTexture.image = {width, height, data: pixels};\n      sdfTexture.flipY = false;\n      sdfTexture.isDataTexture = true;\n    }\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n}\n\n\nconst typesetterWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    CONFIG,\n    workerModule,\n    createTypesetter,\n    bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  ],\n  init(config, fontParser, createTypesetter, bidiFactory) {\n    const {defaultFontURL} = config;\n    return createTypesetter(fontParser, bidiFactory(), { defaultFontURL })\n  }\n});\n\nconst typesetInWorker = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    typesetterWorkerModule,\n  ],\n  init(typesetter) {\n    return function(args) {\n      return new Promise(resolve => {\n        typesetter.typeset(args, resolve);\n      })\n    }\n  },\n  getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    const transferables = [\n      result.glyphPositions.buffer,\n      result.glyphIds.buffer\n    ];\n    if (result.caretPositions) {\n      transferables.push(result.caretPositions.buffer);\n    }\n    if (result.glyphColors) {\n      transferables.push(result.glyphColors.buffer);\n    }\n    return transferables\n  }\n});\n\nfunction dumpSDFTextures() {\n  Object.keys(atlases).forEach(size => {\n    const canvas = atlases[size].sdfCanvas;\n    const {width, height} = canvas;\n    console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n  });\n}\n\nconst templateGeometries = {};\n\nfunction getTemplateGeometry(detail) {\n  let geom = templateGeometries[detail];\n  if (!geom) {\n    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n    const front = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail);\n    const back = front.clone();\n    const frontAttrs = front.attributes;\n    const backAttrs = back.attributes;\n    const combined = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n    const vertCount = frontAttrs.uv.count;\n    for (let i = 0; i < vertCount; i++) {\n      backAttrs.position.array[i * 3] *= -1; // flip position x\n      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n    }\n    ['position', 'normal', 'uv'].forEach(name => {\n      combined.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(\n        [...frontAttrs[name].array, ...backAttrs[name].array],\n        frontAttrs[name].itemSize)\n      );\n    });\n    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n    combined.translate(0.5, 0.5, 0);\n    geom = templateGeometries[detail] = combined;\n  }\n  return geom\n}\n\nconst glyphBoundsAttrName = 'aTroikaGlyphBounds';\nconst glyphIndexAttrName = 'aTroikaGlyphIndex';\nconst glyphColorAttrName = 'aTroikaGlyphColor';\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nclass GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    this.detail = 1;\n    this.curveRadius = 0;\n\n    // Define groups for rendering text outline as a separate pass; these will only\n    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n    this.groups = [\n      {start: 0, count: Infinity, materialIndex: 0},\n      {start: 0, count: Infinity, materialIndex: 1}\n    ];\n\n    // Preallocate empty bounding objects\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n  }\n\n  computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n  }\n\n  computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n  }\n\n  // Since our base geometry contains triangles for both front and back sides, we can emulate\n  // the \"side\" by restricting the draw range.\n  setSide(side) {\n    const verts = this.getIndex().count;\n    this.setDrawRange(side === three__WEBPACK_IMPORTED_MODULE_3__.BackSide ? verts / 2 : 0, side === three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide ? verts : verts / 2);\n  }\n\n  set detail(detail) {\n    if (detail !== this._detail) {\n      this._detail = detail;\n      if (typeof detail !== 'number' || detail < 1) {\n        detail = 1;\n      }\n      let tpl = getTemplateGeometry(detail)\n      ;['position', 'normal', 'uv'].forEach(attr => {\n        this.attributes[attr] = tpl.attributes[attr].clone();\n      });\n      this.setIndex(tpl.getIndex().clone());\n    }\n  }\n  get detail() {\n    return this._detail\n  }\n\n  set curveRadius(r) {\n    if (r !== this._curveRadius) {\n      this._curveRadius = r;\n      this._updateBounds();\n    }\n  }\n  get curveRadius() {\n    return this._curveRadius\n  }\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */\n  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n    // Update the instance attributes\n    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n    this._blockBounds = blockBounds;\n    this._chunkedBounds = chunkedBounds;\n    this.instanceCount = glyphAtlasIndices.length;\n    this._updateBounds();\n  }\n\n  _updateBounds() {\n    const bounds = this._blockBounds;\n    if (bounds) {\n      const { curveRadius, boundingBox: bbox } = this;\n      if (curveRadius) {\n        const { PI, floor, min, max, sin, cos } = Math;\n        const halfPi = PI / 2;\n        const twoPi = PI * 2;\n        const absR = Math.abs(curveRadius);\n        const leftAngle = bounds[0] / absR;\n        const rightAngle = bounds[2] / absR;\n        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n      } else {\n        bbox.min.set(bounds[0], bounds[1], 0);\n        bbox.max.set(bounds[2], bounds[3], 0);\n      }\n      bbox.getBoundingSphere(this.boundingSphere);\n    }\n  }\n\n  /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */\n  applyClipRect(clipRect) {\n    let count = this.getAttribute(glyphIndexAttrName).count;\n    let chunks = this._chunkedBounds;\n    if (chunks) {\n      for (let i = chunks.length; i--;) {\n        count = chunks[i].end;\n        let rect = chunks[i].rect;\n        // note: both rects are l-b-r-t\n        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n          break\n        }\n      }\n    }\n    this.instanceCount = count;\n  }\n}\n\n\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n  const attr = geom.getAttribute(attrName);\n  if (newArray) {\n    // If length isn't changing, just update the attribute's array data\n    if (attr && attr.array.length === newArray.length) {\n      attr.array.set(newArray);\n      attr.needsUpdate = true;\n    } else {\n      geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n      // If the new attribute has a different size, we also have to (as of r117) manually clear the\n      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n      // implies it should be supported. It's possible we need to\n      delete geom._maxInstanceCount; //for r117+, could be fragile\n      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n    }\n  } else if (attr) {\n    geom.deleteAttribute(attrName);\n  }\n}\n\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    extensions: {\n      derivatives: true\n    },\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFExponent: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaDistanceOffset: {value: 0},\n      uTroikaOutlineOpacity: {value: 0},\n      uTroikaFillOpacity: {value: 1},\n      uTroikaPositionOffset: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaCurveRadius: {value: 0},\n      uTroikaBlurRadius: {value: 0},\n      uTroikaStrokeWidth: {value: 0},\n      uTroikaStrokeColor: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()},\n      uTroikaStrokeOpacity: {value: 1},\n      uTroikaOrient: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()},\n      uTroikaUseGlyphColors: {value: true},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM,\n    customRewriter({vertexShader, fragmentShader}) {\n      let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n      if (uDiffuseRE.test(fragmentShader)) {\n        // Replace all instances of `diffuse` with our varying\n        fragmentShader = fragmentShader\n          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n          .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n        // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n        if (!uDiffuseRE.test(vertexShader)) {\n          vertexShader = vertexShader.replace(\n            troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp,\n            'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n          );\n        }\n      }\n      return { vertexShader, fragmentShader }\n    }\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  Object.defineProperties(textMaterial, {\n    isTroikaTextMaterial: {value: true},\n\n    // WebGLShadowMap reverses the side of the shadow material by default, which fails\n    // for planes, so here we force the `shadowSide` to always match the main side.\n    shadowSide: {\n      get() {\n        return this.side\n      },\n      set() {\n        //no-op\n      }\n    }\n  });\n\n  return textMaterial\n}\n\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n  transparent: true\n});\nconst defaultStrokeColor = 0x808080;\n\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = '+x+y';\n\nfunction first(o) {\n  return Array.isArray(o) ? o[0] : o\n}\n\nlet getFlatRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1),\n    defaultMaterial\n  );\n  getFlatRaycastMesh = () => mesh;\n  return mesh\n};\nlet getCurvedRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1),\n    defaultMaterial\n  );\n  getCurvedRaycastMesh = () => mesh;\n  return mesh\n};\n\nconst syncStartEvent = { type: 'syncstart' };\nconst syncCompleteEvent = { type: 'synccomplete' };\n\nconst SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'direction',\n  'textAlign',\n  'textIndent',\n  'whiteSpace',\n  'anchorX',\n  'anchorY',\n  'colorRanges',\n  'sdfGlyphSize'\n];\n\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n  'material',\n  'color',\n  'depthOffset',\n  'clipRect',\n  'curveRadius',\n  'orientation',\n  'glyphGeometryDetail'\n);\n\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nclass Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n  constructor() {\n    const geometry = new GlyphsGeometry();\n    super(geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */\n    this.anchorX = 0;\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */\n    this.anchorY = 0;\n\n    /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */\n    this.curveRadius = 0;\n\n    /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */\n    this.direction = 'auto';\n\n    /**\n     * @member {string} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to the Roboto font loaded from Google Fonts.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */\n    this.textIndent = 0;\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */\n    this.color = null;\n\n    /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */\n    this.colorRanges = null;\n\n    /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */\n    this.outlineWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */\n    this.outlineColor = 0x000000;\n\n    /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */\n    this.outlineOpacity = 1;\n\n    /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineBlur = 0;\n\n    /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetX = 0;\n\n    /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetY = 0;\n\n    /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.strokeWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */\n    this.strokeColor = defaultStrokeColor;\n\n    /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */\n    this.strokeOpacity = 1;\n\n    /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */\n    this.fillOpacity = 1;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */\n    this.orientation = defaultOrient;\n\n    /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */\n    this.glyphGeometryDetail = 1;\n\n    /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */\n    this.sdfGlyphSize = null;\n\n    /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */\n    this.gpuAccelerateSDF = true;\n\n    this.debugSDF = false;\n  }\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  sync(callback) {\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n        this.dispatchEvent(syncStartEvent);\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          fontSize: this.fontSize || 0.1,\n          letterSpacing: this.letterSpacing || 0,\n          lineHeight: this.lineHeight || 'normal',\n          maxWidth: this.maxWidth,\n          direction: this.direction || 'auto',\n          textAlign: this.textAlign,\n          textIndent: this.textIndent,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          colorRanges: this.colorRanges,\n          includeCaretPositions: true, //TODO parameterize\n          sdfGlyphSize: this.sdfGlyphSize,\n          gpuAccelerateSDF: this.gpuAccelerateSDF,\n        }, textRenderInfo => {\n          this._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this.geometry.updateGlyphs(\n            textRenderInfo.glyphBounds,\n            textRenderInfo.glyphAtlasIndices,\n            textRenderInfo.blockBounds,\n            textRenderInfo.chunkedBounds,\n            textRenderInfo.glyphColors\n          );\n\n          // If we had extra sync requests queued up, kick it off\n          const queued = this._queuedSyncs;\n          if (queued) {\n            this._queuedSyncs = null;\n            this._needsSync = true;\n            this.sync(() => {\n              queued.forEach(fn => fn && fn());\n            });\n          }\n\n          this.dispatchEvent(syncCompleteEvent);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  onBeforeRender(renderer, scene, camera, geometry, material, group) {\n    this.sync();\n\n    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n    if (material.isTroikaTextMaterial) {\n      this._prepareForRender(material);\n    }\n\n    // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n    // is instead applied via drawRange in the GlyphsGeometry.\n    material._hadOwnSide = material.hasOwnProperty('side');\n    this.geometry.setSide(material._actualSide = material.side);\n    material.side = three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;\n  }\n\n  onAfterRender(renderer, scene, camera, geometry, material, group) {\n    // Restore original material side\n    if (material._hadOwnSide) {\n      material.side = material._actualSide;\n    } else {\n      delete material.side; // back to inheriting from base material\n    }\n  }\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  dispose() {\n    this.geometry.dispose();\n  }\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  get textRenderInfo() {\n    return this._textRenderInfo || null\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    // If text outline is configured, render it as a preliminary draw using Three's multi-material\n    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n    // materials ensures the layers are always rendered consecutively in a consistent order.\n    // Each layer will trigger onBeforeRender with the appropriate material.\n    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n      let outlineMaterial = derivedMaterial._outlineMtl;\n      if (!outlineMaterial) {\n        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n          id: {value: derivedMaterial.id + 0.1}\n        });\n        outlineMaterial.isTextOutlineMaterial = true;\n        outlineMaterial.depthWrite = false;\n        outlineMaterial.map = null; //???\n        derivedMaterial.addEventListener('dispose', function onDispose() {\n          derivedMaterial.removeEventListener('dispose', onDispose);\n          outlineMaterial.dispose();\n        });\n      }\n      return [\n        outlineMaterial,\n        derivedMaterial\n      ]\n    } else {\n      return derivedMaterial\n    }\n  }\n  set material(baseMaterial) {\n    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n      this._derivedMaterial = baseMaterial;\n      this._baseMaterial = baseMaterial.baseMaterial;\n    } else {\n      this._baseMaterial = baseMaterial;\n    }\n  }\n\n  get glyphGeometryDetail() {\n    return this.geometry.detail\n  }\n  set glyphGeometryDetail(detail) {\n    this.geometry.detail = detail;\n  }\n\n  get curveRadius() {\n    return this.geometry.curveRadius\n  }\n  set curveRadius(r) {\n    this.geometry.curveRadius = r;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return first(this.material).getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return first(this.material).getDistanceMaterial()\n  }\n\n  _prepareForRender(material) {\n    const isOutline = material.isTextOutlineMaterial;\n    const uniforms = material.uniforms;\n    const textInfo = this.textRenderInfo;\n    if (textInfo) {\n      const {sdfTexture, blockBounds} = textInfo;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n      let distanceOffset = 0;\n      let blurRadius = 0;\n      let strokeWidth = 0;\n      let fillOpacity;\n      let strokeOpacity;\n      let strokeColor;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (isOutline) {\n        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n        distanceOffset = this._parsePercent(outlineWidth) || 0;\n        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n        fillOpacity = outlineOpacity;\n        offsetX = this._parsePercent(outlineOffsetX) || 0;\n        offsetY = this._parsePercent(outlineOffsetY) || 0;\n      } else {\n        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n        if (strokeWidth) {\n          strokeColor = this.strokeColor;\n          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n          strokeOpacity = this.strokeOpacity;\n          if (strokeOpacity == null) strokeOpacity = 1;\n        }\n        fillOpacity = this.fillOpacity;\n      }\n\n      uniforms.uTroikaDistanceOffset.value = distanceOffset;\n      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n      uniforms.uTroikaBlurRadius.value = blurRadius;\n      uniforms.uTroikaStrokeWidth.value = strokeWidth;\n      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n      let clipRect = this.clipRect;\n      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n        uniforms.uTroikaClipRect.value.fromArray(clipRect);\n      } else {\n        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n        const pad = (this.fontSize || 0.1) * 100;\n        uniforms.uTroikaClipRect.value.set(\n          blockBounds[0] - pad,\n          blockBounds[1] - pad,\n          blockBounds[2] + pad,\n          blockBounds[3] + pad\n        );\n      }\n      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n    }\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // Shortcut for setting material color via `color` prop on the mesh; this is\n    // applied only to the derived material to avoid mutating a shared base material.\n    const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n    if (color == null) {\n      delete material.color; //inherit from base\n    } else {\n      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color());\n      if (color !== colorObj._input || typeof color === 'object') {\n        colorObj.set(colorObj._input = color);\n      }\n    }\n\n    // base orientation\n    let orient = this.orientation || defaultOrient;\n    if (orient !== material._orientation) {\n      let rotMat = uniforms.uTroikaOrient.value;\n      orient = orient.replace(/[^-+xyz]/g, '');\n      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n      if (match) {\n        let [, hSign, hAxis, vSign, vAxis] = match;\n        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n        rotMat.setFromMatrix4(tempMat4);\n      } else {\n        rotMat.identity();\n      }\n      material._orientation = orient;\n    }\n  }\n\n  _parsePercent(value) {\n    if (typeof value === 'string') {\n      let match = value.match(/^(-?[\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n    }\n    return value\n  }\n\n  /**\n   * Translate a point in local space to an x/y in the text plane.\n   */\n  localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    target.copy(position); //simple non-curved case is 1:1\n    const r = this.curveRadius;\n    if (r) { //flatten the curve\n      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n    }\n    return target\n  }\n\n  /**\n   * Translate a point in world space to an x/y in the text plane.\n   */\n  worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    tempVec3a.copy(position);\n    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n  }\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  raycast(raycaster, intersects) {\n    const {textRenderInfo, curveRadius} = this;\n    if (textRenderInfo) {\n      const bounds = textRenderInfo.blockBounds;\n      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n      const geom = raycastMesh.geometry;\n      const {position, uv} = geom.attributes;\n      for (let i = 0; i < uv.count; i++) {\n        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n        let z = 0;\n        if (curveRadius) {\n          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n          x = Math.sin(x / curveRadius) * curveRadius;\n        }\n        position.setXYZ(i, x, y, z);\n      }\n      geom.boundingSphere = this.geometry.boundingSphere;\n      geom.boundingBox = this.geometry.boundingBox;\n      raycastMesh.matrixWorld = this.matrixWorld;\n      raycastMesh.material.side = this.material.side;\n      tempArray.length = 0;\n      raycastMesh.raycast(raycaster, tempArray);\n      for (let i = 0; i < tempArray.length; i++) {\n        tempArray[i].object = this;\n        intersects.push(tempArray[i]);\n      }\n    }\n  }\n\n  copy(source) {\n    // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n    const geom = this.geometry;\n    super.copy(source);\n    this.geometry = geom;\n\n    COPYABLE_PROPS.forEach(prop => {\n      this[prop] = source[prop];\n    });\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n}\n\n\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach(prop => {\n  const privateKey = '_private_' + prop;\n  Object.defineProperty(Text.prototype, prop, {\n    get() {\n      return this[privateKey]\n    },\n    set(value) {\n      if (value !== this[privateKey]) {\n        this[privateKey] = value;\n        this._needsSync = true;\n      }\n    }\n  });\n});\n\n//=== Utility functions for dealing with carets and selection ranges ===//\n\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */\n\n/**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */\nfunction getCaretAtPoint(textRenderInfo, x, y) {\n  let closestCaret = null;\n  const {caretHeight} = textRenderInfo;\n  const caretsByRow = groupCaretsByRow(textRenderInfo);\n\n  // Find nearest row by y first\n  let closestRowY = Infinity;\n  caretsByRow.forEach((carets, rowY) => {\n    if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {\n      closestRowY = rowY;\n    }\n  });\n\n  // Then find closest caret by x within that row\n  caretsByRow.get(closestRowY).forEach(caret => {\n    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n      closestCaret = caret;\n    }\n  });\n  return closestCaret\n}\n\n\nconst _rectsCache = new WeakMap();\n\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */\nfunction getSelectionRects(textRenderInfo, start, end) {\n  let rects;\n  if (textRenderInfo) {\n    // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n    let prevResult = _rectsCache.get(textRenderInfo);\n    if (prevResult && prevResult.start === start && prevResult.end === end) {\n      return prevResult.rects\n    }\n\n    const {caretPositions, caretHeight} = textRenderInfo;\n\n    // Normalize\n    if (end < start) {\n      const s = start;\n      start = end;\n      end = s;\n    }\n    start = Math.max(start, 0);\n    end = Math.min(end, caretPositions.length + 1);\n\n    // Build list of rects, expanding the current rect for all characters in a run and starting\n    // a new rect whenever reaching a new line or a new bidi direction\n    rects = [];\n    let currentRect = null;\n    for (let i = start; i < end; i++) {\n      const x1 = caretPositions[i * 3];\n      const x2 = caretPositions[i * 3 + 1];\n      const left = Math.min(x1, x2);\n      const right = Math.max(x1, x2);\n      const bottom = caretPositions[i * 3 + 2];\n      if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {\n        currentRect = {\n          left: Infinity,\n          right: -Infinity,\n          bottom: bottom,\n          top: bottom + caretHeight\n        };\n        rects.push(currentRect);\n      }\n      currentRect.left = Math.min(left, currentRect.left);\n      currentRect.right = Math.max(right, currentRect.right);\n    }\n\n    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n    for (let i = rects.length - 1; i-- > 0;) {\n      const rectA = rects[i];\n      const rectB = rects[i + 1];\n      if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n        rectB.left = Math.min(rectB.left, rectA.left);\n        rectB.right = Math.max(rectB.right, rectA.right);\n        rects.splice(i, 1);\n      }\n    }\n\n    _rectsCache.set(textRenderInfo, {start, end, rects});\n  }\n  return rects\n}\n\nconst _caretsByRowCache = new WeakMap();\n\nfunction groupCaretsByRow(textRenderInfo) {\n  // textRenderInfo is frozen so it's safe to cache based on it\n  let caretsByRow = _caretsByRowCache.get(textRenderInfo);\n  if (!caretsByRow) {\n    const {caretPositions, caretHeight} = textRenderInfo;\n    caretsByRow = new Map();\n    for (let i = 0; i < caretPositions.length; i += 3) {\n      const rowY = caretPositions[i + 2];\n      let rowCarets = caretsByRow.get(rowY);\n      if (!rowCarets) {\n        caretsByRow.set(rowY, rowCarets = []);\n      }\n      rowCarets.push({\n        x: caretPositions[i],\n        y: rowY,\n        height: caretHeight,\n        charIndex: i / 3\n      });\n      // Add one more caret after the final char\n      if (i + 3 >= caretPositions.length) {\n        rowCarets.push({\n          x: caretPositions[i + 1],\n          y: rowY,\n          height: caretHeight,\n          charIndex: i / 3 + 1\n        });\n      }\n    }\n  }\n  _caretsByRowCache.set(textRenderInfo, caretsByRow);\n  return caretsByRow\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb1I7QUFDMU07QUFDckI7QUFDbkI7QUFDeUM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxFQUFFLGlDQUFpQyxpQkFBaUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEdBQUcsa0JBQWtCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFMksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanM/MWY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlLCBMaW5lYXJGaWx0ZXIsIENvbG9yLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgU3BoZXJlLCBCb3gzLCBCYWNrU2lkZSwgRG91YmxlU2lkZSwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBQbGFuZUdlb21ldHJ5LCBCdWZmZXJHZW9tZXRyeSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVmVjdG9yMiwgVmVjdG9yNCwgTWF0cml4MywgTWVzaCwgRnJvbnRTaWRlLCBNZXNoQmFzaWNNYXRlcmlhbCwgTWF0cml4NCwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHRlcm1pbmF0ZVdvcmtlciwgZGVmaW5lV29ya2VyTW9kdWxlIH0gZnJvbSAndHJvaWthLXdvcmtlci11dGlscyc7XG5pbXBvcnQgY3JlYXRlU0RGR2VuZXJhdG9yIGZyb20gJ3dlYmdsLXNkZi1nZW5lcmF0b3InO1xuaW1wb3J0IGJpZGlGYWN0b3J5IGZyb20gJ2JpZGktanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCB2b2lkTWFpblJlZ0V4cCB9IGZyb20gJ3Ryb2lrYS10aHJlZS11dGlscyc7XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHR5cGVzZXR0aW5nIHJlcXVlc3RzLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIG5vIGNsb3N1cmUgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IGl0IGNhbiBiZSBlYXNpbHkgaW5qZWN0ZWRcbiAqIGludG8gdGhlIHNvdXJjZSBmb3IgYSBXb3JrZXIgd2l0aG91dCByZXF1aXJpbmcgYSBidWlsZCBzdGVwIG9yIGNvbXBsZXggZGVwZW5kZW5jeSBsb2FkaW5nLiBBbGwgaXRzXG4gKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm9udFBhcnNlciAtIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIEFycmF5QnVmZmVyIG9mIHRoZSBmb250IGRhdGEgYW5kIHJldHVybnNcbiAqIGEgc3RhbmRhcmRpemVkIHN0cnVjdHVyZSBnaXZpbmcgYWNjZXNzIHRvIHRoZSBmb250IGFuZCBpdHMgZ2x5cGhzOlxuICogICB7XG4gKiAgICAgdW5pdHNQZXJFbTogbnVtYmVyLFxuICogICAgIGFzY2VuZGVyOiBudW1iZXIsXG4gKiAgICAgZGVzY2VuZGVyOiBudW1iZXIsXG4gKiAgICAgY2FwSGVpZ2h0OiBudW1iZXIsXG4gKiAgICAgeEhlaWdodDogbnVtYmVyLFxuICogICAgIGxpbmVHYXA6IG51bWJlcixcbiAqICAgICBmb3JFYWNoR2x5cGgoc3RyaW5nLCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgY2FsbGJhY2spIHtcbiAqICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCB0byByZW5kZXIsIHBhc3NpbmcgaXQgYW4gb2JqZWN0OlxuICogICAgICAgY2FsbGJhY2soe1xuICogICAgICAgICBpbmRleDogbnVtYmVyLFxuICogICAgICAgICBhZHZhbmNlV2lkdGg6IG51bWJlcixcbiAqICAgICAgICAgeE1pbjogbnVtYmVyLFxuICogICAgICAgICB5TWluOiBudW1iZXIsXG4gKiAgICAgICAgIHhNYXg6IG51bWJlcixcbiAqICAgICAgICAgeU1heDogbnVtYmVyLFxuICogICAgICAgICBwYXRoOiBzdHJpbmcsXG4gKiAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IG51bWJlclxuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqIEBwYXJhbSB7b2JqZWN0fSBiaWRpIC0gdGhlIGJpZGkuanMgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFBhcnNlciwgYmlkaSwgY29uZmlnKSB7XG5cbiAgY29uc3Qge1xuICAgIGRlZmF1bHRGb250VVJMXG4gIH0gPSBjb25maWc7XG5cbiAgLyoqXG4gICAqIEhvbGRzIHBhcnNlZCBmb250IG9iamVjdHMgYnkgdXJsXG4gICAqL1xuICBjb25zdCBmb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgY29uc3QgSU5GID0gSW5maW5pdHk7XG5cbiAgLy8gU2V0IG9mIFVuaWNvZGUgRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBjaGFyYWN0ZXJzLCB0aGVzZSB3aWxsIG5vdCBwcm9kdWNlIHZpc2libGUgZ2x5cGhzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuICBjb25zdCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUyA9IC9bXFx1MDBBRFxcdTAzNEZcXHUwNjFDXFx1MTE1Ri1cXHUxMTYwXFx1MTdCNC1cXHUxN0I1XFx1MTgwQi1cXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MzE2NFxcdUZFMDAtXFx1RkUwRlxcdUZFRkZcXHVGRkEwXFx1RkZGMC1cXHVGRkY4XS87XG5cbiAgLy8gVGhpcyByZWdleCAoaW5zdGVhZCBvZiAvXFxzLykgYWxsb3dzIHVzIHRvIHNlbGVjdCBhbGwgd2hpdGVzcGFjZSBFWENFUFQgZm9yIG5vbi1icmVha2luZyB3aGl0ZSBzcGFjZXNcbiAgY29uc3QgbGluZUJyZWFraW5nV2hpdGVTcGFjZSA9IGBbXlxcXFxTXFxcXHUwMEEwXWA7XG5cbiAgLy8gSW5jb21wbGV0ZSBzZXQgb2YgY2hhcmFjdGVycyB0aGF0IGFsbG93IGxpbmUgYnJlYWtpbmcgYWZ0ZXIgdGhlbVxuICAvLyBJbiB0aGUgZnV0dXJlIHdlIG1heSBjb25zaWRlciBhIGZ1bGwgVW5pY29kZSBsaW5lIGJyZWFraW5nIGFsZ29yaXRobSBpbXBsOiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMTRcbiAgY29uc3QgQlJFQUtfQUZURVJfQ0hBUlMgPSBuZXcgUmVnRXhwKGAke2xpbmVCcmVha2luZ1doaXRlU3BhY2V9fFtcXFxcLVxcXFx1MDA3Q1xcXFx1MDBBRFxcXFx1MjAxMFxcXFx1MjAxMi1cXFxcdTIwMTRcXFxcdTIwMjdcXFxcdTIwNTZcXFxcdTJFMTdcXFxcdTJFNDBdYCk7XG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybFxuICAgKi9cbiAgZnVuY3Rpb24gZG9Mb2FkRm9udCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gdHJ5TG9hZCgpIHtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsdXJlIGxvYWRpbmcgZm9udCAke3VybH0ke3VybCA9PT0gZGVmYXVsdEZvbnRVUkwgPyAnJyA6ICc7IHRyeWluZyBmYWxsYmFjayd9YCwgZXJyKTtcbiAgICAgICAgaWYgKHVybCAhPT0gZGVmYXVsdEZvbnRVUkwpIHtcbiAgICAgICAgICB1cmwgPSBkZWZhdWx0Rm9udFVSTDtcbiAgICAgICAgICB0cnlMb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBmb250T2JqID0gZm9udFBhcnNlcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5TG9hZCgpO1xuICB9XG5cblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAqIGxvYWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgIGlmICghZm9udFVybCkgZm9udFVybCA9IGRlZmF1bHRGb250VVJMO1xuICAgIGxldCBmb250ID0gZm9udHNbZm9udFVybF07XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIC8vIGlmIGN1cnJlbnRseSBsb2FkaW5nIGZvbnQsIGFkZCB0byBjYWxsYmFja3MsIG90aGVyd2lzZSBleGVjdXRlIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoZm9udC5wZW5kaW5nKSB7XG4gICAgICAgIGZvbnQucGVuZGluZy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGZvbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb250c1tmb250VXJsXSA9IHtwZW5kaW5nOiBbY2FsbGJhY2tdfTtcbiAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgIGxldCBjYWxsYmFja3MgPSBmb250c1tmb250VXJsXS5wZW5kaW5nO1xuICAgICAgICBmb250c1tmb250VXJsXSA9IGZvbnRPYmo7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKGZvbnRPYmopKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAqIFByb2Nlc3MgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgYW5kIGZvcm1hdHRpbmcgcGFyYW1ldGVycywgYW5kIHJldHVybiBhbGwgaW5mb1xuICAgKiBuZWNlc3NhcnkgdG8gcmVuZGVyIGFsbCBpdHMgZ2x5cGhzLlxuICAgKi9cbiAgZnVuY3Rpb24gdHlwZXNldChcbiAgICB7XG4gICAgICB0ZXh0PScnLFxuICAgICAgZm9udD1kZWZhdWx0Rm9udFVSTCxcbiAgICAgIHNkZkdseXBoU2l6ZT02NCxcbiAgICAgIGZvbnRTaXplPTEsXG4gICAgICBsZXR0ZXJTcGFjaW5nPTAsXG4gICAgICBsaW5lSGVpZ2h0PSdub3JtYWwnLFxuICAgICAgbWF4V2lkdGg9SU5GLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGV4dEFsaWduPSdsZWZ0JyxcbiAgICAgIHRleHRJbmRlbnQ9MCxcbiAgICAgIHdoaXRlU3BhY2U9J25vcm1hbCcsXG4gICAgICBvdmVyZmxvd1dyYXA9J25vcm1hbCcsXG4gICAgICBhbmNob3JYID0gMCxcbiAgICAgIGFuY2hvclkgPSAwLFxuICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlLFxuICAgICAgY2h1bmtlZEJvdW5kc1NpemU9ODE5MixcbiAgICAgIGNvbG9yUmFuZ2VzPW51bGxcbiAgICB9LFxuICAgIGNhbGxiYWNrLFxuICAgIG1ldHJpY3NPbmx5PWZhbHNlXG4gICkge1xuICAgIGNvbnN0IG1haW5TdGFydCA9IG5vdygpO1xuICAgIGNvbnN0IHRpbWluZ3MgPSB7Zm9udExvYWQ6IDAsIHR5cGVzZXR0aW5nOiAwfTtcblxuICAgIC8vIEVuc3VyZSBuZXdsaW5lcyBhcmUgbm9ybWFsaXplZFxuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1xccicpID4gLTEpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnVHlwZXNldHRlcjogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICBmb250U2l6ZSA9ICtmb250U2l6ZTtcbiAgICBsZXR0ZXJTcGFjaW5nID0gK2xldHRlclNwYWNpbmc7XG4gICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgbGluZUhlaWdodCA9IGxpbmVIZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgdGV4dEluZGVudCA9ICt0ZXh0SW5kZW50O1xuXG4gICAgbG9hZEZvbnQoZm9udCwgZm9udE9iaiA9PiB7XG4gICAgICBjb25zdCBoYXNNYXhXaWR0aCA9IGlzRmluaXRlKG1heFdpZHRoKTtcbiAgICAgIGxldCBnbHlwaElkcyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoRGF0YSA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhDb2xvcnMgPSBudWxsO1xuICAgICAgbGV0IGNhcmV0UG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGxldCB2aXNpYmxlQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBjaHVua2VkQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgbGV0IHJlbmRlcmFibGVHbHlwaENvdW50ID0gMDtcbiAgICAgIGxldCBjYW5XcmFwID0gd2hpdGVTcGFjZSAhPT0gJ25vd3JhcCc7XG4gICAgICBjb25zdCB7YXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fSA9IGZvbnRPYmo7XG4gICAgICB0aW1pbmdzLmZvbnRMb2FkID0gbm93KCkgLSBtYWluU3RhcnQ7XG4gICAgICBjb25zdCB0eXBlc2V0U3RhcnQgPSBub3coKTtcblxuICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzOyB0aGlzIHdpbGwgYWxyZWFkeSBiZSBkb25lXG4gICAgICAvLyBmb3IgdGhlIGd4L2d5IHZhbHVlcyBiZWxvdyBidXQgZXZlcnl0aGluZyBlbHNlIHdlJ2xsIG5lZWQgdG8gY29udmVydFxuICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICdub3JtYWwnIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250J3MgYWN0dWFsIG1ldHJpY3NcbiAgICAgIC8vIFRPRE8gdGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgaW5kaXZpZHVhbCBnbHlwaHMgd29uJ3QgZXhjZWVkIHRoZSBsaW5lIGhlaWdodCwgZS5nLiBSb2JvdG87IHNob3VsZCB3ZSB1c2UgeU1pbi9NYXggaW5zdGVhZD9cbiAgICAgIGlmIChsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJykge1xuICAgICAgICBsaW5lSGVpZ2h0ID0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyICsgbGluZUdhcCkgLyB1bml0c1BlckVtO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgbGluZSBoZWlnaHQgYW5kIGxlYWRpbmcgYWRqdXN0bWVudHNcbiAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG4gICAgICBjb25zdCBoYWxmTGVhZGluZyA9IChsaW5lSGVpZ2h0IC0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCkgLyAyO1xuICAgICAgY29uc3QgdG9wQmFzZWxpbmUgPSAtKGFzY2VuZGVyICogZm9udFNpemVNdWx0ICsgaGFsZkxlYWRpbmcpO1xuICAgICAgY29uc3QgY2FyZXRIZWlnaHQgPSBNYXRoLm1pbihsaW5lSGVpZ2h0LCAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KTtcbiAgICAgIGNvbnN0IGNhcmV0Qm90dG9tT2Zmc2V0ID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgLSBjYXJldEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICBsZXQgY3VycmVudExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gW2N1cnJlbnRMaW5lXTtcblxuICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIChnbHlwaE9iaiwgZ2x5cGhYLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGNoYXJJbmRleCk7XG4gICAgICAgIGNvbnN0IGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIGNvbnN0IGN1ckxpbmVDb3VudCA9IGN1cnJlbnRMaW5lLmNvdW50O1xuICAgICAgICBsZXQgbmV4dExpbmU7XG5cbiAgICAgICAgLy8gQ2FsYyBpc1doaXRlc3BhY2UgYW5kIGlzRW1wdHkgb25jZSBwZXIgZ2x5cGhPYmpcbiAgICAgICAgaWYgKCEoJ2lzRW1wdHknIGluIGdseXBoT2JqKSkge1xuICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiBuZXcgUmVnRXhwKGxpbmVCcmVha2luZ1doaXRlU3BhY2UpLnRlc3QoY2hhcik7XG4gICAgICAgICAgZ2x5cGhPYmouY2FuQnJlYWtBZnRlciA9ICEhY2hhciAmJiBCUkVBS19BRlRFUl9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgIGdseXBoT2JqLmlzRW1wdHkgPSBnbHlwaE9iai54TWluID09PSBnbHlwaE9iai54TWF4IHx8IGdseXBoT2JqLnlNaW4gPT09IGdseXBoT2JqLnlNYXggfHwgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgIHJlbmRlcmFibGVHbHlwaENvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgaWYgKGNhbldyYXAgJiYgaGFzTWF4V2lkdGggJiYgIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBnbHlwaFggKyBnbHlwaFdpZHRoICsgbGluZVhPZmZzZXQgPiBtYXhXaWR0aCAmJiBjdXJMaW5lQ291bnQpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBjaGFyIGFmdGVyIGEgd2hpdGVzcGFjZSwgc3RhcnQgYSBuZXcgbGluZVxuICAgICAgICAgIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGN1ckxpbmVDb3VudCAtIDEpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJhY2sgdXAgbG9va2luZyBmb3IgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciB0byB3cmFwIGF0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3VyTGluZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBvdmVyZmxvd1dyYXAgPT09ICdicmVhay13b3JkJykge1xuICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRMaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouY2FuQnJlYWtBZnRlcikge1xuICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXh0TGluZS5jb3VudDsgai0tOykge1xuICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZS5pc1NvZnRXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IG1heFdpZHRoOyAvL2FmdGVyIHNvZnQgd3JhcHBpbmcgdXNlIG1heFdpZHRoIGFzIGNhbGN1bGF0ZWQgd2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmx5ID0gY3VycmVudExpbmUuZ2x5cGhBdChjdXJyZW50TGluZS5jb3VudCk7XG4gICAgICAgIGZseS5nbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICBmbHkud2lkdGggPSBnbHlwaFdpZHRoO1xuICAgICAgICBmbHkuY2hhckluZGV4ID0gY2hhckluZGV4O1xuXG4gICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgbGluZVhPZmZzZXQgPSAtKGdseXBoWCArIGdseXBoV2lkdGggKyAobGV0dGVyU3BhY2luZyAqIGZvbnRTaXplKSkgKyB0ZXh0SW5kZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gbGluZS5jb3VudDsgaS0tOykge1xuICAgICAgICAgIGxldCB7Z2x5cGhPYmosIHgsIHdpZHRofSA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaW5kIG92ZXJhbGwgcG9zaXRpb24gYWRqdXN0bWVudHMgZm9yIGFuY2hvcmluZ1xuICAgICAgbGV0IGFuY2hvclhPZmZzZXQgPSAwO1xuICAgICAgbGV0IGFuY2hvcllPZmZzZXQgPSAwO1xuICAgICAgaWYgKGFuY2hvclgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtYW5jaG9yWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLW1heExpbmVXaWR0aCAqIChcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2NlbnRlcicgPyAwLjUgOlxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ3JpZ2h0JyA/IDEgOlxuICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFuY2hvclkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSAtYW5jaG9yWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZXQgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gYW5jaG9yWSA9PT0gJ3RvcCcgPyAwIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtYmFzZWxpbmUnID8gLXRvcEJhc2VsaW5lIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtY2FwJyA/IC10b3BCYXNlbGluZSAtIGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWV4JyA/IC10b3BCYXNlbGluZSAtIHhIZWlnaHQgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ21pZGRsZScgPyBoZWlnaHQgLyAyIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20nID8gaGVpZ2h0IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20tYmFzZWxpbmUnID8gaGVpZ2h0IC0gaGFsZkxlYWRpbmcgKyBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclkpICogaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBiaWRpIGxldmVsc1xuICAgICAgICBjb25zdCBiaWRpTGV2ZWxzUmVzdWx0ID0gYmlkaS5nZXRFbWJlZGRpbmdMZXZlbHModGV4dCwgZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgIC8vIGNvbGxlY3RpbmcgYWxsIHJlbmRlcmFibGUgZ2x5cGhzIGludG8gYSBzaW5nbGUgY29sbGVjdGlvbi5cbiAgICAgICAgZ2x5cGhJZHMgPSBuZXcgVWludDE2QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgZ2x5cGhEYXRhID0ge307XG4gICAgICAgIHZpc2libGVCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgIGxldCBsaW5lWU9mZnNldCA9IHRvcEJhc2VsaW5lO1xuICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgZ2x5cGhDb2xvcnMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhJbmRleCA9IDA7XG4gICAgICAgIGxldCBwcmV2Q2hhckluZGV4ID0gLTE7XG4gICAgICAgIGxldCBjb2xvckNoYXJJbmRleCA9IC0xO1xuICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgIGxldCBjdXJyZW50Q29sb3I7XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGxldCB7Y291bnQ6bGluZUdseXBoQ291bnQsIHdpZHRoOmxpbmVXaWR0aH0gPSBsaW5lO1xuXG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgaWYgKGxpbmVHbHlwaENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQ291bnQgdHJhaWxpbmcgd2hpdGVzcGFjZXMsIHdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGZvciBjZXJ0YWluIHRoaW5nc1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsaW5lR2x5cGhDb3VudDsgaS0tICYmIGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2U7KSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGhvcml6b250YWwgYWxpZ25tZW50IGFkanVzdG1lbnRzXG4gICAgICAgICAgICBsZXQgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGp1c3RpZnlBZGp1c3QgPSAwO1xuICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGNvdW50IG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIGFuZCB3ZSdsbCBhZGp1c3QgdGhlIG9mZnNldHMgcGVyIGNoYXJhY3RlciBpbiB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgIGxldCB3aGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAganVzdGlmeUFkanVzdCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gd2hpdGVzcGFjZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgfHwgbGluZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgbGV0IGp1c3RpZnlPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICAgIGdseXBoSW5mby54ICs9IGxpbmVYT2Zmc2V0ICsganVzdGlmeU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2VzIGZvciBqdXN0aWZ5IGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5QWRqdXN0ICE9PSAwICYmIGdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBpIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAganVzdGlmeU9mZnNldCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLndpZHRoICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYmlkaSByYW5nZSBmbGlwcGluZ1xuICAgICAgICAgICAgY29uc3QgZmxpcHMgPSBiaWRpLmdldFJlb3JkZXJTZWdtZW50cyhcbiAgICAgICAgICAgICAgdGV4dCwgYmlkaUxldmVsc1Jlc3VsdCwgbGluZS5nbHlwaEF0KDApLmNoYXJJbmRleCwgbGluZS5nbHlwaEF0KGxpbmUuY291bnQgLSAxKS5jaGFySW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKGxldCBmaSA9IDA7IGZpIDwgZmxpcHMubGVuZ3RoOyBmaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZsaXBzW2ZpXTtcbiAgICAgICAgICAgICAgLy8gTWFwIHN0YXJ0L2VuZCBzdHJpbmcgaW5kaWNlcyB0byBpbmRpY2VzIGluIHRoZSBsaW5lXG4gICAgICAgICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5nbHlwaEF0KGkpLmNoYXJJbmRleCA+PSBzdGFydCkgeyAvLyBndGUgdG8gaGFuZGxlIHJlbW92ZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5MaW5lID0gaSwgZW5kSW5MaW5lID0gaTtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudDsgZW5kSW5MaW5lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm8gPSBsaW5lLmdseXBoQXQoZW5kSW5MaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uY2hhckluZGV4ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkgeyAvL2Rvbid0IGluY2x1ZGUgdHJhaWxpbmcgd3MgaW4gZmxpcCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBpbmZvLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGluZm8ueCArIGluZm8ud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnRJbkxpbmU7IGogPCBlbmRJbkxpbmU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ID0gcmlnaHQgLSAoZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYXJyYXlzXG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmo7XG4gICAgICAgICAgICBjb25zdCBzZXRHbHlwaE9iaiA9IGcgPT4gZ2x5cGhPYmogPSBnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhPYmouaW5kZXg7XG5cbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSBtaXJyb3JlZCBjaGFyYWN0ZXJzIGluIHJ0bFxuICAgICAgICAgICAgICBjb25zdCBydGwgPSBiaWRpTGV2ZWxzUmVzdWx0LmxldmVsc1tnbHlwaEluZm8uY2hhckluZGV4XSAmIDE7IC8vb2RkIGxldmVsIG1lYW5zIHJ0bFxuICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlycm9yZWQgPSBiaWRpLmdldE1pcnJvcmVkQ2hhcmFjdGVyKHRleHRbZ2x5cGhJbmZvLmNoYXJJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChtaXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgobWlycm9yZWQsIDAsIDAsIHNldEdseXBoT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4fSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRSaWdodCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiAzXSA9IHJ0bCA/IGNhcmV0UmlnaHQgOiBjYXJldExlZnQ7IC8vc3RhcnQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDJdID0gbGluZVlPZmZzZXQgKyBjYXJldEJvdHRvbU9mZnNldCArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIGJvdHRvbSB5XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBza2lwcGVkIGFueSBjaGFycyBmcm9tIHRoZSBwcmV2aW91cyBnbHlwaCAoZHVlIHRvIGxpZ2F0dXJlIHN1YnMpLCBmaWxsIGluIGNhcmV0XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGZvciB0aG9zZSBtaXNzaW5nIGNoYXIgaW5kaWNlczsgY3VycmVudGx5IHRoaXMgdXNlcyBhIGJlc3QtZ3Vlc3MgYnkgZGl2aWRpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGlnYXR1cmUncyB3aWR0aCBldmVubHkuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHRyeSB0byB1c2UgdGhlIGZvbnQncyBMaWdhdHVyZUNhcmV0TGlzdFxuICAgICAgICAgICAgICAgIC8vIHRhYmxlIHRvIGdldCBiZXR0ZXIgaW50ZXJpb3IgY2FyZXQgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gY2hhckluZGV4IC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgcHJldkNoYXJJbmRleCwgbGlnQ291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2Q2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4fSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICB3aGlsZShjaGFySW5kZXggPiBjb2xvckNoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgY29sb3JDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShjb2xvckNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JSYW5nZXNbY29sb3JDaGFySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCBhdGxhcyBkYXRhIGZvciByZW5kZXJhYmxlIGdseXBoc1xuICAgICAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHJlbmRlcmFibGVHbHlwaEluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBnbHlwaCdzIHBhdGggZGF0YVxuICAgICAgICAgICAgICAgIGlmICghZ2x5cGhEYXRhW2dseXBoSWRdKSB7XG4gICAgICAgICAgICAgICAgICBnbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGdseXBoT2JqLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhCb3VuZHM6IFtnbHlwaE9iai54TWluLCBnbHlwaE9iai55TWluLCBnbHlwaE9iai54TWF4LCBnbHlwaE9iai55TWF4XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZmluYWwgZ2x5cGggcG9zaXRpb24gYW5kIGFkZCB0byBnbHlwaFBvc2l0aW9ucyBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFkgPSBsaW5lWU9mZnNldCArIGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMl0gPSBnbHlwaFg7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMiArIDFdID0gZ2x5cGhZO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgdG90YWwgdmlzaWJsZSBib3VuZHNcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMCA9IGdseXBoWCArIGdseXBoT2JqLnhNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTAgPSBnbHlwaFkgKyBnbHlwaE9iai55TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gxID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNZMSA9IGdseXBoWSArIGdseXBoT2JqLnlNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgdmlzaWJsZUJvdW5kc1swXSkgdmlzaWJsZUJvdW5kc1swXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IHZpc2libGVCb3VuZHNbMV0pIHZpc2libGVCb3VuZHNbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiB2aXNpYmxlQm91bmRzWzJdKSB2aXNpYmxlQm91bmRzWzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gdmlzaWJsZUJvdW5kc1szXSkgdmlzaWJsZUJvdW5kc1szXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY2h1bmsgb2YgTiBnbHlwaHNcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICUgY2h1bmtlZEJvdW5kc1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNodW5rID0ge3N0YXJ0OiBpZHgsIGVuZDogaWR4LCByZWN0OiBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdfTtcbiAgICAgICAgICAgICAgICAgIGNodW5rZWRCb3VuZHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rLmVuZCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUmVjdCA9IGNodW5rLnJlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgY2h1bmtSZWN0WzBdKSBjaHVua1JlY3RbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCBjaHVua1JlY3RbMV0pIGNodW5rUmVjdFsxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IGNodW5rUmVjdFsyXSkgY2h1bmtSZWN0WzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gY2h1bmtSZWN0WzNdKSBjaHVua1JlY3RbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBnbHlwaCBpZHMgYXJyYXlcbiAgICAgICAgICAgICAgICBnbHlwaElkc1tpZHhdID0gZ2x5cGhJZDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaWR4ICogMztcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0XSA9IGN1cnJlbnRDb2xvciA+PiAxNiAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMV0gPSBjdXJyZW50Q29sb3IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMl0gPSBjdXJyZW50Q29sb3IgJiAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW5jcmVtZW50IHkgb2Zmc2V0IGZvciBuZXh0IGxpbmVcbiAgICAgICAgICBsaW5lWU9mZnNldCAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWxsIGluIHJlbWFpbmluZyBjYXJldCBwb3NpdGlvbnMgaW4gY2FzZSB0aGUgZmluYWwgY2hhcmFjdGVyIHdhcyBhIGxpZ2F0dXJlXG4gICAgICAgIGlmIChjYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gdGV4dC5sZW5ndGggLSBwcmV2Q2hhckluZGV4O1xuICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRpbWluZyBzdGF0c1xuICAgICAgdGltaW5ncy50eXBlc2V0dGluZyA9IG5vdygpIC0gdHlwZXNldFN0YXJ0O1xuXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGdseXBoSWRzLCAvL2ZvbnQgaW5kaWNlcyBmb3IgZWFjaCBnbHlwaFxuICAgICAgICBnbHlwaFBvc2l0aW9ucywgLy94LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICAgICAgZ2x5cGhEYXRhLCAvL2RpY3QgaG9sZGluZyBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gICAgICAgIGNhcmV0UG9zaXRpb25zLCAvL3N0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAgICAgICAgY2FyZXRIZWlnaHQsIC8vaGVpZ2h0IG9mIGN1cnNvciBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAgICAgZ2x5cGhDb2xvcnMsIC8vY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICAgICAgICBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gICAgICAgIHVuaXRzUGVyRW0sIC8vZm9udCB1bml0cyBwZXIgZW1cbiAgICAgICAgYXNjZW5kZXI6IGFzY2VuZGVyICogZm9udFNpemVNdWx0LCAvL2ZvbnQgYXNjZW5kZXJcbiAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsIC8vZm9udCBkZXNjZW5kZXJcbiAgICAgICAgY2FwSGVpZ2h0OiBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vZm9udCBjYXAtaGVpZ2h0XG4gICAgICAgIHhIZWlnaHQ6IHhIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vZm9udCB4LWhlaWdodFxuICAgICAgICBsaW5lSGVpZ2h0LCAvL2NvbXB1dGVkIGxpbmUgaGVpZ2h0XG4gICAgICAgIHRvcEJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodCxcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ICsgbWF4TGluZVdpZHRoLFxuICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAgICAgICAgXSxcbiAgICAgICAgdmlzaWJsZUJvdW5kcywgLy90b3RhbCBib3VuZHMgb2YgdmlzaWJsZSB0ZXh0IHBhdGhzLCBtYXkgYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiBibG9ja0JvdW5kc1xuICAgICAgICB0aW1pbmdzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHRleHQgc3RyaW5nIGFuZCBmb250IHBhcmFtZXRlcnMsIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIGJsb2NrIGRpbWVuc2lvbnNcbiAgICogYWZ0ZXIgd3JhcHBpbmcgZm9yIHRoZSBnaXZlbiBtYXhXaWR0aC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgdHlwZXNldChhcmdzLCAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gcmVzdWx0LmJsb2NrQm91bmRzO1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgaGVpZ2h0OiB5MSAtIHkwXG4gICAgICB9KTtcbiAgICB9LCB7bWV0cmljc09ubHk6IHRydWV9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyY2VudChzdHIpIHtcbiAgICBsZXQgbWF0Y2ggPSBzdHIubWF0Y2goL14oW1xcZC5dKyklJC8pO1xuICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgIHJldHVybiBpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMFxuICB9XG5cbiAgZnVuY3Rpb24gZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIGxpZ1N0YXJ0SW5kZXgsIGxpZ0NvdW50KSB7XG4gICAgY29uc3QgbGlnU3RhcnRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDNdO1xuICAgIGNvbnN0IGxpZ0VuZFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogMyArIDFdO1xuICAgIGNvbnN0IGxpZ1kgPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogMyArIDJdO1xuICAgIGNvbnN0IGd1ZXNzZWRBZHZhbmNlWCA9IChsaWdFbmRYIC0gbGlnU3RhcnRYKSAvIGxpZ0NvdW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChsaWdTdGFydEluZGV4ICsgaSkgKiAzO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleF0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiBpO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDFdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogKGkgKyAxKTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAyXSA9IGxpZ1k7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxuICB9XG5cbiAgLy8gQXJyYXktYmFja2VkIHN0cnVjdHVyZSBmb3IgYSBzaW5nbGUgbGluZSdzIGdseXBocyBkYXRhXG4gIGZ1bmN0aW9uIFRleHRMaW5lKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIGNvbnN0IHRleHRMaW5lUHJvcHMgPSBbJ2dseXBoT2JqJywgJ3gnLCAnd2lkdGgnLCAnY2hhckluZGV4J107XG4gIFRleHRMaW5lLnByb3RvdHlwZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBpc1NvZnRXcmFwcGVkOiBmYWxzZSxcbiAgICBnZXQgY291bnQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICB9LFxuICAgIGdseXBoQXQoaSkge1xuICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgIGZseS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgZmx5LmluZGV4ID0gaTtcbiAgICAgIHJldHVybiBmbHlcbiAgICB9LFxuICAgIHNwbGl0QXQoaSkge1xuICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIG5ld0xpbmUuZGF0YSA9IHRoaXMuZGF0YS5zcGxpY2UoaSAqIHRleHRMaW5lUHJvcHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdMaW5lXG4gICAgfVxuICB9O1xuICBUZXh0TGluZS5mbHl3ZWlnaHQgPSB0ZXh0TGluZVByb3BzLnJlZHVjZSgob2JqLCBwcm9wLCBpLCBhbGwpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqXG4gIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlc2V0LFxuICAgIG1lYXN1cmUsXG4gICAgbG9hZEZvbnRcbiAgfVxufVxuXG5jb25zdCBub3cgPSAoKSA9PiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKTtcblxuY29uc3QgbWFpblRocmVhZEdlbmVyYXRvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU0RGR2VuZXJhdG9yKCk7XG5cbmxldCB3YXJuZWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgc2luZ2xlIGdseXBoIHBhdGgsIHBsYWNpbmcgdGhlIHJlc3VsdCBpbnRvIGEgd2ViZ2wgY2FudmFzIGF0IGFcbiAqIGdpdmVuIGxvY2F0aW9uIGFuZCBjaGFubmVsLiBVdGlsaXplcyB0aGUgd2ViZ2wtc2RmLWdlbmVyYXRvciBleHRlcm5hbCBwYWNrYWdlIGZvciBHUFUtYWNjZWxlcmF0ZWQgU0RGXG4gKiBnZW5lcmF0aW9uIHdoZW4gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCwgdXNlV2ViR0wgPSB0cnVlKSB7XG4gIC8vIEFsbG93IG9wdC1vdXRcbiAgaWYgKCF1c2VXZWJHTCkge1xuICAgIHJldHVybiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpXG4gIH1cblxuICAvLyBBdHRlbXB0IEdQVS1hY2NlbGVyYXRlZCBnZW5lcmF0aW9uIGZpcnN0XG4gIHJldHVybiBnZW5lcmF0ZVNERl9HTCh3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkudGhlbihcbiAgICBudWxsLFxuICAgIGVyciA9PiB7XG4gICAgICAvLyBXZWJHTCBmYWlsZWQgZWl0aGVyIGR1ZSB0byBhIGhhcmQgZXJyb3Igb3IgdW5leHBlY3RlZCByZXN1bHRzOyBmYWxsIGJhY2sgdG8gSlMgaW4gd29ya2Vyc1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKU2AsIGVycik7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgIH1cbiAgKVxufVxuXG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgY2h1bmtUaW1lQnVkZ2V0ID0gNTsgLy8gbXNcbmxldCB0aW1lciA9IDA7XG5cbmZ1bmN0aW9uIG5leHRDaHVuaygpIHtcbiAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiBub3coKSAtIHN0YXJ0IDwgY2h1bmtUaW1lQnVkZ2V0KSB7XG4gICAgcXVldWUuc2hpZnQoKSgpO1xuICB9XG4gIHRpbWVyID0gcXVldWUubGVuZ3RoID8gc2V0VGltZW91dChuZXh0Q2h1bmssIDApIDogMDtcbn1cblxuLyoqXG4gKiBXZWJHTC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBleGVjdXRlZCBvbiB0aGUgbWFpbiB0aHJlYWQuIFJlcXVlc3RzIGFyZSBleGVjdXRlZCBpbiB0aW1lLWJvdW5kZWRcbiAqIG1hY3JvdGFzayBjaHVua3MgdG8gYWxsb3cgcmVuZGVyIGZyYW1lcyB0byBleGVjdXRlIGluIGJldHdlZW4uXG4gKi9cbmNvbnN0IGdlbmVyYXRlU0RGX0dMID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmdlbmVyYXRlSW50b0NhbnZhcyguLi5hcmdzKTtcbiAgICAgICAgcmVzb2x2ZSh7IHRpbWluZzogbm93KCkgLSBzdGFydCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQobmV4dENodW5rLCAwKTtcbiAgICB9XG4gIH0pXG59O1xuXG5jb25zdCB0aHJlYWRDb3VudCA9IDQ7IC8vIGhvdyBtYW55IHdvcmtlcnMgdG8gc3Bhd25cbmNvbnN0IGlkbGVUaW1lb3V0ID0gMjAwMDsgLy8gd29ya2VycyB3aWxsIGJlIHRlcm1pbmF0ZWQgYWZ0ZXIgYmVpbmcgaWRsZSB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG5jb25zdCB0aHJlYWRzID0ge307XG5sZXQgY2FsbE51bSA9IDA7XG5cbi8qKlxuICogRmFsbGJhY2sgSlMtYmFzZWQgaW1wbGVtZW50YXRpb24sIGZhbm5lZCBvdXQgdG8gYSBudW1iZXIgb2Ygd29ya2VyIHRocmVhZHMgZm9yIHBhcmFsbGVsaXNtXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICBjb25zdCB3b3JrZXJJZCA9ICdUcm9pa2FUZXh0U0RGR2VuZXJhdG9yX0pTXycgKyAoKGNhbGxOdW0rKykgJSB0aHJlYWRDb3VudCk7XG4gIGxldCB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXTtcbiAgaWYgKCF0aHJlYWQpIHtcbiAgICB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXSA9IHtcbiAgICAgIHdvcmtlck1vZHVsZTogZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICAgICAgbmFtZTogd29ya2VySWQsXG4gICAgICAgIHdvcmtlcklkLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgICAgICBjcmVhdGVTREZHZW5lcmF0b3IsXG4gICAgICAgICAgbm93XG4gICAgICAgIF0sXG4gICAgICAgIGluaXQoX2NyZWF0ZVNERkdlbmVyYXRvciwgbm93KSB7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGUgPSBfY3JlYXRlU0RGR2VuZXJhdG9yKCkuamF2YXNjcmlwdC5nZW5lcmF0ZTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlRGF0YSA9IGdlbmVyYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGV4dHVyZURhdGEsXG4gICAgICAgICAgICAgIHRpbWluZzogbm93KCkgLSBzdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdC50ZXh0dXJlRGF0YS5idWZmZXJdXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICBpZGxlVGltZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdGhyZWFkLnJlcXVlc3RzKys7XG4gIGNsZWFyVGltZW91dCh0aHJlYWQuaWRsZVRpbWVyKTtcbiAgcmV0dXJuIHRocmVhZC53b3JrZXJNb2R1bGUod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50KVxuICAgIC50aGVuKCh7IHRleHR1cmVEYXRhLCB0aW1pbmcgfSkgPT4ge1xuICAgICAgLy8gY29weSByZXN1bHQgZGF0YSBpbnRvIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAvLyBleHBhbmQgc2luZ2xlLWNoYW5uZWwgZGF0YSBpbnRvIHJnYmFcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVEYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWFnZURhdGFbaSAqIDQgKyBjaGFubmVsXSA9IHRleHR1cmVEYXRhW2ldO1xuICAgICAgfVxuICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlbmRlckltYWdlRGF0YShjYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpKTtcbiAgICAgIHRpbWluZyArPSBub3coKSAtIHN0YXJ0O1xuXG4gICAgICAvLyBjbGVhbiB1cCB3b3JrZXJzIGFmdGVyIGEgd2hpbGVcbiAgICAgIGlmICgtLXRocmVhZC5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICB0aHJlYWQuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IHRlcm1pbmF0ZVdvcmtlcih3b3JrZXJJZCk7IH0sIGlkbGVUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRpbWluZyB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gd2FybVVwU0RGQ2FudmFzKGNhbnZhcykge1xuICBpZiAoIWNhbnZhcy5fd2FybSkge1xuICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2wuaXNTdXBwb3J0ZWQoY2FudmFzKTtcbiAgICBjYW52YXMuX3dhcm0gPSB0cnVlO1xuICB9XG59XG5cbmNvbnN0IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nID0gbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nO1xuXG4vKiFcbkN1c3RvbSBidWlsZCBvZiBUeXByLnRzIChodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cykgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuXG5PcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuZnVuY3Rpb24gdHlwckZhY3RvcnkoKXtyZXR1cm4gXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmKHNlbGYud2luZG93PXNlbGYpLGZ1bmN0aW9uKHIpe3ZhciBlPXtwYXJzZTpmdW5jdGlvbihyKXt2YXIgdD1lLl9iaW4sYT1uZXcgVWludDhBcnJheShyKTtpZihcInR0Y2ZcIj09dC5yZWFkQVNDSUkoYSwwLDQpKXt2YXIgbj00O3QucmVhZFVzaG9ydChhLG4pLG4rPTIsdC5yZWFkVXNob3J0KGEsbiksbis9Mjt2YXIgbz10LnJlYWRVaW50KGEsbik7bis9NDtmb3IodmFyIHM9W10saT0wO2k8bztpKyspe3ZhciBoPXQucmVhZFVpbnQoYSxuKTtuKz00LHMucHVzaChlLl9yZWFkRm9udChhLGgpKTt9cmV0dXJuIHN9cmV0dXJuIFtlLl9yZWFkRm9udChhLDApXX0sX3JlYWRGb250OmZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dDthLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIHM9W1wiY21hcFwiLFwiaGVhZFwiLFwiaGhlYVwiLFwibWF4cFwiLFwiaG10eFwiLFwibmFtZVwiLFwiT1MvMlwiLFwicG9zdFwiLFwibG9jYVwiLFwiZ2x5ZlwiLFwia2VyblwiLFwiQ0ZGIFwiLFwiR1BPU1wiLFwiR1NVQlwiLFwiU1ZHIFwiXSxpPXtfZGF0YTpyLF9vZmZzZXQ6bn0saD17fSxmPTA7ZjxvO2YrKyl7dmFyIGQ9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIHU9YS5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9YS5yZWFkVWludChyLHQpO3QrPTQsaFtkXT17b2Zmc2V0OnUsbGVuZ3RoOmx9O31mb3IoZj0wO2Y8cy5sZW5ndGg7ZisrKXt2YXIgdj1zW2ZdO2hbdl0mJihpW3YudHJpbSgpXT1lW3YudHJpbSgpXS5wYXJzZShyLGhbdl0ub2Zmc2V0LGhbdl0ubGVuZ3RoLGkpKTt9cmV0dXJuIGl9LF90YWJPZmZzZXQ6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocixhKzQpLHM9YSsxMixpPTA7aTxvO2krKyl7dmFyIGg9bi5yZWFkQVNDSUkocixzLDQpO3MrPTQsbi5yZWFkVWludChyLHMpLHMrPTQ7dmFyIGY9bi5yZWFkVWludChyLHMpO2lmKHMrPTQsbi5yZWFkVWludChyLHMpLHMrPTQsaD09dClyZXR1cm4gZn1yZXR1cm4gMH19O2UuX2Jpbj17cmVhZEZpeGVkOmZ1bmN0aW9uKHIsZSl7cmV0dXJuIChyW2VdPDw4fHJbZSsxXSkrKHJbZSsyXTw8OHxyW2UrM10pLzY1NTQwfSxyZWFkRjJkb3QxNDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4ucmVhZFNob3J0KHIsdCkvMTYzODR9LHJlYWRJbnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDMyKHQpfSxyZWFkSW50ODpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50OCh0KX0scmVhZFNob3J0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQxNih0KX0scmVhZFVzaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDE2KHQpfSxyZWFkVXNob3J0czpmdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGE7bysrKW4ucHVzaChlLl9iaW4ucmVhZFVzaG9ydChyLHQrMipvKSk7cmV0dXJuIG59LHJlYWRVaW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRVaW50MzIodCl9LHJlYWRVaW50NjQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gNDI5NDk2NzI5NiplLl9iaW4ucmVhZFVpbnQocix0KStlLl9iaW4ucmVhZFVpbnQocix0KzQpfSxyZWFkQVNDSUk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKTtyZXR1cm4gYX0scmVhZFVuaWNvZGU6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKXt2YXIgbz1yW2UrK108PDh8cltlKytdO2ErPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7fXJldHVybiBhfSxfdGRlYzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuVGV4dERlY29kZXI/bmV3IHdpbmRvdy5UZXh0RGVjb2RlcjpudWxsLHJlYWRVVEY4OmZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4uX3RkZWM7cmV0dXJuIG4mJjA9PXQmJmE9PXIubGVuZ3RoP24uZGVjb2RlKHIpOmUuX2Jpbi5yZWFkQVNDSUkocix0LGEpfSxyZWFkQnl0ZXM6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2gocltlK25dKTtyZXR1cm4gYX0scmVhZEFTQ0lJQXJyYXk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyW2Urbl0pKTtyZXR1cm4gYX0sX3ZpZXc6ZnVuY3Rpb24ocil7cmV0dXJuIHIuX2RhdGFWaWV3fHwoci5fZGF0YVZpZXc9ci5idWZmZXI/bmV3IERhdGFWaWV3KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpOm5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheShyKS5idWZmZXIpKX19LGUuX2xjdGY9e30sZS5fbGN0Zi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuLG8pe3ZhciBzPWUuX2JpbixpPXt9LGg9dDtzLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIGY9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1zLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PXMucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLGkuc2NyaXB0TGlzdD1lLl9sY3RmLnJlYWRTY3JpcHRMaXN0KHIsaCtmKSxpLmZlYXR1cmVMaXN0PWUuX2xjdGYucmVhZEZlYXR1cmVMaXN0KHIsaCtkKSxpLmxvb2t1cExpc3Q9ZS5fbGN0Zi5yZWFkTG9va3VwTGlzdChyLGgrdSxvKSxpfSxlLl9sY3RmLnJlYWRMb29rdXBMaXN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9W10saT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9ZS5fbGN0Zi5yZWFkTG9va3VwVGFibGUocixvK2YsYSk7cy5wdXNoKGQpO31yZXR1cm4gc30sZS5fbGN0Zi5yZWFkTG9va3VwVGFibGU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXQscz17dGFiczpbXX07cy5sdHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLHMuZmxhZz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXMubHR5cGUsZj0wO2Y8aTtmKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9YShyLGgsbytkLHMpO3MudGFicy5wdXNoKHUpO31yZXR1cm4gc30sZS5fbGN0Zi5udW1PZk9uZXM9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPTAsdD0wO3Q8MzI7dCsrKTAhPShyPj4+dCYxKSYmZSsrO3JldHVybiBlfSxlLl9sY3RmLnJlYWRDbGFzc0RlZj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89YS5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1vKXt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyluLnB1c2gocytoKSxuLnB1c2gocytoKSxuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7fWlmKDI9PW8pe3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGg9MDtoPGY7aCsrKW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MixuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31yZXR1cm4gbn0sZS5fbGN0Zi5nZXRJbnRlcnZhbD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9Myl7dmFyIGE9clt0XSxuPXJbdCsxXTtpZihyW3QrMl0sYTw9ZSYmZTw9bilyZXR1cm4gdH1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZENvdmVyYWdlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MiwxPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LG8pKSwyPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LDMqbykpLG59LGUuX2xjdGYuY292ZXJhZ2VJbmRleD1mdW5jdGlvbihyLHQpe3ZhciBhPXIudGFiO2lmKDE9PXIuZm10KXJldHVybiBhLmluZGV4T2YodCk7aWYoMj09ci5mbXQpe3ZhciBuPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoYSx0KTtpZigtMSE9bilyZXR1cm4gYVtuKzJdKyh0LWFbbl0pfXJldHVybiAtMX0sZS5fbGN0Zi5yZWFkRmVhdHVyZUxpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9ZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlKHIsbitmKTtkLnRhZz1oLnRyaW0oKSxvLnB1c2goZCk7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRGZWF0dXJlVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZmVhdHVyZVBhcmFtcz1uK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby50YWI9W107Zm9yKHZhciBoPTA7aDxpO2grKylvLnRhYi5wdXNoKGEucmVhZFVzaG9ydChyLHQrMipoKSk7cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdExpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1toLnRyaW0oKV09ZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGUocixuK2YpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8uZGVmYXVsdD1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyl7dmFyIGY9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQ7dmFyIGQ9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvW2YudHJpbSgpXT1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK2QpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307YS5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlcUZlYXR1cmU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLmZlYXR1cmVzPWEucmVhZFVzaG9ydHMocix0LG8pLG59LGUuQ0ZGPXt9LGUuQ0ZGLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47KHI9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSlbdD0wXSxyWysrdF0sclsrK3RdLHJbKyt0XSx0Kys7dmFyIG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO2Zvcih2YXIgcz1bXSxpPTA7aTxvLmxlbmd0aC0xO2krKylzLnB1c2gobi5yZWFkQVNDSUkocix0K29baV0sb1tpKzFdLW9baV0pKTt0Kz1vW28ubGVuZ3RoLTFdO3ZhciBoPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxoKTt2YXIgZj1bXTtmb3IoaT0wO2k8aC5sZW5ndGgtMTtpKyspZi5wdXNoKGUuQ0ZGLnJlYWREaWN0KHIsdCtoW2ldLHQraFtpKzFdKSk7dCs9aFtoLmxlbmd0aC0xXTt2YXIgZD1mWzBdLHU9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciBsPVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKylsLnB1c2gobi5yZWFkQVNDSUkocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtpZih0Kz11W3UubGVuZ3RoLTFdLGUuQ0ZGLnJlYWRTdWJycyhyLHQsZCksZC5DaGFyU3RyaW5ncyl7dD1kLkNoYXJTdHJpbmdzO3U9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciB2PVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKyl2LnB1c2gobi5yZWFkQnl0ZXMocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtkLkNoYXJTdHJpbmdzPXY7fWlmKGQuUk9TKXt0PWQuRkRBcnJheTt2YXIgYz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsYyksZC5GREFycmF5PVtdO2ZvcihpPTA7aTxjLmxlbmd0aC0xO2krKyl7dmFyIHA9ZS5DRkYucmVhZERpY3Qocix0K2NbaV0sdCtjW2krMV0pO2UuQ0ZGLl9yZWFkRkRpY3QocixwLGwpLGQuRkRBcnJheS5wdXNoKHApO310Kz1jW2MubGVuZ3RoLTFdLHQ9ZC5GRFNlbGVjdCxkLkZEU2VsZWN0PVtdO3ZhciBVPXJbdF07aWYodCsrLDMhPVUpdGhyb3cgVTt2YXIgZz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihpPTA7aTxnKzE7aSsrKWQuRkRTZWxlY3QucHVzaChuLnJlYWRVc2hvcnQocix0KSxyW3QrMl0pLHQrPTM7fXJldHVybiBkLkVuY29kaW5nJiYoZC5FbmNvZGluZz1lLkNGRi5yZWFkRW5jb2RpbmcocixkLkVuY29kaW5nLGQuQ2hhclN0cmluZ3MubGVuZ3RoKSksZC5jaGFyc2V0JiYoZC5jaGFyc2V0PWUuQ0ZGLnJlYWRDaGFyc2V0KHIsZC5jaGFyc2V0LGQuQ2hhclN0cmluZ3MubGVuZ3RoKSksZS5DRkYuX3JlYWRGRGljdChyLGQsbCksZH0sZS5DRkYuX3JlYWRGRGljdD1mdW5jdGlvbihyLHQsYSl7dmFyIG47Zm9yKHZhciBvIGluIHQuUHJpdmF0ZSYmKG49dC5Qcml2YXRlWzFdLHQuUHJpdmF0ZT1lLkNGRi5yZWFkRGljdChyLG4sbit0LlByaXZhdGVbMF0pLHQuUHJpdmF0ZS5TdWJycyYmZS5DRkYucmVhZFN1YnJzKHIsbit0LlByaXZhdGUuU3VicnMsdC5Qcml2YXRlKSksdCktMSE9W1wiRmFtaWx5TmFtZVwiLFwiRm9udE5hbWVcIixcIkZ1bGxOYW1lXCIsXCJOb3RpY2VcIixcInZlcnNpb25cIixcIkNvcHlyaWdodFwiXS5pbmRleE9mKG8pJiYodFtvXT1hW3Rbb10tNDI2KzM1XSk7fSxlLkNGRi5yZWFkU3VicnM9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTt2YXIgcyxpPW8ubGVuZ3RoO3M9aTwxMjQwPzEwNzppPDMzOTAwPzExMzE6MzI3NjgsYS5CaWFzPXMsYS5TdWJycz1bXTtmb3IodmFyIGg9MDtoPG8ubGVuZ3RoLTE7aCsrKWEuU3VicnMucHVzaChuLnJlYWRCeXRlcyhyLHQrb1toXSxvW2grMV0tb1toXSkpO30sZS5DRkYudGFibGVTRT1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwwLDExMSwxMTIsMTEzLDExNCwwLDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMCwxMjMsMCwxMjQsMTI1LDEyNiwxMjcsMTI4LDEyOSwxMzAsMTMxLDAsMTMyLDEzMywwLDEzNCwxMzUsMTM2LDEzNywwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEzOCwwLDEzOSwwLDAsMCwwLDE0MCwxNDEsMTQyLDE0MywwLDAsMCwwLDAsMTQ0LDAsMCwwLDE0NSwwLDAsMTQ2LDE0NywxNDgsMTQ5LDAsMCwwLDBdLGUuQ0ZGLmdseXBoQnlVbmljb2RlPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmNoYXJzZXQubGVuZ3RoO3QrKylpZihyLmNoYXJzZXRbdF09PWUpcmV0dXJuIHQ7cmV0dXJuIC0xfSxlLkNGRi5nbHlwaEJ5U0U9ZnVuY3Rpb24ocix0KXtyZXR1cm4gdDwwfHx0PjI1NT8tMTplLkNGRi5nbHlwaEJ5VW5pY29kZShyLGUuQ0ZGLnRhYmxlU0VbdF0pfSxlLkNGRi5yZWFkRW5jb2Rpbmc9ZnVuY3Rpb24ocix0LGEpe2UuX2Jpbjt2YXIgbj1bXCIubm90ZGVmXCJdLG89clt0XTtpZih0KyssMCE9byl0aHJvdyBcImVycm9yOiB1bmtub3duIGVuY29kaW5nIGZvcm1hdDogXCIrbzt2YXIgcz1yW3RdO3QrKztmb3IodmFyIGk9MDtpPHM7aSsrKW4ucHVzaChyW3QraV0pO3JldHVybiBufSxlLkNGRi5yZWFkQ2hhcnNldD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W1wiLm5vdGRlZlwiXSxzPXJbdF07aWYodCsrLDA9PXMpZm9yKHZhciBpPTA7aTxhO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goaCk7fWVsc2Uge2lmKDEhPXMmJjIhPXMpdGhyb3cgXCJlcnJvcjogZm9ybWF0OiBcIitzO2Zvcig7by5sZW5ndGg8YTspe2g9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj0wOzE9PXM/KGY9clt0XSx0KyspOihmPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpO2ZvcihpPTA7aTw9ZjtpKyspby5wdXNoKGgpLGgrKzt9fXJldHVybiBvfSxlLkNGRi5yZWFkSW5kZXg9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPW4ucmVhZFVzaG9ydChyLHQpKzEscz1yW3QrPTJdO2lmKHQrKywxPT1zKWZvcih2YXIgaT0wO2k8bztpKyspYS5wdXNoKHJbdCtpXSk7ZWxzZSBpZigyPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2gobi5yZWFkVXNob3J0KHIsdCsyKmkpKTtlbHNlIGlmKDM9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaCgxNjc3NzIxNSZuLnJlYWRVaW50KHIsdCszKmktMSkpO2Vsc2UgaWYoMSE9byl0aHJvdyBcInVuc3VwcG9ydGVkIG9mZnNldCBzaXplOiBcIitzK1wiLCBjb3VudDogXCIrbztyZXR1cm4gKHQrPW8qcyktMX0sZS5DRkYuZ2V0Q2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89clt0XSxzPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgaT0xLGg9bnVsbCxmPW51bGw7bzw9MjAmJihoPW8saT0xKSwxMj09byYmKGg9MTAwKm8rcyxpPTIpLDIxPD1vJiZvPD0yNyYmKGg9byxpPTEpLDI4PT1vJiYoZj1uLnJlYWRTaG9ydChyLHQrMSksaT0zKSwyOTw9byYmbzw9MzEmJihoPW8saT0xKSwzMjw9byYmbzw9MjQ2JiYoZj1vLTEzOSxpPTEpLDI0Nzw9byYmbzw9MjUwJiYoZj0yNTYqKG8tMjQ3KStzKzEwOCxpPTIpLDI1MTw9byYmbzw9MjU0JiYoZj0yNTYqLShvLTI1MSktcy0xMDgsaT0yKSwyNTU9PW8mJihmPW4ucmVhZEludChyLHQrMSkvNjU1MzUsaT01KSxhLnZhbD1udWxsIT1mP2Y6XCJvXCIraCxhLnNpemU9aTt9LGUuQ0ZGLnJlYWRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49dCthLG89ZS5fYmluLHM9W107dDxuOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZj0xLGQ9bnVsbCx1PW51bGw7aTw9MjAmJihkPWksZj0xKSwxMj09aSYmKGQ9MTAwKmkraCxmPTIpLDE5IT1pJiYyMCE9aXx8KGQ9aSxmPTIpLDIxPD1pJiZpPD0yNyYmKGQ9aSxmPTEpLDI4PT1pJiYodT1vLnJlYWRTaG9ydChyLHQrMSksZj0zKSwyOTw9aSYmaTw9MzEmJihkPWksZj0xKSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxmPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxmPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZj0yKSwyNTU9PWkmJih1PW8ucmVhZEludChyLHQrMSkvNjU1MzUsZj01KSxzLnB1c2gobnVsbCE9dT91Olwib1wiK2QpLHQrPWY7fXJldHVybiBzfSxlLkNGRi5yZWFkRGljdD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2JpbixvPXt9LHM9W107dDxhOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZj0xLGQ9bnVsbCx1PW51bGw7aWYoMjg9PWkmJih1PW4ucmVhZFNob3J0KHIsdCsxKSxmPTMpLDI5PT1pJiYodT1uLnJlYWRJbnQocix0KzEpLGY9NSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZj0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZj0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGY9MiksMjU1PT1pKXRocm93IHU9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxmPTUsXCJ1bmtub3duIG51bWJlclwiO2lmKDMwPT1pKXt2YXIgbD1bXTtmb3IoZj0xOzspe3ZhciB2PXJbdCtmXTtmKys7dmFyIGM9dj4+NCxwPTE1JnY7aWYoMTUhPWMmJmwucHVzaChjKSwxNSE9cCYmbC5wdXNoKHApLDE1PT1wKWJyZWFrfWZvcih2YXIgVT1cIlwiLGc9WzAsMSwyLDMsNCw1LDYsNyw4LDksXCIuXCIsXCJlXCIsXCJlLVwiLFwicmVzZXJ2ZWRcIixcIi1cIixcImVuZE9mTnVtYmVyXCJdLFM9MDtTPGwubGVuZ3RoO1MrKylVKz1nW2xbU11dO3U9cGFyc2VGbG9hdChVKTt9aWYoaTw9MjEpaWYoZD1bXCJ2ZXJzaW9uXCIsXCJOb3RpY2VcIixcIkZ1bGxOYW1lXCIsXCJGYW1pbHlOYW1lXCIsXCJXZWlnaHRcIixcIkZvbnRCQm94XCIsXCJCbHVlVmFsdWVzXCIsXCJPdGhlckJsdWVzXCIsXCJGYW1pbHlCbHVlc1wiLFwiRmFtaWx5T3RoZXJCbHVlc1wiLFwiU3RkSFdcIixcIlN0ZFZXXCIsXCJlc2NhcGVcIixcIlVuaXF1ZUlEXCIsXCJYVUlEXCIsXCJjaGFyc2V0XCIsXCJFbmNvZGluZ1wiLFwiQ2hhclN0cmluZ3NcIixcIlByaXZhdGVcIixcIlN1YnJzXCIsXCJkZWZhdWx0V2lkdGhYXCIsXCJub21pbmFsV2lkdGhYXCJdW2ldLGY9MSwxMj09aSlkPVtcIkNvcHlyaWdodFwiLFwiaXNGaXhlZFBpdGNoXCIsXCJJdGFsaWNBbmdsZVwiLFwiVW5kZXJsaW5lUG9zaXRpb25cIixcIlVuZGVybGluZVRoaWNrbmVzc1wiLFwiUGFpbnRUeXBlXCIsXCJDaGFyc3RyaW5nVHlwZVwiLFwiRm9udE1hdHJpeFwiLFwiU3Ryb2tlV2lkdGhcIixcIkJsdWVTY2FsZVwiLFwiQmx1ZVNoaWZ0XCIsXCJCbHVlRnV6elwiLFwiU3RlbVNuYXBIXCIsXCJTdGVtU25hcFZcIixcIkZvcmNlQm9sZFwiLDAsMCxcIkxhbmd1YWdlR3JvdXBcIixcIkV4cGFuc2lvbkZhY3RvclwiLFwiaW5pdGlhbFJhbmRvbVNlZWRcIixcIlN5bnRoZXRpY0Jhc2VcIixcIlBvc3RTY3JpcHRcIixcIkJhc2VGb250TmFtZVwiLFwiQmFzZUZvbnRCbGVuZFwiLDAsMCwwLDAsMCwwLFwiUk9TXCIsXCJDSURGb250VmVyc2lvblwiLFwiQ0lERm9udFJldmlzaW9uXCIsXCJDSURGb250VHlwZVwiLFwiQ0lEQ291bnRcIixcIlVJREJhc2VcIixcIkZEQXJyYXlcIixcIkZEU2VsZWN0XCIsXCJGb250TmFtZVwiXVtoXSxmPTI7bnVsbCE9ZD8ob1tkXT0xPT1zLmxlbmd0aD9zWzBdOnMscz1bXSk6cy5wdXNoKHUpLHQrPWY7fXJldHVybiBvfSxlLmNtYXA9e30sZS5jbWFwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXtyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSksdD0wO3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1bXTtvLnRhYmxlcz1bXTtmb3IodmFyIGg9MDtoPHM7aCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9bi5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9XCJwXCIrZitcImVcIitkLHY9aS5pbmRleE9mKHUpO2lmKC0xPT12KXt2YXIgYzt2PW8udGFibGVzLmxlbmd0aCxpLnB1c2godSk7dmFyIHA9bi5yZWFkVXNob3J0KHIsdSk7MD09cD9jPWUuY21hcC5wYXJzZTAocix1KTo0PT1wP2M9ZS5jbWFwLnBhcnNlNChyLHUpOjY9PXA/Yz1lLmNtYXAucGFyc2U2KHIsdSk6MTI9PXA/Yz1lLmNtYXAucGFyc2UxMihyLHUpOmNvbnNvbGUuZGVidWcoXCJ1bmtub3duIGZvcm1hdDogXCIrcCxmLGQsdSksby50YWJsZXMucHVzaChjKTt9aWYobnVsbCE9b1tsXSl0aHJvdyBcIm11bHRpcGxlIHRhYmxlcyBmb3Igb25lIHBsYXRmb3JtK2VuY29kaW5nXCI7b1tsXT12O31yZXR1cm4gb30sZS5jbWFwLnBhcnNlMD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ubWFwPVtdO2Zvcih2YXIgcz0wO3M8by02O3MrKyluLm1hcC5wdXNoKHJbdCtzXSk7cmV0dXJuIG59LGUuY21hcC5wYXJzZTQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e307by5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaD1pLzI7by5zZWFyY2hSYW5nZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW50cnlTZWxlY3Rvcj1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ucmFuZ2VTaGlmdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW5kQ291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLHQrPTIsby5zdGFydENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmlkRGVsdGE9W107Zm9yKHZhciBmPTA7ZjxoO2YrKylvLmlkRGVsdGEucHVzaChhLnJlYWRTaG9ydChyLHQpKSx0Kz0yO2ZvcihvLmlkUmFuZ2VPZmZzZXQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uZ2x5cGhJZEFycmF5PVtdO3Q8bitzOylvLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBvfSxlLmNtYXAucGFyc2U2PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5maXJzdENvZGU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4uZ2x5cGhJZEFycmF5PVtdO2Zvcih2YXIgcz0wO3M8bztzKyspbi5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlMTI9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLHQrPTIsYS5yZWFkVWludChyLHQpLHQrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVWludChyLHQpO3QrPTQsbi5ncm91cHM9W107Zm9yKHZhciBzPTA7czxvO3MrKyl7dmFyIGk9dCsxMipzLGg9YS5yZWFkVWludChyLGkrMCksZj1hLnJlYWRVaW50KHIsaSs0KSxkPWEucmVhZFVpbnQocixpKzgpO24uZ3JvdXBzLnB1c2goW2gsZixkXSk7fXJldHVybiBufSxlLmdseWY9e30sZS5nbHlmLnBhcnNlPWZ1bmN0aW9uKHIsZSx0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhLm1heHAubnVtR2x5cGhzO28rKyluLnB1c2gobnVsbCk7cmV0dXJuIG59LGUuZ2x5Zi5fcGFyc2VHbHlmPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49ci5fZGF0YSxvPWUuX3RhYk9mZnNldChuLFwiZ2x5ZlwiLHIuX29mZnNldCkrci5sb2NhW3RdO2lmKHIubG9jYVt0XT09ci5sb2NhW3QrMV0pcmV0dXJuIG51bGw7dmFyIHM9e307aWYocy5ub2M9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPj1zLnhNYXh8fHMueU1pbj49cy55TWF4KXJldHVybiBudWxsO2lmKHMubm9jPjApe3MuZW5kUHRzPVtdO2Zvcih2YXIgaT0wO2k8cy5ub2M7aSsrKXMuZW5kUHRzLnB1c2goYS5yZWFkVXNob3J0KG4sbykpLG8rPTI7dmFyIGg9YS5yZWFkVXNob3J0KG4sbyk7aWYobys9MixuLmxlbmd0aC1vPGgpcmV0dXJuIG51bGw7cy5pbnN0cnVjdGlvbnM9YS5yZWFkQnl0ZXMobixvLGgpLG8rPWg7dmFyIGY9cy5lbmRQdHNbcy5ub2MtMV0rMTtzLmZsYWdzPVtdO2ZvcihpPTA7aTxmO2krKyl7dmFyIGQ9bltvXTtpZihvKysscy5mbGFncy5wdXNoKGQpLDAhPSg4JmQpKXt2YXIgdT1uW29dO28rKztmb3IodmFyIGw9MDtsPHU7bCsrKXMuZmxhZ3MucHVzaChkKSxpKys7fX1zLnhzPVtdO2ZvcihpPTA7aTxmO2krKyl7dmFyIHY9MCE9KDImcy5mbGFnc1tpXSksYz0wIT0oMTYmcy5mbGFnc1tpXSk7dj8ocy54cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueHMucHVzaCgwKToocy54cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO31zLnlzPVtdO2ZvcihpPTA7aTxmO2krKyl7dj0wIT0oNCZzLmZsYWdzW2ldKSxjPTAhPSgzMiZzLmZsYWdzW2ldKTt2PyhzLnlzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy55cy5wdXNoKDApOihzLnlzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXZhciBwPTAsVT0wO2ZvcihpPTA7aTxmO2krKylwKz1zLnhzW2ldLFUrPXMueXNbaV0scy54c1tpXT1wLHMueXNbaV09VTt9ZWxzZSB7dmFyIGc7cy5wYXJ0cz1bXTtkb3tnPWEucmVhZFVzaG9ydChuLG8pLG8rPTI7dmFyIFM9e206e2E6MSxiOjAsYzowLGQ6MSx0eDowLHR5OjB9LHAxOi0xLHAyOi0xfTtpZihzLnBhcnRzLnB1c2goUyksUy5nbHlwaEluZGV4PWEucmVhZFVzaG9ydChuLG8pLG8rPTIsMSZnKXt2YXIgbT1hLnJlYWRTaG9ydChuLG8pO28rPTI7dmFyIGI9YS5yZWFkU2hvcnQobixvKTtvKz0yO31lbHNlIHttPWEucmVhZEludDgobixvKTtvKys7Yj1hLnJlYWRJbnQ4KG4sbyk7bysrO30yJmc/KFMubS50eD1tLFMubS50eT1iKTooUy5wMT1tLFMucDI9YiksOCZnPyhTLm0uYT1TLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6NjQmZz8oUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjEyOCZnJiYoUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmI9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmM9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpO313aGlsZSgzMiZnKTtpZigyNTYmZyl7dmFyIHk9YS5yZWFkVXNob3J0KG4sbyk7bys9MixzLmluc3RyPVtdO2ZvcihpPTA7aTx5O2krKylzLmluc3RyLnB1c2gobltvXSksbysrO319cmV0dXJuIHN9LGUuR1BPUz17fSxlLkdQT1MucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdQT1Muc3VidCl9LGUuR1BPUy5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDE9PXR8fDI9PXR8fDM9PXR8fDc9PXR8fDg9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixoK3MpO31pZigxPT10JiYxPT1pLmZtdCl7dmFyIGY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgZD1lLl9sY3RmLm51bU9mT25lcyhmKTswIT1mJiYoaS5wb3M9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZikpO31lbHNlIGlmKDI9PXQmJmkuZm10Pj0xJiZpLmZtdDw9Mil7Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB1PW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7ZD1lLl9sY3RmLm51bU9mT25lcyhmKTt2YXIgbD1lLl9sY3RmLm51bU9mT25lcyh1KTtpZigxPT1pLmZtdCl7aS5wYWlyc2V0cz1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgYz0wO2M8djtjKyspe3ZhciBwPXMrby5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgVT1vLnJlYWRVc2hvcnQocixwKTtwKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxVO1MrKyl7dmFyIG09by5yZWFkVXNob3J0KHIscCk7cCs9MiwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxmKSxwKz0yKmQpLDAhPXUmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixwLHUpLHArPTIqbCksZy5wdXNoKHtnaWQyOm0sdmFsMTp4LHZhbDI6UH0pO31pLnBhaXJzZXRzLnB1c2goZyk7fX1pZigyPT1pLmZtdCl7dmFyIGI9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgeT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBGPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIF89by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNsYXNzRGVmMT1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrYiksaS5jbGFzc0RlZjI9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK3kpLGkubWF0cml4PVtdO2ZvcihjPTA7YzxGO2MrKyl7dmFyIEM9W107Zm9yKFM9MDtTPF87UysrKXt2YXIgeD1udWxsLFA9bnVsbDswIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxmKSxhKz0yKmQpLDAhPXUmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLHUpLGErPTIqbCksQy5wdXNoKHt2YWwxOngsdmFsMjpQfSk7fWkubWF0cml4LnB1c2goQyk7fX19ZWxzZSB7aWYoOT09dCYmMT09aS5mbXQpe3ZhciBJPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHc9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPUk7ZWxzZSBpZihuLmx0eXBlIT1JKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1BPUy5zdWJ0KHIsbi5sdHlwZSxzK3cpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHUE9TIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HUE9TLnJlYWRWYWx1ZVJlY29yZD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107cmV0dXJuIG8ucHVzaCgxJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0xJmE/MjowLG8ucHVzaCgyJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0yJmE/MjowLG8ucHVzaCg0JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz00JmE/MjowLG8ucHVzaCg4JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz04JmE/MjowLG99LGUuR1NVQj17fSxlLkdTVUIucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdTVUIuc3VidCl9LGUuR1NVQi5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDEhPXQmJjQhPXQmJjUhPXQmJjYhPXQpcmV0dXJuIG51bGw7aWYoMT09dHx8ND09dHx8NT09dCYmaS5mbXQ8PTJ8fDY9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK2gpO31pZigxPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2lmKDE9PWkuZm10KWkuZGVsdGE9by5yZWFkU2hvcnQocixhKSxhKz0yO2Vsc2UgaWYoMj09aS5mbXQpe3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5uZXdnPW8ucmVhZFVzaG9ydHMocixhLGYpLGErPTIqaS5uZXdnLmxlbmd0aDt9fWVsc2UgaWYoND09dCl7aS52YWxzPVtdO2Y9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGQ9MDtkPGY7ZCsrKXt2YXIgdT1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkudmFscy5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQocixzK3UpKTt9fWVsc2UgaWYoNT09dCYmMj09aS5mbXQpe2lmKDI9PWkuZm10KXt2YXIgbD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY0RlZj1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrbCksaS5zY3NldD1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2ZvcihkPTA7ZDx2O2QrKyl7dmFyIGM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnNjc2V0LnB1c2goMD09Yz9udWxsOmUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQocixzK2MpKTt9fX1lbHNlIGlmKDY9PXQmJjM9PWkuZm10KXtpZigzPT1pLmZtdCl7Zm9yKGQ9MDtkPDM7ZCsrKXtmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBwPVtdLFU9MDtVPGY7VSsrKXAucHVzaChlLl9sY3RmLnJlYWRDb3ZlcmFnZShyLHMrby5yZWFkVXNob3J0KHIsYSsyKlUpKSk7YSs9MipmLDA9PWQmJihpLmJhY2tDdmc9cCksMT09ZCYmKGkuaW5wdEN2Zz1wKSwyPT1kJiYoaS5haGVkQ3ZnPXApO31mPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5sb29rdXBSZWM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocixhLGYpO319ZWxzZSB7aWYoNz09dCYmMT09aS5mbXQpe3ZhciBnPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFM9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPWc7ZWxzZSBpZihuLmx0eXBlIT1nKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1NVQi5zdWJ0KHIsbi5sdHlwZSxzK1MpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHU1VCIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HU1VCLnJlYWRTdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49dCxvPVtdLHM9YShyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YShyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZFN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49e30sbz1hKHIsdCkscz1hKHIsdCs9Mik7dCs9MixuLmlucHV0PVtdO2Zvcih2YXIgaT0wO2k8by0xO2krKyluLmlucHV0LnB1c2goYShyLHQpKSx0Kz0yO3JldHVybiBuLnN1YnN0TG9va3VwUmVjb3Jkcz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLHQscyksbn0sZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHM9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydCxvPVtdLHM9MDtzPGE7cysrKW8ucHVzaChuKHIsdCksbihyLHQrMikpLHQrPTQ7cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT1lLl9iaW4sbj17fSxvPVtcImJhY2t0cmFja1wiLFwiaW5wdXRcIixcImxvb2thaGVhZFwiXSxzPTA7czxvLmxlbmd0aDtzKyspe3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsMT09cyYmaS0tLG5bb1tzXV09YS5yZWFkVXNob3J0cyhyLHQsaSksdCs9MipuW29bc11dLmxlbmd0aDt9aT1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLnN1YnN0PWEucmVhZFVzaG9ydHMocix0LDIqaSksdCs9MipuLnN1YnN0Lmxlbmd0aCxufSxlLkdTVUIucmVhZExpZ2F0dXJlU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZExpZ2F0dXJlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e2NoYWluOltdfTtuLm5nbHlwaD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBzPTA7czxvLTE7cysrKW4uY2hhaW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5oZWFkPXt9LGUuaGVhZC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmZvbnRSZXZpc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsby5mbGFncz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8udW5pdHNQZXJFbT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uY3JlYXRlZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ubW9kaWZpZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLnhNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWFjU3R5bGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmxvd2VzdFJlY1BQRU09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmZvbnREaXJlY3Rpb25IaW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmluZGV4VG9Mb2NGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZ2x5cGhEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxlLmhoZWE9e30sZS5oaGVhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uYXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmxpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uYWR2YW5jZVdpZHRoTWF4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5taW5MZWZ0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWluUmlnaHRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4RXh0ZW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSaXNlPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSdW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLHQrPTgsby5tZXRyaWNEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm51bWJlck9mSE1ldHJpY3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvfSxlLmhtdHg9e30sZS5obXR4LnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1lLl9iaW4scz17YVdpZHRoOltdLGxzQmVhcmluZzpbXX0saT0wLGg9MCxmPTA7ZjxuLm1heHAubnVtR2x5cGhzO2YrKylmPG4uaGhlYS5udW1iZXJPZkhNZXRyaWNzJiYoaT1vLnJlYWRVc2hvcnQocix0KSx0Kz0yLGg9by5yZWFkU2hvcnQocix0KSx0Kz0yKSxzLmFXaWR0aC5wdXNoKGkpLHMubHNCZWFyaW5nLnB1c2goaCk7cmV0dXJuIHN9LGUua2Vybj17fSxlLmtlcm4ucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9by5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1zKXJldHVybiBlLmtlcm4ucGFyc2VWMShyLHQtMixhLG4pO3ZhciBpPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXtnbHlwaDE6W10scnZhbDpbXX0sZj0wO2Y8aTtmKyspe3QrPTI7YT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9ZD4+Pjg7aWYoMCE9KHUmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK3U7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGgpO31yZXR1cm4gaH0sZS5rZXJuLnBhcnNlVjE9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluO28ucmVhZEZpeGVkKHIsdCksdCs9NDt2YXIgcz1vLnJlYWRVaW50KHIsdCk7dCs9NDtmb3IodmFyIGk9e2dseXBoMTpbXSxydmFsOltdfSxoPTA7aDxzO2grKyl7by5yZWFkVWludChyLHQpLHQrPTQ7dmFyIGY9by5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBkPWY+Pj44O2lmKDAhPShkJj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIitkO3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxpKTt9cmV0dXJuIGl9LGUua2Vybi5yZWFkRm9ybWF0MD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89LTEscz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRTaG9ydChyLHQpO3QrPTIsaCE9byYmKGEuZ2x5cGgxLnB1c2goaCksYS5ydmFsLnB1c2goe2dseXBoMjpbXSx2YWxzOltdfSkpO3ZhciB1PWEucnZhbFthLnJ2YWwubGVuZ3RoLTFdO3UuZ2x5cGgyLnB1c2goZiksdS52YWxzLnB1c2goZCksbz1oO31yZXR1cm4gdH0sZS5sb2NhPXt9LGUubG9jYS5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1bXSxpPW4uaGVhZC5pbmRleFRvTG9jRm9ybWF0LGg9bi5tYXhwLm51bUdseXBocysxO2lmKDA9PWkpZm9yKHZhciBmPTA7ZjxoO2YrKylzLnB1c2goby5yZWFkVXNob3J0KHIsdCsoZjw8MSkpPDwxKTtpZigxPT1pKWZvcihmPTA7ZjxoO2YrKylzLnB1c2goby5yZWFkVWludChyLHQrKGY8PDIpKSk7cmV0dXJuIHN9LGUubWF4cD17fSxlLm1heHAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9LHM9bi5yZWFkVWludChyLHQpO3JldHVybiB0Kz00LG8ubnVtR2x5cGhzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsNjU1MzY9PXMmJihvLm1heFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZVBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlQ29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFpvbmVzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhUd2lsaWdodFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RvcmFnZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4RnVuY3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhJbnN0cnVjdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0YWNrRWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFNpemVPZkluc3RydWN0aW9ucz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudERlcHRoPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpLG99LGUubmFtZT17fSxlLm5hbWUucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KTtmb3IodmFyIGksaD1bXCJjb3B5cmlnaHRcIixcImZvbnRGYW1pbHlcIixcImZvbnRTdWJmYW1pbHlcIixcIklEXCIsXCJmdWxsTmFtZVwiLFwidmVyc2lvblwiLFwicG9zdFNjcmlwdE5hbWVcIixcInRyYWRlbWFya1wiLFwibWFudWZhY3R1cmVyXCIsXCJkZXNpZ25lclwiLFwiZGVzY3JpcHRpb25cIixcInVybFZlbmRvclwiLFwidXJsRGVzaWduZXJcIixcImxpY2VuY2VcIixcImxpY2VuY2VVUkxcIixcIi0tLVwiLFwidHlwb0ZhbWlseU5hbWVcIixcInR5cG9TdWJmYW1pbHlOYW1lXCIsXCJjb21wYXRpYmxlRnVsbFwiLFwic2FtcGxlVGV4dFwiLFwicG9zdFNjcmlwdENJRFwiLFwid3dzRmFtaWx5TmFtZVwiLFwid3dzU3ViZmFtaWx5TmFtZVwiLFwibGlnaHRQYWxldHRlXCIsXCJkYXJrUGFsZXR0ZVwiXSxmPXQrPTIsZD0wO2Q8cztkKyspe3ZhciB1PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGw9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBjPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHA9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgVT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBnLFM9aFtjXSxtPWYrMTIqcytVO2lmKDA9PXUpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09dSYmMD09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigwPT1sKWc9bi5yZWFkQVNDSUkocixtLHApO2Vsc2UgaWYoMT09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIHtpZigxIT11KXRocm93IFwidW5rbm93biBlbmNvZGluZyBcIitsK1wiLCBwbGF0Zm9ybUlEOiBcIit1O2c9bi5yZWFkQVNDSUkocixtLHApLGNvbnNvbGUuZGVidWcoXCJyZWFkaW5nIHVua25vd24gTUFDIGVuY29kaW5nIFwiK2wrXCIgYXMgQVNDSUlcIik7fXZhciBiPVwicFwiK3UrXCIsXCIrdi50b1N0cmluZygxNik7bnVsbD09b1tiXSYmKG9bYl09e30pLG9bYl1bdm9pZCAwIT09Uz9TOmNdPWcsb1tiXS5fbGFuZz12O31mb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYxMDMzPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjA9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMzA4ND09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKXtpPXk7YnJlYWt9cmV0dXJuIGNvbnNvbGUuZGVidWcoXCJyZXR1cm5pbmcgbmFtZSB0YWJsZSB3aXRoIGxhbmd1YWdlSUQgXCIrb1tpXS5fbGFuZyksb1tpXX0sZVtcIk9TLzJcIl09e30sZVtcIk9TLzJcIl0ucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbz17fTtpZigwPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxvKTtlbHNlIGlmKDE9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LG8pO2Vsc2UgaWYoMj09bnx8Mz09bnx8ND09billW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsbyk7ZWxzZSB7aWYoNSE9bil0aHJvdyBcInVua25vd24gT1MvMiB0YWJsZSB2ZXJzaW9uOiBcIituO2VbXCJPUy8yXCJdLnZlcnNpb241KHIsdCxvKTt9cmV0dXJuIG99LGVbXCJPUy8yXCJdLnZlcnNpb24wPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIGEueEF2Z0NoYXJXaWR0aD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dlaWdodENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpZHRoQ2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLmZzVHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNGYW1pbHlDbGFzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5wYW5vc2U9bi5yZWFkQnl0ZXMocix0LDEwKSx0Kz0xMCxhLnVsVW5pY29kZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMz1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlND1uLnJlYWRVaW50KHIsdCksdCs9NCxhLmFjaFZlbmRJRD1bbi5yZWFkSW50OChyLHQpLG4ucmVhZEludDgocix0KzEpLG4ucmVhZEludDgocix0KzIpLG4ucmVhZEludDgocix0KzMpXSx0Kz00LGEuZnNTZWxlY3Rpb249bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzRmlyc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTGFzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuc1R5cG9Bc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0Rlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0xpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXaW5Bc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2luRGVzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uMT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxhKSxhLnVsQ29kZVBhZ2VSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bENvZGVQYWdlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00fSxlW1wiT1MvMlwiXS52ZXJzaW9uMj1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxhKSxhLnN4SGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNDYXBIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNEZWZhdWx0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0JyZWFrPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c01heENvbnRleHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsYSksYS51c0xvd2VyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNVcHBlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZS5wb3N0PXt9LGUucG9zdC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG8udmVyc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby5pdGFsaWNBbmdsZT1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby51bmRlcmxpbmVQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby51bmRlcmxpbmVUaGlja25lc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LG51bGw9PWUmJihlPXt9KSxudWxsPT1lLlUmJihlLlU9e30pLGUuVS5jb2RlVG9HbHlwaD1mdW5jdGlvbihyLGUpe3ZhciB0PXIuY21hcCxhPS0xO2lmKG51bGwhPXQucDBlND9hPXQucDBlNDpudWxsIT10LnAzZTE/YT10LnAzZTE6bnVsbCE9dC5wMWUwP2E9dC5wMWUwOm51bGwhPXQucDBlMyYmKGE9dC5wMGUzKSwtMT09YSl0aHJvdyBcIm5vIGZhbWlsaWFyIHBsYXRmb3JtIGFuZCBlbmNvZGluZyFcIjt2YXIgbj10LnRhYmxlc1thXTtpZigwPT1uLmZvcm1hdClyZXR1cm4gZT49bi5tYXAubGVuZ3RoPzA6bi5tYXBbZV07aWYoND09bi5mb3JtYXQpe2Zvcih2YXIgbz0tMSxzPTA7czxuLmVuZENvdW50Lmxlbmd0aDtzKyspaWYoZTw9bi5lbmRDb3VudFtzXSl7bz1zO2JyZWFrfWlmKC0xPT1vKXJldHVybiAwO2lmKG4uc3RhcnRDb3VudFtvXT5lKXJldHVybiAwO3JldHVybiA2NTUzNSYoMCE9bi5pZFJhbmdlT2Zmc2V0W29dP24uZ2x5cGhJZEFycmF5W2Utbi5zdGFydENvdW50W29dKyhuLmlkUmFuZ2VPZmZzZXRbb10+PjEpLShuLmlkUmFuZ2VPZmZzZXQubGVuZ3RoLW8pXTplK24uaWREZWx0YVtvXSl9aWYoMTI9PW4uZm9ybWF0KXtpZihlPm4uZ3JvdXBzW24uZ3JvdXBzLmxlbmd0aC0xXVsxXSlyZXR1cm4gMDtmb3Iocz0wO3M8bi5ncm91cHMubGVuZ3RoO3MrKyl7dmFyIGk9bi5ncm91cHNbc107aWYoaVswXTw9ZSYmZTw9aVsxXSlyZXR1cm4gaVsyXSsoZS1pWzBdKX1yZXR1cm4gMH10aHJvdyBcInVua25vd24gY21hcCB0YWJsZSBmb3JtYXQgXCIrbi5mb3JtYXR9LGUuVS5nbHlwaFRvUGF0aD1mdW5jdGlvbihyLHQpe3ZhciBhPXtjbWRzOltdLGNyZHM6W119O2lmKHIuU1ZHJiZyLlNWRy5lbnRyaWVzW3RdKXt2YXIgbj1yLlNWRy5lbnRyaWVzW3RdO3JldHVybiBudWxsPT1uP2E6KFwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj1lLlNWRy50b1BhdGgobiksci5TVkcuZW50cmllc1t0XT1uKSxuKX1pZihyLkNGRil7dmFyIG89e3g6MCx5OjAsc3RhY2s6W10sblN0ZW1zOjAsaGF2ZVdpZHRoOiExLHdpZHRoOnIuQ0ZGLlByaXZhdGU/ci5DRkYuUHJpdmF0ZS5kZWZhdWx0V2lkdGhYOjAsb3BlbjohMX0scz1yLkNGRixpPXIuQ0ZGLlByaXZhdGU7aWYocy5ST1Mpe2Zvcih2YXIgaD0wO3MuRkRTZWxlY3RbaCsyXTw9dDspaCs9MjtpPXMuRkRBcnJheVtzLkZEU2VsZWN0W2grMV1dLlByaXZhdGU7fWUuVS5fZHJhd0NGRihyLkNGRi5DaGFyU3RyaW5nc1t0XSxvLHMsaSxhKTt9ZWxzZSByLmdseWYmJmUuVS5fZHJhd0dseWYodCxyLGEpO3JldHVybiBhfSxlLlUuX2RyYXdHbHlmPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj10LmdseWZbcl07bnVsbD09biYmKG49dC5nbHlmW3JdPWUuZ2x5Zi5fcGFyc2VHbHlmKHQscikpLG51bGwhPW4mJihuLm5vYz4tMT9lLlUuX3NpbXBsZUdseXBoKG4sYSk6ZS5VLl9jb21wb0dseXBoKG4sdCxhKSk7fSxlLlUuX3NpbXBsZUdseXBoPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPTA7YTxyLm5vYzthKyspe2Zvcih2YXIgbj0wPT1hPzA6ci5lbmRQdHNbYS0xXSsxLG89ci5lbmRQdHNbYV0scz1uO3M8PW87cysrKXt2YXIgaT1zPT1uP286cy0xLGg9cz09bz9uOnMrMSxmPTEmci5mbGFnc1tzXSxkPTEmci5mbGFnc1tpXSx1PTEmci5mbGFnc1toXSxsPXIueHNbc10sdj1yLnlzW3NdO2lmKHM9PW4paWYoZil7aWYoIWQpe2UuVS5QLm1vdmVUbyh0LGwsdik7Y29udGludWV9ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTt9ZWxzZSBkP2UuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk6ZS5VLlAubW92ZVRvKHQsKHIueHNbaV0rbCkvMiwoci55c1tpXSt2KS8yKTtmP2QmJmUuVS5QLmxpbmVUbyh0LGwsdik6dT9lLlUuUC5xY3VydmVUbyh0LGwsdixyLnhzW2hdLHIueXNbaF0pOmUuVS5QLnFjdXJ2ZVRvKHQsbCx2LChsK3IueHNbaF0pLzIsKHYrci55c1toXSkvMik7fWUuVS5QLmNsb3NlUGF0aCh0KTt9fSxlLlUuX2NvbXBvR2x5cGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248ci5wYXJ0cy5sZW5ndGg7bisrKXt2YXIgbz17Y21kczpbXSxjcmRzOltdfSxzPXIucGFydHNbbl07ZS5VLl9kcmF3R2x5ZihzLmdseXBoSW5kZXgsdCxvKTtmb3IodmFyIGk9cy5tLGg9MDtoPG8uY3Jkcy5sZW5ndGg7aCs9Mil7dmFyIGY9by5jcmRzW2hdLGQ9by5jcmRzW2grMV07YS5jcmRzLnB1c2goZippLmErZCppLmIraS50eCksYS5jcmRzLnB1c2goZippLmMrZCppLmQraS50eSk7fWZvcihoPTA7aDxvLmNtZHMubGVuZ3RoO2grKylhLmNtZHMucHVzaChvLmNtZHNbaF0pO319LGUuVS5fZ2V0R2x5cGhDbGFzcz1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2xjdGYuZ2V0SW50ZXJ2YWwodCxyKTtyZXR1cm4gLTE9PWE/MDp0W2ErMl19LGUuVS5nZXRQYWlyQWRqdXN0bWVudD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ITE7aWYoci5HUE9TKWZvcih2YXIgbz1yLkdQT1Mscz1vLmxvb2t1cExpc3QsaT1vLmZlYXR1cmVMaXN0LGg9W10sZj0wO2Y8aS5sZW5ndGg7ZisrKXt2YXIgZD1pW2ZdO2lmKFwia2VyblwiPT1kLnRhZyl7bj0hMDtmb3IodmFyIHU9MDt1PGQudGFiLmxlbmd0aDt1KyspaWYoIWhbZC50YWJbdV1dKXtoW2QudGFiW3VdXT0hMDtmb3IodmFyIGw9c1tkLnRhYlt1XV0sdj0wO3Y8bC50YWJzLmxlbmd0aDt2KyspaWYobnVsbCE9bC50YWJzW3ZdKXt2YXIgYyxwPWwudGFic1t2XTtpZighcC5jb3ZlcmFnZXx8LTEhPShjPWUuX2xjdGYuY292ZXJhZ2VJbmRleChwLmNvdmVyYWdlLHQpKSlpZigxPT1sLmx0eXBlKTtlbHNlIGlmKDI9PWwubHR5cGUpe3ZhciBVPW51bGw7aWYoMT09cC5mbXQpe3ZhciBnPXAucGFpcnNldHNbY107Zm9yKGY9MDtmPGcubGVuZ3RoO2YrKylnW2ZdLmdpZDI9PWEmJihVPWdbZl0pO31lbHNlIGlmKDI9PXAuZm10KXt2YXIgUz1lLlUuX2dldEdseXBoQ2xhc3ModCxwLmNsYXNzRGVmMSksbT1lLlUuX2dldEdseXBoQ2xhc3MoYSxwLmNsYXNzRGVmMik7VT1wLm1hdHJpeFtTXVttXTt9aWYoVSl7dmFyIGI9MDtyZXR1cm4gVS52YWwxJiZVLnZhbDFbMl0mJihiKz1VLnZhbDFbMl0pLFUudmFsMiYmVS52YWwyWzBdJiYoYis9VS52YWwyWzBdKSxifX19fX19aWYoci5rZXJuJiYhbil7dmFyIHk9ci5rZXJuLmdseXBoMS5pbmRleE9mKHQpO2lmKC0xIT15KXt2YXIgRj1yLmtlcm4ucnZhbFt5XS5nbHlwaDIuaW5kZXhPZihhKTtpZigtMSE9RilyZXR1cm4gci5rZXJuLnJ2YWxbeV0udmFsc1tGXX19cmV0dXJuIDB9LGUuVS5fYXBwbHlTdWJzPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1yLmxlbmd0aC10LTEscz0wO3M8YS50YWJzLmxlbmd0aDtzKyspaWYobnVsbCE9YS50YWJzW3NdKXt2YXIgaSxoPWEudGFic1tzXTtpZighaC5jb3ZlcmFnZXx8LTEhPShpPWUuX2xjdGYuY292ZXJhZ2VJbmRleChoLmNvdmVyYWdlLHJbdF0pKSlpZigxPT1hLmx0eXBlKXJbdF0sMT09aC5mbXQ/clt0XT1yW3RdK2guZGVsdGE6clt0XT1oLm5ld2dbaV07ZWxzZSBpZig0PT1hLmx0eXBlKWZvcih2YXIgZj1oLnZhbHNbaV0sZD0wO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgdT1mW2RdLGw9dS5jaGFpbi5sZW5ndGg7aWYoIShsPm8pKXtmb3IodmFyIHY9ITAsYz0wLHA9MDtwPGw7cCsrKXtmb3IoOy0xPT1yW3QrYysoMStwKV07KWMrKzt1LmNoYWluW3BdIT1yW3QrYysoMStwKV0mJih2PSExKTt9aWYodil7clt0XT11Lm5nbHlwaDtmb3IocD0wO3A8bCtjO3ArKylyW3QrcCsxXT0tMTticmVha319fWVsc2UgaWYoNT09YS5sdHlwZSYmMj09aC5mbXQpZm9yKHZhciBVPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdF0pLGc9aC5jRGVmW1UrMl0sUz1oLnNjc2V0W2ddLG09MDttPFMubGVuZ3RoO20rKyl7dmFyIGI9U1ttXSx5PWIuaW5wdXQ7aWYoISh5Lmxlbmd0aD5vKSl7Zm9yKHY9ITAscD0wO3A8eS5sZW5ndGg7cCsrKXt2YXIgRj1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3QrMStwXSk7aWYoLTE9PVUmJmguY0RlZltGKzJdIT15W3BdKXt2PSExO2JyZWFrfX1pZih2KXt2YXIgXz1iLnN1YnN0TG9va3VwUmVjb3Jkcztmb3IoZD0wO2Q8Xy5sZW5ndGg7ZCs9MilfW2RdLF9bZCsxXTt9fX1lbHNlIGlmKDY9PWEubHR5cGUmJjM9PWguZm10KXtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5iYWNrQ3ZnLHQtaC5iYWNrQ3ZnLmxlbmd0aCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguaW5wdEN2Zyx0KSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5haGVkQ3ZnLHQraC5pbnB0Q3ZnLmxlbmd0aCkpY29udGludWU7dmFyIEM9aC5sb29rdXBSZWM7Zm9yKG09MDttPEMubGVuZ3RoO20rPTIpe1U9Q1ttXTt2YXIgeD1uW0NbbSsxXV07ZS5VLl9hcHBseVN1YnMocix0K1UseCxuKTt9fX19LGUuVS5fZ2xzQ292ZXJlZD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe2lmKC0xPT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgodFtuXSxyW2Erbl0pKXJldHVybiAhMX1yZXR1cm4gITB9LGUuVS5nbHlwaHNUb1BhdGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj17Y21kczpbXSxjcmRzOltdfSxvPTAscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgaT10W3NdO2lmKC0xIT1pKXtmb3IodmFyIGg9czx0Lmxlbmd0aC0xJiYtMSE9dFtzKzFdP3RbcysxXTowLGY9ZS5VLmdseXBoVG9QYXRoKHIsaSksZD0wO2Q8Zi5jcmRzLmxlbmd0aDtkKz0yKW4uY3Jkcy5wdXNoKGYuY3Jkc1tkXStvKSxuLmNyZHMucHVzaChmLmNyZHNbZCsxXSk7YSYmbi5jbWRzLnB1c2goYSk7Zm9yKGQ9MDtkPGYuY21kcy5sZW5ndGg7ZCsrKW4uY21kcy5wdXNoKGYuY21kc1tkXSk7YSYmbi5jbWRzLnB1c2goXCJYXCIpLG8rPXIuaG10eC5hV2lkdGhbaV0sczx0Lmxlbmd0aC0xJiYobys9ZS5VLmdldFBhaXJBZGp1c3RtZW50KHIsaSxoKSk7fX1yZXR1cm4gbn0sZS5VLlA9e30sZS5VLlAubW92ZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIk1cIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmxpbmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJMXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5jdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbixvLHMpe3IuY21kcy5wdXNoKFwiQ1wiKSxyLmNyZHMucHVzaChlLHQsYSxuLG8scyk7fSxlLlUuUC5xY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4pe3IuY21kcy5wdXNoKFwiUVwiKSxyLmNyZHMucHVzaChlLHQsYSxuKTt9LGUuVS5QLmNsb3NlUGF0aD1mdW5jdGlvbihyKXtyLmNtZHMucHVzaChcIlpcIik7fSxlLlUuX2RyYXdDRkY9ZnVuY3Rpb24ocix0LGEsbixvKXtmb3IodmFyIHM9dC5zdGFjayxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZj10LndpZHRoLGQ9dC5vcGVuLHU9MCxsPXQueCx2PXQueSxjPTAscD0wLFU9MCxnPTAsUz0wLG09MCxiPTAseT0wLEY9MCxfPTAsQz17dmFsOjAsc2l6ZTowfTt1PHIubGVuZ3RoOyl7ZS5DRkYuZ2V0Q2hhclN0cmluZyhyLHUsQyk7dmFyIHg9Qy52YWw7aWYodSs9Qy5zaXplLFwibzFcIj09eHx8XCJvMThcIj09eClzLmxlbmd0aCUyIT0wJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO2Vsc2UgaWYoXCJvM1wiPT14fHxcIm8yM1wiPT14KXtzLmxlbmd0aCUyIT0wJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO31lbHNlIGlmKFwibzRcIj09eClzLmxlbmd0aD4xJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxkJiZlLlUuUC5jbG9zZVBhdGgobyksdis9cy5wb3AoKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGQ9ITA7ZWxzZSBpZihcIm81XCI9PXgpZm9yKDtzLmxlbmd0aD4wOylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7ZWxzZSBpZihcIm82XCI9PXh8fFwibzdcIj09eClmb3IodmFyIFA9cy5sZW5ndGgsST1cIm82XCI9PXgsdz0wO3c8UDt3Kyspe3ZhciBPPXMuc2hpZnQoKTtJP2wrPU86dis9TyxJPSFJLGUuVS5QLmxpbmVUbyhvLGwsdik7fWVsc2UgaWYoXCJvOFwiPT14fHxcIm8yNFwiPT14KXtQPXMubGVuZ3RoO2Zvcih2YXIgVD0wO1QrNjw9UDspYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxUKz02O1wibzI0XCI9PXgmJihsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdikpO31lbHNlIHtpZihcIm8xMVwiPT14KWJyZWFrO2lmKFwibzEyMzRcIj09eHx8XCJvMTIzNVwiPT14fHxcIm8xMjM2XCI9PXh8fFwibzEyMzdcIj09eClcIm8xMjM0XCI9PXgmJihwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLF89Zz1wK3Muc2hpZnQoKSxtPWcseT12LGw9KGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM1XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksXz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09XytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksdj15K3Muc2hpZnQoKSxzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM2XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxfPWc9cCtzLnNoaWZ0KCksbT1nLGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLF8pLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzdcIj09eCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxfPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1fK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksTWF0aC5hYnMoYi1sKT5NYXRoLmFicyh5LXYpP2w9YitzLnNoaWZ0KCk6dj15K3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLF8pLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpO2Vsc2UgaWYoXCJvMTRcIj09eCl7aWYocy5sZW5ndGg+MCYmIWgmJihmPXMuc2hpZnQoKSthLm5vbWluYWxXaWR0aFgsaD0hMCksND09cy5sZW5ndGgpe3ZhciBrPXMuc2hpZnQoKSxHPXMuc2hpZnQoKSxEPXMuc2hpZnQoKSxCPXMuc2hpZnQoKSxMPWUuQ0ZGLmdseXBoQnlTRShhLEQpLFI9ZS5DRkYuZ2x5cGhCeVNFKGEsQik7ZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbTF0sdCxhLG4sbyksdC54PWssdC55PUcsZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbUl0sdCxhLG4sbyk7fWQmJihlLlUuUC5jbG9zZVBhdGgobyksZD0hMSk7fWVsc2UgaWYoXCJvMTlcIj09eHx8XCJvMjBcIj09eCl7cy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMCx1Kz1pKzc+PjM7fWVsc2UgaWYoXCJvMjFcIj09eClzLmxlbmd0aD4yJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSx2Kz1zLnBvcCgpLGwrPXMucG9wKCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZD0hMDtlbHNlIGlmKFwibzIyXCI9PXgpcy5sZW5ndGg+MSYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksbCs9cy5wb3AoKSxkJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxkPSEwO2Vsc2UgaWYoXCJvMjVcIj09eCl7Zm9yKDtzLmxlbmd0aD42OylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7Yz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTt9ZWxzZSBpZihcIm8yNlwiPT14KWZvcihzLmxlbmd0aCUyJiYobCs9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOyljPWwscD12K3Muc2hpZnQoKSxsPVU9YytzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8yN1wiPT14KWZvcihzLmxlbmd0aCUyJiYodis9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOylwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcsZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzEwXCI9PXh8fFwibzI5XCI9PXgpe3ZhciBBPVwibzEwXCI9PXg/bjphO2lmKDA9PXMubGVuZ3RoKWNvbnNvbGUuZGVidWcoXCJlcnJvcjogZW1wdHkgc3RhY2tcIik7ZWxzZSB7dmFyIFc9cy5wb3AoKSxNPUEuU3VicnNbVytBLkJpYXNdO3QueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWYsdC5vcGVuPWQsZS5VLl9kcmF3Q0ZGKE0sdCxhLG4sbyksbD10Lngsdj10LnksaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGY9dC53aWR0aCxkPXQub3Blbjt9fWVsc2UgaWYoXCJvMzBcIj09eHx8XCJvMzFcIj09eCl7dmFyIFY9cy5sZW5ndGgsTj0oVD0wLFwibzMxXCI9PXgpO2ZvcihUKz1WLShQPS0zJlYpO1Q8UDspTj8ocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCksUC1UPT01PyhsPVUrcy5zaGlmdCgpLFQrKyk6bD1VLE49ITEpOihjPWwscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSxQLVQ9PTU/KHY9ZytzLnNoaWZ0KCksVCsrKTp2PWcsTj0hMCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxUKz00O31lbHNlIHtpZihcIm9cIj09KHgrXCJcIikuY2hhckF0KDApKXRocm93IGNvbnNvbGUuZGVidWcoXCJVbmtub3duIG9wZXJhdGlvbjogXCIreCxyKSx4O3MucHVzaCh4KTt9fX10Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1mLHQub3Blbj1kO307dmFyIHQ9ZSxhPXtUeXByOnR9O3JldHVybiByLlR5cHI9dCxyLmRlZmF1bHQ9YSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyfSh7fSkuVHlwcn1cblxuLyohXG5DdXN0b20gYnVuZGxlIG9mIHdvZmYyb3RmIChodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmKSB3aXRoIGZmbGF0ZVxuKGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlKSBmb3IgdXNlIGluIFRyb2lrYSB0ZXh0IHJlbmRlcmluZy4gXG5PcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4tIGZmbGF0ZTogaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuLSB3b2ZmMm90Zi5qczogaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zi9ibG9iL21hc3Rlci93b2ZmMm90Zi5qcyAoQXBhY2hlMilcbiovXG5mdW5jdGlvbiB3b2ZmMm90ZkZhY3RvcnkoKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGU9VWludDhBcnJheSxuPVVpbnQxNkFycmF5LHQ9VWludDMyQXJyYXksYT1uZXcgZShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksaT1uZXcgZShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxvPW5ldyBlKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksZj1mdW5jdGlvbihyLGUpe2Zvcih2YXIgYT1uZXcgbigzMSksaT0wO2k8MzE7KytpKWFbaV09ZSs9MTw8cltpLTFdO3ZhciBvPW5ldyB0KGFbMzBdKTtmb3IoaT0xO2k8MzA7KytpKWZvcih2YXIgZj1hW2ldO2Y8YVtpKzFdOysrZilvW2ZdPWYtYVtpXTw8NXxpO3JldHVybiBbYSxvXX0sdT1mKGEsMiksdj11WzBdLHM9dVsxXTt2WzI4XT0yNTgsc1syNThdPTI4O2Zvcih2YXIgbD1mKGksMClbMF0sYz1uZXcgbigzMjc2OCksZz0wO2c8MzI3Njg7KytnKXt2YXIgaD0oNDM2OTAmZyk+Pj4xfCgyMTg0NSZnKTw8MTtoPSg2MTY4MCYoaD0oNTI0MjgmaCk+Pj4yfCgxMzEwNyZoKTw8MikpPj4+NHwoMzg1NSZoKTw8NCxjW2ddPSgoNjUyODAmaCk+Pj44fCgyNTUmaCk8PDgpPj4+MTt9dmFyIHc9ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1yLmxlbmd0aCxpPTAsbz1uZXcgbihlKTtpPGE7KytpKSsrb1tyW2ldLTFdO3ZhciBmLHU9bmV3IG4oZSk7Zm9yKGk9MDtpPGU7KytpKXVbaV09dVtpLTFdK29baS0xXTw8MTtpZih0KXtmPW5ldyBuKDE8PGUpO3ZhciB2PTE1LWU7Zm9yKGk9MDtpPGE7KytpKWlmKHJbaV0pZm9yKHZhciBzPWk8PDR8cltpXSxsPWUtcltpXSxnPXVbcltpXS0xXSsrPDxsLGg9Z3woMTw8bCktMTtnPD1oOysrZylmW2NbZ10+Pj52XT1zO31lbHNlIGZvcihmPW5ldyBuKGEpLGk9MDtpPGE7KytpKXJbaV0mJihmW2ldPWNbdVtyW2ldLTFdKytdPj4+MTUtcltpXSk7cmV0dXJuIGZ9LGQ9bmV3IGUoMjg4KTtmb3IoZz0wO2c8MTQ0OysrZylkW2ddPTg7Zm9yKGc9MTQ0O2c8MjU2OysrZylkW2ddPTk7Zm9yKGc9MjU2O2c8MjgwOysrZylkW2ddPTc7Zm9yKGc9MjgwO2c8Mjg4OysrZylkW2ddPTg7dmFyIG09bmV3IGUoMzIpO2ZvcihnPTA7ZzwzMjsrK2cpbVtnXT01O3ZhciBiPXcoZCw5LDEpLHA9dyhtLDUsMSkseT1mdW5jdGlvbihyKXtmb3IodmFyIGU9clswXSxuPTE7bjxyLmxlbmd0aDsrK24pcltuXT5lJiYoZT1yW25dKTtyZXR1cm4gZX0sTD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9ZS84fDA7cmV0dXJuIChyW3RdfHJbdCsxXTw8OCk+Pig3JmUpJm59LFU9ZnVuY3Rpb24ocixlKXt2YXIgbj1lLzh8MDtyZXR1cm4gKHJbbl18cltuKzFdPDw4fHJbbisyXTw8MTYpPj4oNyZlKX0saz1bXCJ1bmV4cGVjdGVkIEVPRlwiLFwiaW52YWxpZCBibG9jayB0eXBlXCIsXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCIsXCJpbnZhbGlkIGRpc3RhbmNlXCIsXCJzdHJlYW0gZmluaXNoZWRcIixcIm5vIHN0cmVhbSBoYW5kbGVyXCIsLFwibm8gY2FsbGJhY2tcIixcImludmFsaWQgVVRGLTggZGF0YVwiLFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIixcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFwiZmlsZW5hbWUgdG9vIGxvbmdcIixcInN0cmVhbSBmaW5pc2hpbmdcIixcImludmFsaWQgemlwIGRhdGFcIl0sVD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9bmV3IEVycm9yKGV8fGtbcl0pO2lmKHQuY29kZT1yLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0LFQpLCFuKXRocm93IHQ7cmV0dXJuIHR9LE89ZnVuY3Rpb24ocixmLHUpe3ZhciBzPXIubGVuZ3RoO2lmKCFzfHx1JiYhdS5sJiZzPDUpcmV0dXJuIGZ8fG5ldyBlKDApO3ZhciBjPSFmfHx1LGc9IXV8fHUuaTt1fHwodT17fSksZnx8KGY9bmV3IGUoMypzKSk7dmFyIGgsZD1mdW5jdGlvbihyKXt2YXIgbj1mLmxlbmd0aDtpZihyPm4pe3ZhciB0PW5ldyBlKE1hdGgubWF4KDIqbixyKSk7dC5zZXQoZiksZj10O319LG09dS5mfHwwLGs9dS5wfHwwLE89dS5ifHwwLEE9dS5sLHg9dS5kLEU9dS5tLEQ9dS5uLE09OCpzO2Rve2lmKCFBKXt1LmY9bT1MKHIsaywxKTt2YXIgUz1MKHIsaysxLDMpO2lmKGsrPTMsIVMpe3ZhciBWPXJbKEk9KChoPWspLzh8MCkrKDcmaCYmMSkrNCktNF18cltJLTNdPDw4LF89SStWO2lmKF8+cyl7ZyYmVCgwKTticmVha31jJiZkKE8rViksZi5zZXQoci5zdWJhcnJheShJLF8pLE8pLHUuYj1PKz1WLHUucD1rPTgqXztjb250aW51ZX1pZigxPT1TKUE9Yix4PXAsRT05LEQ9NTtlbHNlIGlmKDI9PVMpe3ZhciBqPUwocixrLDMxKSsyNTcsej1MKHIsaysxMCwxNSkrNCxDPWorTChyLGsrNSwzMSkrMTtrKz0xNDtmb3IodmFyIEY9bmV3IGUoQyksUD1uZXcgZSgxOSkscT0wO3E8ejsrK3EpUFtvW3FdXT1MKHIsayszKnEsNyk7ays9Myp6O3ZhciBCPXkoUCksRz0oMTw8QiktMSxIPXcoUCxCLDEpO2ZvcihxPTA7cTxDOyl7dmFyIEksSj1IW0wocixrLEcpXTtpZihrKz0xNSZKLChJPUo+Pj40KTwxNilGW3ErK109STtlbHNlIHt2YXIgSz0wLE49MDtmb3IoMTY9PUk/KE49MytMKHIsaywzKSxrKz0yLEs9RltxLTFdKToxNz09ST8oTj0zK0wocixrLDcpLGsrPTMpOjE4PT1JJiYoTj0xMStMKHIsaywxMjcpLGsrPTcpO04tLTspRltxKytdPUs7fX12YXIgUT1GLnN1YmFycmF5KDAsaiksUj1GLnN1YmFycmF5KGopO0U9eShRKSxEPXkoUiksQT13KFEsRSwxKSx4PXcoUixELDEpO31lbHNlIFQoMSk7aWYoaz5NKXtnJiZUKDApO2JyZWFrfX1jJiZkKE8rMTMxMDcyKTtmb3IodmFyIFc9KDE8PEUpLTEsWD0oMTw8RCktMSxZPWs7O1k9ayl7dmFyIFo9KEs9QVtVKHIsaykmV10pPj4+NDtpZigoays9MTUmSyk+TSl7ZyYmVCgwKTticmVha31pZihLfHxUKDIpLFo8MjU2KWZbTysrXT1aO2Vsc2Uge2lmKDI1Nj09Wil7WT1rLEE9bnVsbDticmVha312YXIgJD1aLTI1NDtpZihaPjI2NCl7dmFyIHJyPWFbcT1aLTI1N107JD1MKHIsaywoMTw8cnIpLTEpK3ZbcV0says9cnI7fXZhciBlcj14W1UocixrKSZYXSxucj1lcj4+PjQ7ZXJ8fFQoMyksays9MTUmZXI7Uj1sW25yXTtpZihucj4zKXtycj1pW25yXTtSKz1VKHIsaykmKDE8PHJyKS0xLGsrPXJyO31pZihrPk0pe2cmJlQoMCk7YnJlYWt9YyYmZChPKzEzMTA3Mik7Zm9yKHZhciB0cj1PKyQ7Tzx0cjtPKz00KWZbT109ZltPLVJdLGZbTysxXT1mW08rMS1SXSxmW08rMl09ZltPKzItUl0sZltPKzNdPWZbTyszLVJdO089dHI7fX11Lmw9QSx1LnA9WSx1LmI9TyxBJiYobT0xLHUubT1FLHUuZD14LHUubj1EKTt9d2hpbGUoIW0pO3JldHVybiBPPT1mLmxlbmd0aD9mOmZ1bmN0aW9uKHIsYSxpKXsobnVsbD09YXx8YTwwKSYmKGE9MCksKG51bGw9PWl8fGk+ci5sZW5ndGgpJiYoaT1yLmxlbmd0aCk7dmFyIG89bmV3KHIgaW5zdGFuY2VvZiBuP246ciBpbnN0YW5jZW9mIHQ/dDplKShpLWEpO3JldHVybiBvLnNldChyLnN1YmFycmF5KGEsaSkpLG99KGYsMCxPKX0sQT1uZXcgZSgwKTt2YXIgeD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXImJm5ldyBUZXh0RGVjb2Rlcjt0cnl7eC5kZWNvZGUoQSx7c3RyZWFtOiEwfSksMTt9Y2F0Y2gocil7fXJldHVybiByLmNvbnZlcnRfc3RyZWFtcz1mdW5jdGlvbihyKXt2YXIgZT1uZXcgRGF0YVZpZXcociksbj0wO2Z1bmN0aW9uIHQoKXt2YXIgcj1lLmdldFVpbnQxNihuKTtyZXR1cm4gbis9MixyfWZ1bmN0aW9uIGEoKXt2YXIgcj1lLmdldFVpbnQzMihuKTtyZXR1cm4gbis9NCxyfWZ1bmN0aW9uIGkocil7bS5zZXRVaW50MTYoYixyKSxiKz0yO31mdW5jdGlvbiBvKHIpe20uc2V0VWludDMyKGIsciksYis9NDt9Zm9yKHZhciBmPXtzaWduYXR1cmU6YSgpLGZsYXZvcjphKCksbGVuZ3RoOmEoKSxudW1UYWJsZXM6dCgpLHJlc2VydmVkOnQoKSx0b3RhbFNmbnRTaXplOmEoKSxtYWpvclZlcnNpb246dCgpLG1pbm9yVmVyc2lvbjp0KCksbWV0YU9mZnNldDphKCksbWV0YUxlbmd0aDphKCksbWV0YU9yaWdMZW5ndGg6YSgpLHByaXZPZmZzZXQ6YSgpLHByaXZMZW5ndGg6YSgpfSx1PTA7TWF0aC5wb3coMix1KTw9Zi5udW1UYWJsZXM7KXUrKzt1LS07Zm9yKHZhciB2PTE2Kk1hdGgucG93KDIsdSkscz0xNipmLm51bVRhYmxlcy12LGw9MTIsYz1bXSxnPTA7ZzxmLm51bVRhYmxlcztnKyspYy5wdXNoKHt0YWc6YSgpLG9mZnNldDphKCksY29tcExlbmd0aDphKCksb3JpZ0xlbmd0aDphKCksb3JpZ0NoZWNrc3VtOmEoKX0pLGwrPTE2O3ZhciBoLHc9bmV3IFVpbnQ4QXJyYXkoMTIrMTYqYy5sZW5ndGgrYy5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHIrZS5vcmlnTGVuZ3RoKzR9KSwwKSksZD13LmJ1ZmZlcixtPW5ldyBEYXRhVmlldyhkKSxiPTA7cmV0dXJuIG8oZi5mbGF2b3IpLGkoZi5udW1UYWJsZXMpLGkodiksaSh1KSxpKHMpLGMuZm9yRWFjaCgoZnVuY3Rpb24ocil7byhyLnRhZyksbyhyLm9yaWdDaGVja3N1bSksbyhsKSxvKHIub3JpZ0xlbmd0aCksci5vdXRPZmZzZXQ9bCwobCs9ci5vcmlnTGVuZ3RoKSU0IT0wJiYobCs9NC1sJTQpO30pKSxjLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuLHQ9ci5zbGljZShlLm9mZnNldCxlLm9mZnNldCtlLmNvbXBMZW5ndGgpO2lmKGUuY29tcExlbmd0aCE9ZS5vcmlnTGVuZ3RoKXt2YXIgYT1uZXcgVWludDhBcnJheShlLm9yaWdMZW5ndGgpO249bmV3IFVpbnQ4QXJyYXkodCwyKSxPKG4sYSk7fWVsc2UgYT1uZXcgVWludDhBcnJheSh0KTt3LnNldChhLGUub3V0T2Zmc2V0KTt2YXIgaT0wOyhsPWUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCklNCE9MCYmKGk9NC1sJTQpLHcuc2V0KG5ldyBVaW50OEFycmF5KGkpLmJ1ZmZlcixlLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpLGg9bCtpO30pKSxkLnNsaWNlKDAsaCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5jb252ZXJ0X3N0cmVhbXN9XG5cbi8qKlxuICogQSBmYWN0b3J5IHdyYXBwZXIgcGFyc2luZyBhIGZvbnQgZmlsZSB1c2luZyBUeXByLlxuICogQWxzbyBhZGRzIHN1cHBvcnQgZm9yIFdPRkYgZmlsZXMgKG5vdCBXT0ZGMikuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICBjb25zdCBjbWRBcmdMZW5ndGhzID0ge1xuICAgIE06IDIsXG4gICAgTDogMixcbiAgICBROiA0LFxuICAgIEM6IDYsXG4gICAgWjogMFxuICB9O1xuXG4gIC8vIHtqb2luVHlwZTogXCJza2lwK3N0ZXAsLi4uXCJ9XG4gIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICBjb25zdCBKVF9MRUZUID0gMSwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICBKVF9SSUdIVCA9IDIsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfVFJBTlNQQVJFTlQgPSA4LCAvL2luZGljYXRlcyB0aGF0IHRoZSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIGFkamFjZW50IGNoYXJhY3RlcnMgYW5kIHRoYXQgdGhlIGNoYXJhY3RlciBtdXN0IGJlIHNraXBwZWQgb3ZlciB3aGVuIHRoZSBzaGFwaW5nIGVuZ2luZSBpcyBldmFsdWF0aW5nIHRoZSBqb2luaW5nIHBvc2l0aW9ucyBpbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuIFdoZW4gYSBKVF9UUkFOU1BBUkVOVCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gYSBzZXF1ZW5jZSwgdGhlIEpPSU5JTkdfVFlQRSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBwYXNzZXMgdGhyb3VnaC4gRGlhY3JpdGljYWwgbWFya3MgYXJlIGZyZXF1ZW50bHkgYXNzaWduZWQgdGhpcyB2YWx1ZS5cbiAgICBKVF9KT0lOX0NBVVNJTkcgPSAxNiwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGZvcmNlcyB0aGUgdXNlIG9mIGpvaW5pbmcgZm9ybXMgd2l0aCB0aGUgcHJlY2VkaW5nIGFuZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMuIEthc2hpZGFzIGFuZCB0aGUgWmVybyBXaWR0aCBKb2luZXIgKFUrMjAwRCkgYXJlIGJvdGggSk9JTl9DQVVTSU5HIGNoYXJhY3RlcnMuXG4gICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgbGV0IGpvaW5pbmdUeXBlTWFwO1xuICBmdW5jdGlvbiBnZXRDaGFySm9pbmluZ1R5cGUoY2gpIHtcbiAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBSOiBKVF9SSUdIVCxcbiAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgRDogSlRfRFVBTCxcbiAgICAgICAgQzogSlRfSk9JTl9DQVVTSU5HLFxuICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgVDogSlRfVFJBTlNQQVJFTlRcbiAgICAgIH07XG4gICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gam9pbmluZ1R5cGVSYXdEYXRhKSB7XG4gICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGxldCBbc2tpcCwgc3RlcF0gPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLDM2KTtcbiAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIG1bdHlwZV0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwOyBpLS07KSB7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpvaW5pbmdUeXBlTWFwLmdldChjaCkgfHwgSlRfTk9OX0pPSU5JTkdcbiAgfVxuXG4gIGNvbnN0IElTT0wgPSAxLCBJTklUID0gMiwgRklOQSA9IDMsIE1FREkgPSA0O1xuICBjb25zdCBmb3Jtc1RvRmVhdHVyZXMgPSBbbnVsbCwgJ2lzb2wnLCAnaW5pdCcsICdmaW5hJywgJ21lZGknXTtcblxuICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL244d2lsbGlzL29wZW50eXBlLXNoYXBpbmctZG9jdW1lbnRzL2Jsb2IvbWFzdGVyL29wZW50eXBlLXNoYXBpbmctYXJhYmljLWdlbmVyYWwubWRcbiAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICBsZXQgcHJldkpvaW5pbmdUeXBlID0gSlRfTk9OX0pPSU5JTkc7XG4gICAgbGV0IHByZXZGb3JtID0gSVNPTDtcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgbGV0IGZvcm0gPSBJU09MO1xuICAgICAgaWYgKGpvaW5pbmdUeXBlICYgSlRfVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgZm9ybSA9IEZJTkE7XG4gICAgICAgICAgLy8gaXNvbC0+aW5pdCwgZmluYS0+bWVkaVxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoam9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX05PTl9KT0lOSU5HKSkge1xuICAgICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2Rm9ybSA9IGpvaW5pbmdGb3Jtc1tpXSA9IGZvcm07XG4gICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgICBpZiAoY29kZSA+IDB4ZmZmZikgaSsrO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBjaC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikpKVxuICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGdldENoYXJKb2luaW5nVHlwZShjaC5jb2RlUG9pbnRBdCgwKSkpKVxuICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICByZXR1cm4gam9pbmluZ0Zvcm1zXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgY29uc3QgZ2x5cGhJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBpZiAoY2MgPiAweGZmZmYpIGkrKztcbiAgICAgIGdseXBoSWRzLnB1c2goVHlwci5VLmNvZGVUb0dseXBoKGZvbnQsIGNjKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3N1YiA9IGZvbnRbJ0dTVUInXTtcbiAgICBpZiAoZ3N1Yikge1xuICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICBsZXQgam9pbmluZ0Zvcm1zO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSAvXihybGlnfGxpZ2F8bXNldHxpc29sfGluaXR8ZmluYXxtZWRpfGhhbGZ8cHJlc3xibHdzKSQvO1xuICAgICAgY29uc3QgdXNlZExvb2t1cHMgPSBbXTtcbiAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgIGlmIChzdXBwb3J0ZWRGZWF0dXJlcy50ZXN0KGZlYXR1cmUudGFnKSkge1xuICAgICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBmZWF0dXJlLnRhYi5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgIGlmICh1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dKSBjb250aW51ZVxuICAgICAgICAgICAgdXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXBMaXN0W2ZlYXR1cmUudGFiW3RpXV07XG4gICAgICAgICAgICBjb25zdCBpc0pvaW5pbmdGZWF0dXJlID0gL14oaXNvbHxpbml0fGZpbmF8bWVkaSkkLy50ZXN0KGZlYXR1cmUudGFnKTtcbiAgICAgICAgICAgIGlmIChpc0pvaW5pbmdGZWF0dXJlICYmICFqb2luaW5nRm9ybXMpIHsgLy9sYXp5XG4gICAgICAgICAgICAgIGpvaW5pbmdGb3JtcyA9IGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGdseXBoSWRzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBpZiAoIWpvaW5pbmdGb3JtcyB8fCAhaXNKb2luaW5nRmVhdHVyZSB8fCBmb3Jtc1RvRmVhdHVyZXNbam9pbmluZ0Zvcm1zW2NpXV0gPT09IGZlYXR1cmUudGFnKSB7XG4gICAgICAgICAgICAgICAgVHlwci5VLl9hcHBseVN1YnMoZ2x5cGhJZHMsIGNpLCB0YWIsIGxvb2t1cExpc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhJZHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0TnVtKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRm9udE9iaih0eXByRm9udCkge1xuICAgIGNvbnN0IGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGNvbnN0IG9zMiA9IHR5cHJGb250WydPUy8yJ107XG4gICAgY29uc3QgaGhlYSA9IHR5cHJGb250LmhoZWE7XG4gICAgY29uc3QgdW5pdHNQZXJFbSA9IHR5cHJGb250LmhlYWQudW5pdHNQZXJFbTtcbiAgICBjb25zdCBhc2NlbmRlciA9IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9Bc2NlbmRlciwgaGhlYSAmJiBoaGVhLmFzY2VuZGVyLCB1bml0c1BlckVtKTtcblxuICAgIGNvbnN0IGZvbnRPYmogPSB7XG4gICAgICB1bml0c1BlckVtLFxuICAgICAgYXNjZW5kZXIsXG4gICAgICBkZXNjZW5kZXI6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9EZXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5kZXNjZW5kZXIsIDApLFxuICAgICAgY2FwSGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnNDYXBIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIHhIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc3hIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIGxpbmVHYXA6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9MaW5lR2FwLCBoaGVhICYmIGhoZWEubGluZUdhcCksXG4gICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBnbHlwaFggPSAwO1xuICAgICAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gZm9udE9iai51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICAgICAgY29uc3QgZ2x5cGhJbmRpY2VzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgbGV0IHByZXZHbHlwaEluZGV4ID0gLTE7XG4gICAgICAgIGdseXBoSW5kaWNlcy5mb3JFYWNoKChnbHlwaEluZGV4LCBpKSA9PiB7XG4gICAgICAgICAgLy8gVHlwciByZXR1cm5zIGEgZ2x5cGggaW5kZXggcGVyIHN0cmluZyBjb2RlcG9pbnQsIHdpdGggLTFzIGluIHBsYWNlIG9mIHRob3NlIHRoYXRcbiAgICAgICAgICAvLyB3ZXJlIG9taXR0ZWQgZHVlIHRvIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbi4gU28gd2UgY2FuIHRyYWNrIG9yaWdpbmFsIGluZGV4IGluIHRoZVxuICAgICAgICAgIC8vIHN0cmluZyB2aWEgc2ltcGxlIGluY3JlbWVudCwgYW5kIHNraXAgZXZlcnl0aGluZyBlbHNlIHdoZW4gc2VlaW5nIGEgLTEuXG4gICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIGlmICghZ2x5cGhPYmopIHtcbiAgICAgICAgICAgICAgY29uc3Qge2NtZHMsIGNyZHN9ID0gVHlwci5VLmdseXBoVG9QYXRoKHR5cHJGb250LCBnbHlwaEluZGV4KTtcblxuICAgICAgICAgICAgICAvLyBCdWlsZCBwYXRoIHN0cmluZ1xuICAgICAgICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgY3Jkc0lkeCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjbWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV07XG4gICAgICAgICAgICAgICAgcGF0aCArPSBjbWRzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IG51bUFyZ3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgcGF0aCArPSAoaiA+IDEgPyAnLCcgOiAnJykgKyBjcmRzW2NyZHNJZHgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmluZCBleHRlbnRzIC0gR2x5ZiBnaXZlcyB0aGlzIGluIG1ldGFkYXRhIGJ1dCBub3QgQ0ZGLCBhbmQgVHlwciBkb2Vzbid0XG4gICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdHdvLCBzbyBpdCdzIHNpbXBsZXN0IGp1c3QgdG8gaXRlcmF0ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgIGxldCB4TWluLCB5TWluLCB4TWF4LCB5TWF4O1xuICAgICAgICAgICAgICBpZiAoY3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4TWluID0geU1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHhNYXggPSB5TWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeCA9IGNyZHNbaV07XG4gICAgICAgICAgICAgICAgICBsZXQgeSA9IGNyZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgICAgICAgICAgICAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggPSB5TWluID0geU1heCA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBnbHlwaEluZGV4LFxuICAgICAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogdHlwckZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJbmRleF0sXG4gICAgICAgICAgICAgICAgeE1pbixcbiAgICAgICAgICAgICAgICB5TWluLFxuICAgICAgICAgICAgICAgIHhNYXgsXG4gICAgICAgICAgICAgICAgeU1heCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IGNtZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC8vIGZvckVhY2hQYXRoQ29tbWFuZChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vICAgbGV0IGFyZ3NJbmRleCA9IDBcbiAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGFyZ3NBcnJheSA9IFtdXG4gICAgICAgICAgICAgICAgLy8gICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXVxuICAgICAgICAgICAgICAgIC8vICAgICBhcmdzQXJyYXkubGVuZ3RoID0gMSArIG51bUFyZ3NcbiAgICAgICAgICAgICAgICAvLyAgICAgYXJnc0FycmF5WzBdID0gY21kc1tpXVxuICAgICAgICAgICAgICAgIC8vICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICBhcmdzQXJyYXlbal0gPSBjcmRzW2FyZ3NJbmRleCsrXVxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3NBcnJheSlcbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEtlcm5pbmdcbiAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZ2x5cGhYICs9IFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudCh0eXByRm9udCwgcHJldkdseXBoSW5kZXgsIGdseXBoSW5kZXgpICogZm9udFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGdseXBoT2JqLCBnbHlwaFgsIGNoYXJJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChnbHlwaE9iai5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgICAgZ2x5cGhYICs9IGdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIGdseXBoWCArPSBsZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZHbHlwaEluZGV4ID0gZ2x5cGhJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhckluZGV4ICs9ICh0ZXh0LmNvZGVQb2ludEF0KGNoYXJJbmRleCkgPiAweGZmZmYgPyAyIDogMSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2x5cGhYXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmb250T2JqXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGFyc2UoYnVmZmVyKSB7XG4gICAgLy8gTG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIFdPRkYgZmlsZSBhbmQgY29udmVydCBpdCBpZiBzbzpcbiAgICBjb25zdCBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICBjb25zdCB0YWcgPSBUeXByLl9iaW4ucmVhZEFTQ0lJKHBlZWssIDAsIDQpO1xuICAgIGlmICh0YWcgPT09ICd3T0ZGJykge1xuICAgICAgYnVmZmVyID0gd29mZjJvdGYoYnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3dPRjInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvZmYyIGZvbnRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbiAgICByZXR1cm4gd3JhcEZvbnRPYmooVHlwci5wYXJzZShidWZmZXIpWzBdKVxuICB9XG59XG5cblxuY29uc3Qgd29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXByIEZvbnQgUGFyc2VyJyxcbiAgZGVwZW5kZW5jaWVzOiBbdHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeV0sXG4gIGluaXQodHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeSkge1xuICAgIGNvbnN0IFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgIGNvbnN0IHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgcmV0dXJuIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpXG4gIH1cbn0pO1xuXG5jb25zdCBDT05GSUcgPSB7XG4gIGRlZmF1bHRGb250VVJMOiAnaHR0cHM6Ly9mb250cy5nc3RhdGljLmNvbS9zL3JvYm90by92MTgvS0ZPbUNucUV1OTJGcjFNdTRteE0ud29mZicsIC8vUm9ib3RvIFJlZ3VsYXJcbiAgc2RmR2x5cGhTaXplOiA2NCxcbiAgc2RmTWFyZ2luOiAxIC8gMTYsXG4gIHNkZkV4cG9uZW50OiA5LFxuICB0ZXh0dXJlV2lkdGg6IDIwNDhcbn07XG5jb25zdCB0ZW1wQ29sb3IgPSAvKiNfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5sZXQgaGFzUmVxdWVzdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG5vdyQxKCkge1xuICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbn1cblxuLyoqXG4gKiBDdXN0b21pemVzIHRoZSB0ZXh0IGJ1aWxkZXIgY29uZmlndXJhdGlvbi4gVGhpcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byB0aGUgZmlyc3QgZm9udCBwcm9jZXNzaW5nXG4gKiByZXF1ZXN0LCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWZhdWx0Rm9udFVSTCAtIFRoZSBVUkwgb2YgdGhlIGRlZmF1bHQgZm9udCB0byB1c2UgZm9yIHRleHQgcHJvY2Vzc2luZ1xuICogICAgICAgICAgICAgICAgIHJlcXVlc3RzLCBpbiBjYXNlIG5vbmUgaXMgc3BlY2lmaWVkIG9yIHRoZSBzcGVjaWZpZWRlIGZvbnQgZmFpbHMgdG8gbG9hZCBvciBwYXJzZS5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBcIlJvYm90byBSZWd1bGFyXCIgZnJvbSBHb29nbGUgRm9udHMuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICogICAgICAgICAgICAgICAgIHRleHR1cmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBNdXN0IGJlIGEgcG93ZXItb2YtdHdvIG51bWJlciwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLFxuICogICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhpcyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIHBlciBjYWxsIHRvIGBnZXRUZXh0UmVuZGVySW5mbygpYC5cbiAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICogICAgICAgICAgICAgICAgIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeS4gRGVmYXVsdHNcbiAqICAgICAgICAgICAgICAgICB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICogICAgICAgICAgICAgICAgIHNoaWZ0cyB0aGUgZW5jb2RlZCA4LWJpdCB2YWx1ZXMgdG8gYWNoaWV2ZSBoaWdoZXIgcHJlY2lzaW9uL2FjY3VyYWN5IGF0IHRleGVscyBuZWFyZXJcbiAqICAgICAgICAgICAgICAgICB0aGUgZ2x5cGgncyBwYXRoLCB3aXRoIGxvd2VyIHByZWNpc2lvbiBmdXJ0aGVyIGF3YXkuIERlZmF1bHRzIHRvIDkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICogICAgICAgICAgICAgICAgIHBhdGgsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgU0RGIHdpZHRoLiBBIGxhcmdlciBtYXJnaW4gaW5jcmVhc2VzIHRoZSBxdWFsaXR5IG9mXG4gKiAgICAgICAgICAgICAgICAgZXh0cnVkZWQgZ2x5cGggb3V0bGluZXMsIGJ1dCBkZWNyZWFzZXMgdGhlIHByZWNpc2lvbiBhdmFpbGFibGUgZm9yIHRoZSBnbHlwaCBpdHNlbGYuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50ZXh0dXJlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIFNERiB0ZXh0dXJlOyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gRGVmYXVsdHMgdG9cbiAqICAgICAgICAgICAgICAgICAyMDQ4IHdoaWNoIGlzIGEgc2FmZSBtYXhpbXVtIHRleHR1cmUgZGltZW5zaW9uIGFjY29yZGluZyB0byB0aGUgc3RhdHMgYXRcbiAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAqICAgICAgICAgICAgICAgICByZWFzb25hYmx5IGxhcmdlIG51bWJlciBvZiBnbHlwaHMgKGRlZmF1bHQgZ2x5cGggc2l6ZSBvZiA2NF4yIGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICogICAgICAgICAgICAgICAgIDIwNDheMiwgdGltZXMgNCBjaGFubmVscywgYWxsb3dzIGZvciA0MDk2IGdseXBocy4pIFRoaXMgY2FuIGJlIGluY3JlYXNlZCBpZiB5b3UgbmVlZCB0b1xuICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gIGlmIChoYXNSZXF1ZXN0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ2NvbmZpZ3VyZVRleHRCdWlsZGVyIGNhbGxlZCBhZnRlciBmaXJzdCBmb250IHJlcXVlc3Q7IHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24oQ09ORklHLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzIGFuZCB0aGVpciBnbHlwaCBtYXBwaW5ncy4gVGhlcmUgaXMgYSBzZXBhcmF0ZSBhdGxhcyBmb3JcbiAqIGVhY2ggc2RmR2x5cGhTaXplLiBFYWNoIGF0bGFzIGhhcyBhIHNpbmdsZSBUZXh0dXJlIHRoYXQgaG9sZHMgYWxsIGdseXBocyBmb3IgYWxsIGZvbnRzLlxuICpcbiAqICAge1xuICogICAgIFtzZGZHbHlwaFNpemVdOiB7XG4gKiAgICAgICBnbHlwaENvdW50OiBudW1iZXIsXG4gKiAgICAgICBzZGZHbHlwaFNpemU6IG51bWJlcixcbiAqICAgICAgIHNkZlRleHR1cmU6IFRleHR1cmUsXG4gKiAgICAgICBzZGZDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICogICAgICAgY29udGV4dExvc3Q6IGJvb2xlYW4sXG4gKiAgICAgICBnbHlwaHNCeUZvbnQ6IE1hcDxmb250VVJMLCBNYXA8Z2x5cGhJRCwge3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9Pj5cbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuY29uc3QgYXRsYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJvaWthVGV4dFJlbmRlckluZm8gLSBGb3JtYXQgb2YgdGhlIHJlc3VsdCBmcm9tIGBnZXRUZXh0UmVuZGVySW5mb2AuXG4gKiBAcHJvcGVydHkge29iamVjdH0gcGFyYW1ldGVycyAtIFRoZSBub3JtYWxpemVkIGlucHV0IGFyZ3VtZW50cyB0byB0aGUgcmVuZGVyIGNhbGwuXG4gKiBAcHJvcGVydHkge1RleHR1cmV9IHNkZlRleHR1cmUgLSBUaGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERjsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCBpbiBlbmNvZGluZyB0aGUgU0RGJ3MgdmFsdWVzOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBpbmRleCBpbiB0aGUgU0RGIGF0bGFzLlxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBbciwgZywgYl0gY29sb3IsIGlmIGBjb2xvclJhbmdlc2Agd2FzIHN1cHBsaWVkLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nOyBlYWNoIGlzXG4gKiAgICAgICAgICAgdGhyZWUgZWxlbWVudHM6IHRoZSBzdGFydGluZyBYLCB0aGUgZW5kaW5nIFgsIGFuZCB0aGUgYm90dG9tIFkgZm9yIHRoZSBjYXJldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FyZXRIZWlnaHRdIC0gQW4gYXBwcm9wcmlhdGUgaGVpZ2h0IGZvciBhbGwgc2VsZWN0aW9uIGNhcmV0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlciAtIFRoZSBmb250J3MgYXNjZW5kZXIgbWV0cmljLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlciAtIFRoZSBmb250J3MgZGVzY2VuZGVyIG1ldHJpYy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBIZWlnaHQgLSBUaGUgZm9udCdzIGNhcCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGNhcGl0YWwgbGV0dGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0IC0gVGhlIGZvbnQncyB4IGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gbG93ZXJjYXNlIGxldHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZUhlaWdodCAtIFRoZSBmaW5hbCBjb21wdXRlZCBsaW5lSGVpZ2h0IG1lYXN1cmVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcEJhc2VsaW5lIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGJsb2NrQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICogICAgICAgICAgIHRoaXMgY2FuIGluY2x1ZGUgZXh0cmEgdmVydGljYWwgc3BhY2UgYmV5b25kIHRoZSB2aXNpYmxlIGdseXBocyBkdWUgdG8gbGluZUhlaWdodCwgYW5kIGlzXG4gKiAgICAgICAgICAgZXF1aXZhbGVudCB0byB0aGUgZGltZW5zaW9ucyBvZiBhIGJsb2NrLWxldmVsIHRleHQgZWxlbWVudCBpbiBDU1MuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpc2libGVCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gKiAgICAgICAgICAgdW5saWtlIGBibG9ja0JvdW5kc2AgdGhpcyBpcyB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIHZpc2libGUgZ2x5cGggcGF0aHMuXG4gKiBAcHJvcGVydHkge0FycmF5PG9iamVjdD59IGNodW5rZWRCb3VuZHMgLSBMaXN0IG9mIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNvbnNlY3V0aXZlIHNldCBvZiBOIGdseXBocyxcbiAqICAgICAgICAgICBpbiB0aGUgZm9ybWF0IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdGltaW5ncyAtIFRpbWluZyBpbmZvIGZvciB2YXJpb3VzIHBhcnRzIG9mIHRoZSByZW5kZXJpbmcgbG9naWMgaW5jbHVkaW5nIFNERlxuICogICAgICAgICAgIGdlbmVyYXRpb24sIHR5cGVzZXR0aW5nLCBldGMuXG4gKiBAZnJvemVuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciByZXF1ZXN0aW5nIHRoZSBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgcGFyYW1ldGVycy5cbiAqIFRoaXMgaXMgYW4gYXN5bmNocm9ub3VzIGNhbGwsIHBlcmZvcm1pbmcgbW9zdCBvZiB0aGUgbG9naWMgaW4gYSB3ZWIgd29ya2VyIHRocmVhZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2dldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICBoYXNSZXF1ZXN0ZWQgPSB0cnVlO1xuICBhcmdzID0gYXNzaWduKHt9LCBhcmdzKTtcbiAgY29uc3QgdG90YWxTdGFydCA9IG5vdyQxKCk7XG5cbiAgLy8gQXBwbHkgZGVmYXVsdCBmb250IGhlcmUgdG8gYXZvaWQgYSAnbnVsbCcgYXRsYXMsIGFuZCBjb252ZXJ0IHJlbGF0aXZlXG4gIC8vIFVSTHMgdG8gYWJzb2x1dGUgc28gdGhleSBjYW4gYmUgcmVzb2x2ZWQgaW4gdGhlIHdvcmtlclxuICBhcmdzLmZvbnQgPSB0b0Fic29sdXRlVVJMKGFyZ3MuZm9udCB8fCBDT05GSUcuZGVmYXVsdEZvbnRVUkwpO1xuXG4gIC8vIE5vcm1hbGl6ZSB0ZXh0IHRvIGEgc3RyaW5nXG4gIGFyZ3MudGV4dCA9ICcnICsgYXJncy50ZXh0O1xuXG4gIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcblxuICAvLyBOb3JtYWxpemUgY29sb3JzXG4gIGlmIChhcmdzLmNvbG9yUmFuZ2VzICE9IG51bGwpIHtcbiAgICBsZXQgY29sb3JzID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3MuY29sb3JSYW5nZXMpIHtcbiAgICAgIGlmIChhcmdzLmNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbGV0IHZhbCA9IGFyZ3MuY29sb3JSYW5nZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsID0gdGVtcENvbG9yLnNldCh2YWwpLmdldEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBhcmdzLmNvbG9yUmFuZ2VzID0gY29sb3JzO1xuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShhcmdzKTtcblxuICAvLyBJbml0IHRoZSBhdGxhcyBpZiBuZWVkZWRcbiAgY29uc3Qge3RleHR1cmVXaWR0aCwgc2RmRXhwb25lbnR9ID0gQ09ORklHO1xuICBjb25zdCB7c2RmR2x5cGhTaXplfSA9IGFyZ3M7XG4gIGNvbnN0IGdseXBoc1BlclJvdyA9ICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUgKiA0KTtcbiAgbGV0IGF0bGFzID0gYXRsYXNlc1tzZGZHbHlwaFNpemVdO1xuICBpZiAoIWF0bGFzKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzZGZHbHlwaFNpemUgKiAyNTYgLyBnbHlwaHNQZXJSb3c7IC8vIHN0YXJ0IHRhbGwgZW5vdWdoIHRvIGZpdCAyNTYgZ2x5cGhzXG4gICAgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV0gPSB7XG4gICAgICBnbHlwaENvdW50OiAwLFxuICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgc2RmQ2FudmFzOiBjYW52YXMsXG4gICAgICBzZGZUZXh0dXJlOiBuZXcgVGV4dHVyZShcbiAgICAgICAgY2FudmFzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIExpbmVhckZpbHRlclxuICAgICAgKSxcbiAgICAgIGNvbnRleHRMb3N0OiBmYWxzZSxcbiAgICAgIGdseXBoc0J5Rm9udDogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBhdGxhcy5zZGZUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKTtcbiAgfVxuXG4gIGNvbnN0IHtzZGZUZXh0dXJlLCBzZGZDYW52YXN9ID0gYXRsYXM7XG4gIGxldCBmb250R2x5cGhzID0gYXRsYXMuZ2x5cGhzQnlGb250LmdldChhcmdzLmZvbnQpO1xuICBpZiAoIWZvbnRHbHlwaHMpIHtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuc2V0KGFyZ3MuZm9udCwgZm9udEdseXBocyA9IG5ldyBNYXAoKSk7XG4gIH1cblxuICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICB0eXBlc2V0SW5Xb3JrZXIoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgIGNvbnN0IHtnbHlwaElkcywgZ2x5cGhQb3NpdGlvbnMsIGZvbnRTaXplLCB1bml0c1BlckVtLCB0aW1pbmdzfSA9IHJlc3VsdDtcbiAgICBjb25zdCBuZWVkZWRTREZzID0gW107XG4gICAgY29uc3QgZ2x5cGhCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBoSWRzLmxlbmd0aCAqIDQpO1xuICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICBsZXQgYm91bmRzSWR4ID0gMDtcbiAgICBsZXQgcG9zaXRpb25zSWR4ID0gMDtcbiAgICBjb25zdCBxdWFkc1N0YXJ0ID0gbm93JDEoKTtcbiAgICBnbHlwaElkcy5mb3JFYWNoKChnbHlwaElkLCBpKSA9PiB7XG4gICAgICBsZXQgZ2x5cGhJbmZvID0gZm9udEdseXBocy5nZXQoZ2x5cGhJZCk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBnbHlwaElkIG5vdCBzZWVuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBhdGxhc1xuICAgICAgaWYgKCFnbHlwaEluZm8pIHtcbiAgICAgICAgY29uc3Qge3BhdGgsIHBhdGhCb3VuZHN9ID0gcmVzdWx0LmdseXBoRGF0YVtnbHlwaElkXTtcblxuICAgICAgICAvLyBNYXJnaW4gYXJvdW5kIHBhdGggZWRnZXMgaW4gU0RGLCBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGdseXBoJ3MgbWF4IGRpbWVuc2lvbi5cbiAgICAgICAgLy8gTm90ZSB3ZSBhZGQgYW4gZXh0cmEgMC41IHB4IG92ZXIgdGhlIGNvbmZpZ3VyZWQgdmFsdWUgYmVjYXVzZSB0aGUgb3V0ZXIgMC41IGRvZXNuJ3QgY29udGFpblxuICAgICAgICAvLyB1c2VmdWwgaW50ZXJwb2xhdGVkIHZhbHVlcyBhbmQgd2lsbCBiZSBpZ25vcmVkIGFueXdheS5cbiAgICAgICAgY29uc3QgZm9udFVuaXRzTWFyZ2luID0gTWF0aC5tYXgocGF0aEJvdW5kc1syXSAtIHBhdGhCb3VuZHNbMF0sIHBhdGhCb3VuZHNbM10gLSBwYXRoQm91bmRzWzFdKVxuICAgICAgICAgIC8gc2RmR2x5cGhTaXplICogKENPTkZJRy5zZGZNYXJnaW4gKiBzZGZHbHlwaFNpemUgKyAwLjUpO1xuXG4gICAgICAgIGNvbnN0IGF0bGFzSW5kZXggPSBhdGxhcy5nbHlwaENvdW50Kys7XG4gICAgICAgIGNvbnN0IHNkZlZpZXdCb3ggPSBbXG4gICAgICAgICAgcGF0aEJvdW5kc1swXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzFdIC0gZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbMl0gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1szXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgXTtcbiAgICAgICAgZm9udEdseXBocy5zZXQoZ2x5cGhJZCwgKGdseXBoSW5mbyA9IHsgcGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveCB9KSk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0aG9zZSB0aGF0IG5lZWQgU0RGIGdlbmVyYXRpb25cbiAgICAgICAgbmVlZGVkU0RGcy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgZm9yIHJlbmRlcmFibGUgcXVhZHNcbiAgICAgIC8vIFRPRE8gY2FuIHdlIGdldCB0aGlzIGJhY2sgb2ZmIHRoZSBtYWluIHRocmVhZD9cbiAgICAgIGNvbnN0IHtzZGZWaWV3Qm94fSA9IGdseXBoSW5mbztcbiAgICAgIGNvbnN0IHBvc1ggPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICBjb25zdCBwb3NZID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMF0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzJdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbM10gKiBmb250U2l6ZU11bHQ7XG5cbiAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgIGdseXBoSWRzW2ldID0gZ2x5cGhJbmZvLmF0bGFzSW5kZXg7XG4gICAgfSk7XG4gICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgIGNvbnN0IHNkZlN0YXJ0ID0gbm93JDEoKTtcbiAgICB0aW1pbmdzLnNkZiA9IHt9O1xuXG4gICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gc2RmQ2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBuZWVkZWRSb3dzID0gTWF0aC5jZWlsKGF0bGFzLmdseXBoQ291bnQgLyBnbHlwaHNQZXJSb3cpO1xuICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xuICAgICAgLy8gU2luY2UgcmVzaXppbmcgdGhlIGNhbnZhcyBjbGVhcnMgaXRzIHJlbmRlciBidWZmZXIsIGl0IG5lZWRzIHNwZWNpYWwgaGFuZGxpbmcgdG8gY29weSB0aGUgb2xkIGNvbnRlbnRzIG92ZXJcbiAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoc2RmQ2FudmFzLCB0ZXh0dXJlV2lkdGgsIG5lZWRlZEhlaWdodCk7XG4gICAgICAvLyBBcyBvZiBUaHJlZSByMTM2IHRleHR1cmVzIGNhbm5vdCBiZSByZXNpemVkIG9uY2UgdGhleSdyZSBhbGxvY2F0ZWQgb24gdGhlIEdQVSwgd2UgbXVzdCBkaXNwb3NlIHRvIHJlYWxsb2NhdGUgaXRcbiAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIFByb21pc2UuYWxsKG5lZWRlZFNERnMubWFwKGdseXBoSW5mbyA9PlxuICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgIHRpbWluZ3Muc2RmW2dseXBoSW5mby5hdGxhc0luZGV4XSA9IHRpbWluZztcbiAgICAgIH0pXG4gICAgKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAobmVlZGVkU0RGcy5sZW5ndGggJiYgIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGltaW5ncy5zZGZUb3RhbCA9IG5vdyQxKCkgLSBzZGZTdGFydDtcbiAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBTREYgLSAke3RpbWluZ3Muc2RmVG90YWx9LCBUb3RhbCAtICR7dGltaW5ncy50b3RhbCAtIHRpbWluZ3MuZm9udExvYWR9YClcblxuICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIHdpdGggdGhlIHRleHQgbGF5b3V0IGFycmF5cyBhbmQgdXBkYXRlZCB0ZXh0dXJlXG4gICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGFyYW1ldGVyczogYXJncyxcbiAgICAgICAgc2RmVGV4dHVyZSxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgZ2x5cGhCb3VuZHMsXG4gICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgZ2x5cGhDb2xvcnM6IHJlc3VsdC5nbHlwaENvbG9ycyxcbiAgICAgICAgY2FyZXRQb3NpdGlvbnM6IHJlc3VsdC5jYXJldFBvc2l0aW9ucyxcbiAgICAgICAgY2FyZXRIZWlnaHQ6IHJlc3VsdC5jYXJldEhlaWdodCxcbiAgICAgICAgY2h1bmtlZEJvdW5kczogcmVzdWx0LmNodW5rZWRCb3VuZHMsXG4gICAgICAgIGFzY2VuZGVyOiByZXN1bHQuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogcmVzdWx0LmRlc2NlbmRlcixcbiAgICAgICAgbGluZUhlaWdodDogcmVzdWx0LmxpbmVIZWlnaHQsXG4gICAgICAgIGNhcEhlaWdodDogcmVzdWx0LmNhcEhlaWdodCxcbiAgICAgICAgeEhlaWdodDogcmVzdWx0LnhIZWlnaHQsXG4gICAgICAgIHRvcEJhc2VsaW5lOiByZXN1bHQudG9wQmFzZWxpbmUsXG4gICAgICAgIGJsb2NrQm91bmRzOiByZXN1bHQuYmxvY2tCb3VuZHMsXG4gICAgICAgIHZpc2libGVCb3VuZHM6IHJlc3VsdC52aXNpYmxlQm91bmRzLFxuICAgICAgICB0aW1pbmdzOiByZXN1bHQudGltaW5ncyxcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2hpbGUgdGhlIHR5cGVzZXR0aW5nIHJlcXVlc3QgaXMgYmVpbmcgaGFuZGxlZCwgZ28gYWhlYWQgYW5kIG1ha2Ugc3VyZSB0aGUgYXRsYXMgY2FudmFzIGNvbnRleHQgaXNcbiAgLy8gXCJ3YXJtZWQgdXBcIjsgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSB0aGUgbG9uZ2VzdCBkdWUgdG8gc2hhZGVyIHByb2dyYW0gY29tcGlsYXRpb24gc28gdGhpcyBnZXRzXG4gIC8vIGEgaGVhZCBzdGFydCBvbiB0aGF0IHByb2Nlc3MgYmVmb3JlIFNERnMgYWN0dWFsbHkgc3RhcnQgZ2V0dGluZyBwcm9jZXNzZWQuXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmICghYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgIHdhcm1VcFNERkNhbnZhcyhzZGZDYW52YXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR2x5cGhTREYoe3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9LCB7c2RmR2x5cGhTaXplLCBzZGZDYW52YXMsIGNvbnRleHRMb3N0fSwgdXNlR1BVKSB7XG4gIGlmIChjb250ZXh0TG9zdCkge1xuICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIGxvc3QgdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbywganVzdCBxdWl0IHNpbGVudGx5IGFuZCBsZXQgaXRcbiAgICAvLyBnZXQgcmVnZW5lcmF0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyByZXN0b3JlZFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3RpbWluZzogLTF9KVxuICB9XG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KHNkZlZpZXdCb3hbMl0gLSBzZGZWaWV3Qm94WzBdLCBzZGZWaWV3Qm94WzNdIC0gc2RmVmlld0JveFsxXSk7XG4gIGNvbnN0IHNxdWFyZUluZGV4ID0gTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gNCk7XG4gIGNvbnN0IHggPSBzcXVhcmVJbmRleCAlICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpICogc2RmR2x5cGhTaXplO1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcihzcXVhcmVJbmRleCAvICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgY2hhbm5lbCA9IGF0bGFzSW5kZXggJSA0O1xuICByZXR1cm4gZ2VuZXJhdGVTREYoc2RmR2x5cGhTaXplLCBzZGZHbHlwaFNpemUsIHBhdGgsIHNkZlZpZXdCb3gsIG1heERpc3QsIHNkZkV4cG9uZW50LCBzZGZDYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZUdQVSlcbn1cblxuZnVuY3Rpb24gaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpIHtcbiAgY29uc3QgY2FudmFzID0gYXRsYXMuc2RmQ2FudmFzO1xuXG4gIC8qXG4gIC8vIEJlZ2luIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gIGlmICghd2luZG93LldlYkdMRGVidWdVdGlscykge1xuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2ViR0xEZWJ1Z1V0aWxzU2NyaXB0JylcbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdC5pZCA9ICdXZWJHTERlYnVnVXRpbHMnXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tocm9ub3NHcm91cC9XZWJHTERldmVsb3BlclRvb2xzQGI0MmU3MDIvc3JjL2RlYnVnL3dlYmdsLWRlYnVnLmpzJ1xuICAgIH1cbiAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ2FudmFzKGNhbnZhcylcbiAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwKVxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDAwKVxuICB9KVxuICAvLyBFbmQgY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgKi9cblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IExvc3QnLCBldmVudCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IHRydWU7XG4gIH0pO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBSZXN0b3JlZCcsIGV2ZW50KTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGdseXBocyBpbnRvIHRoZSByZXN0b3JlZCBjYW52YXM6XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuZm9yRWFjaChnbHlwaE1hcCA9PiB7XG4gICAgICBnbHlwaE1hcC5mb3JFYWNoKGdseXBoID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChnZW5lcmF0ZUdseXBoU0RGKGdseXBoLCBhdGxhcywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkIGEgZ2l2ZW4gZm9udCBhbmQgb3B0aW9uYWxseSBwcmUtZ2VuZXJhdGUgZ2x5cGggU0RGcyBmb3Igb25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCBsb25nIHBhdXNlcyB3aGVuIGZpcnN0IHNob3dpbmcgdGV4dCBpbiBhIHNjZW5lLCBieSBwcmVsb2FkaW5nIHRoZVxuICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICogICAgICAgIGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLmNoYXJhY3RlcnMgLSBPbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIGZvciB3aGljaCB0byBwcmUtXG4gKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICogICAgICAgIHRvIHNwZWNpZnkgbGlnYXR1cmUgc2VxdWVuY2VzIGluIGFkZGl0aW9uIHRvIHRoZWlyIGluZGl2aWR1YWwgY2hhcmFjdGVycyB0byBnZXQgYWxsXG4gKiAgICAgICAgcG9zc2libGUgZ2x5cGhzLCBlLmcuIGBbXCJ0XCIsIFwiaFwiLCBcInRoXCJdYCB0byBnZXQgdGhlIFwidFwiIGFuZCBcImhcIiBnbHlwaHMgcGx1cyB0aGUgXCJ0aFwiIGxpZ2F0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICogICAgICAgIHNwZWNpZmllZCBgY2hhcmFjdGVyc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwcmVsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICovXG5mdW5jdGlvbiBwcmVsb2FkRm9udCh7Zm9udCwgY2hhcmFjdGVycywgc2RmR2x5cGhTaXplfSwgY2FsbGJhY2spIHtcbiAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGNoYXJhY3RlcnMpID8gY2hhcmFjdGVycy5qb2luKCdcXG4nKSA6ICcnICsgY2hhcmFjdGVycztcbiAgZ2V0VGV4dFJlbmRlckluZm8oeyBmb250LCBzZGZHbHlwaFNpemUsIHRleHQgfSwgY2FsbGJhY2spO1xufVxuXG5cbi8vIExvY2FsIGFzc2lnbiBpbXBsIHNvIHdlIGRvbid0IGhhdmUgdG8gaW1wb3J0IHRyb2lrYS1jb3JlXG5mdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgZm9yIChsZXQga2V5IGluIGZyb21PYmopIHtcbiAgICBpZiAoZnJvbU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9PYmpcbn1cblxuLy8gVXRpbGl0eSBmb3IgbWFraW5nIFVSTHMgYWJzb2x1dGVcbmxldCBsaW5rRWw7XG5mdW5jdGlvbiB0b0Fic29sdXRlVVJMKHBhdGgpIHtcbiAgaWYgKCFsaW5rRWwpIHtcbiAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIH1cbiAgbGlua0VsLmhyZWYgPSBwYXRoO1xuICByZXR1cm4gbGlua0VsLmhyZWZcbn1cblxuLyoqXG4gKiBTYWZhcmkgPCB2MTUgc2VlbXMgdW5hYmxlIHRvIHVzZSB0aGUgU0RGIHdlYmdsIGNhbnZhcyBhcyBhIHRleHR1cmUuIFRoaXMgYXBwbGllcyBhIHdvcmthcm91bmRcbiAqIHdoZXJlIGl0IHJlYWRzIHRoZSBwaXhlbHMgb3V0IG9mIHRoYXQgY2FudmFzIGFuZCB1cGxvYWRzIHRoZW0gYXMgYSBkYXRhIHRleHR1cmUgaW5zdGVhZCwgYXRcbiAqIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGNvc3QuXG4gKi9cbmZ1bmN0aW9uIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcykge1xuICAvLyBVc2UgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydCBhcyBhIHByb3h5IGZvciBTYWZhcmk8MTUsIGFsbCBvdGhlciBtYWluc3RyZWFtIGJyb3dzZXJzXG4gIC8vIGhhdmUgc3VwcG9ydGVkIGl0IGZvciBhIGxvbmcgd2hpbGUgc28gYW55IGZhbHNlIHBvc2l0aXZlcyBzaG91bGQgYmUgbWluaW1hbC5cbiAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuaW5mbygnU2FmYXJpPDE1OiBhcHBseWluZyBTREYgY2FudmFzIHdvcmthcm91bmQnKTtcbiAgICBjb25zdCB7c2RmQ2FudmFzLCBzZGZUZXh0dXJlfSA9IGF0bGFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNkZkNhbnZhcztcbiAgICBjb25zdCBnbCA9IGF0bGFzLnNkZkNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGxldCBwaXhlbHMgPSBzZGZUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgaWYgKCFwaXhlbHMgfHwgcGl4ZWxzLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgc2RmVGV4dHVyZS5pbWFnZSA9IHt3aWR0aCwgaGVpZ2h0LCBkYXRhOiBwaXhlbHN9O1xuICAgICAgc2RmVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgc2RmVGV4dHVyZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICB9XG59XG5cblxuY29uc3QgdHlwZXNldHRlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIENPTkZJRyxcbiAgICB3b3JrZXJNb2R1bGUsXG4gICAgY3JlYXRlVHlwZXNldHRlcixcbiAgICBiaWRpRmFjdG9yeVxuICBdLFxuICBpbml0KGNvbmZpZywgZm9udFBhcnNlciwgY3JlYXRlVHlwZXNldHRlciwgYmlkaUZhY3RvcnkpIHtcbiAgICBjb25zdCB7ZGVmYXVsdEZvbnRVUkx9ID0gY29uZmlnO1xuICAgIHJldHVybiBjcmVhdGVUeXBlc2V0dGVyKGZvbnRQYXJzZXIsIGJpZGlGYWN0b3J5KCksIHsgZGVmYXVsdEZvbnRVUkwgfSlcbiAgfVxufSk7XG5cbmNvbnN0IHR5cGVzZXRJbldvcmtlciA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUsXG4gIF0sXG4gIGluaXQodHlwZXNldHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHR5cGVzZXR0ZXIudHlwZXNldChhcmdzLCByZXNvbHZlKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBnZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCkge1xuICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW1xuICAgICAgcmVzdWx0LmdseXBoUG9zaXRpb25zLmJ1ZmZlcixcbiAgICAgIHJlc3VsdC5nbHlwaElkcy5idWZmZXJcbiAgICBdO1xuICAgIGlmIChyZXN1bHQuY2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHQuY2FyZXRQb3NpdGlvbnMuYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5nbHlwaENvbG9ycykge1xuICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHJlc3VsdC5nbHlwaENvbG9ycy5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlc1xuICB9XG59KTtcblxuZnVuY3Rpb24gZHVtcFNERlRleHR1cmVzKCkge1xuICBPYmplY3Qua2V5cyhhdGxhc2VzKS5mb3JFYWNoKHNpemUgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGNhbnZhcztcbiAgICBjb25zb2xlLmxvZyhcIiVjLlwiLCBgXG4gICAgICBiYWNrZ3JvdW5kOiB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHt3aWR0aH1weCAke2hlaWdodH1weDtcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHt3aWR0aH1weDtcbiAgICBgKTtcbiAgfSk7XG59XG5cbmNvbnN0IHRlbXBsYXRlR2VvbWV0cmllcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICBsZXQgZ2VvbSA9IHRlbXBsYXRlR2VvbWV0cmllc1tkZXRhaWxdO1xuICBpZiAoIWdlb20pIHtcbiAgICAvLyBHZW9tZXRyeSBpcyB0d28gcGxhbmVzIGJhY2stdG8tYmFjaywgd2hpY2ggd2lsbCBhbHdheXMgYmUgcmVuZGVyZWQgRnJvbnRTaWRlIG9ubHkgYnV0XG4gICAgLy8gYXBwZWFyIGFzIERvdWJsZVNpZGUgYnkgZGVmYXVsdC4gRnJvbnRTaWRlL0JhY2tTaWRlIGFyZSBlbXVsYXRlZCB1c2luZyBkcmF3UmFuZ2UuXG4gICAgLy8gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGhpdCBvZiB0d28gZHJhdyBjYWxscyBmb3IgRG91YmxlU2lkZSBtYXRlcmlhbHNcbiAgICAvLyBpbnRyb2R1Y2VkIGJ5IFRocmVlLmpzIGluIHIxMzAgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3XG4gICAgY29uc3QgZnJvbnQgPSBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCBkZXRhaWwsIGRldGFpbCk7XG4gICAgY29uc3QgYmFjayA9IGZyb250LmNsb25lKCk7XG4gICAgY29uc3QgZnJvbnRBdHRycyA9IGZyb250LmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgYmFja0F0dHJzID0gYmFjay5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgdmVydENvdW50ID0gZnJvbnRBdHRycy51di5jb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRDb3VudDsgaSsrKSB7XG4gICAgICBiYWNrQXR0cnMucG9zaXRpb24uYXJyYXlbaSAqIDNdICo9IC0xOyAvLyBmbGlwIHBvc2l0aW9uIHhcbiAgICAgIGJhY2tBdHRycy5ub3JtYWwuYXJyYXlbaSAqIDMgKyAyXSAqPSAtMTsgLy8gZmxpcCBub3JtYWwgelxuICAgIH1cbiAgICBbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb21iaW5lZC5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgIFsuLi5mcm9udEF0dHJzW25hbWVdLmFycmF5LCAuLi5iYWNrQXR0cnNbbmFtZV0uYXJyYXldLFxuICAgICAgICBmcm9udEF0dHJzW25hbWVdLml0ZW1TaXplKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb21iaW5lZC5zZXRJbmRleChbLi4uZnJvbnQuaW5kZXguYXJyYXksIC4uLmJhY2suaW5kZXguYXJyYXkubWFwKG4gPT4gbiArIHZlcnRDb3VudCldKTtcbiAgICBjb21iaW5lZC50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICAgIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXSA9IGNvbWJpbmVkO1xuICB9XG4gIHJldHVybiBnZW9tXG59XG5cbmNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbmNvbnN0IGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG5jb25zdCBnbHlwaENvbG9yQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQ29sb3InO1xuXG4vKipcbkBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG5BIHNwZWNpYWxpemVkIEdlb21ldHJ5IGZvciByZW5kZXJpbmcgYSBzZXQgb2YgdGV4dCBnbHlwaHMuIFVzZXMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgdG9cbnJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG5nZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICBXaGVyZSBOID0gbnVtYmVyIG9mIGdseXBocy4uLlxuXG4gIEluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogNCAqIDNcbiAgLSBpbmRleDogMiAqIDNcbiAgLSBub3JtYWw6IDQgKiAzXG4gIC0gdXY6IDQgKiAyXG4gIC0gZ2x5cGggeC95IGJvdW5kczogTiAqIDRcbiAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICA9IDVOICsgMzhcblxuICBOb24taW5zdGFuY2VkOlxuICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgLSBpbmRleDogTiAqIDIgKiAzXG4gIC0gbm9ybWFsOiBOICogNCAqIDNcbiAgLSB1djogTiAqIDQgKiAyXG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSAzOU5cblxuQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbndoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4qL1xuY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvLyBEZWZpbmUgZ3JvdXBzIGZvciByZW5kZXJpbmcgdGV4dCBvdXRsaW5lIGFzIGEgc2VwYXJhdGUgcGFzczsgdGhlc2Ugd2lsbCBvbmx5XG4gICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgdGhpcy5ncm91cHMgPSBbXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMH0sXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICBdO1xuXG4gICAgLy8gUHJlYWxsb2NhdGUgZW1wdHkgYm91bmRpbmcgb2JqZWN0c1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ1NwaGVyZSBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgfVxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdCb3ggcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICAvLyBTaW5jZSBvdXIgYmFzZSBnZW9tZXRyeSBjb250YWlucyB0cmlhbmdsZXMgZm9yIGJvdGggZnJvbnQgYW5kIGJhY2sgc2lkZXMsIHdlIGNhbiBlbXVsYXRlXG4gIC8vIHRoZSBcInNpZGVcIiBieSByZXN0cmljdGluZyB0aGUgZHJhdyByYW5nZS5cbiAgc2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLmdldEluZGV4KCkuY291bnQ7XG4gICAgdGhpcy5zZXREcmF3UmFuZ2Uoc2lkZSA9PT0gQmFja1NpZGUgPyB2ZXJ0cyAvIDIgOiAwLCBzaWRlID09PSBEb3VibGVTaWRlID8gdmVydHMgOiB2ZXJ0cyAvIDIpO1xuICB9XG5cbiAgc2V0IGRldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoZGV0YWlsICE9PSB0aGlzLl9kZXRhaWwpIHtcbiAgICAgIHRoaXMuX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgIGRldGFpbCA9IDE7XG4gICAgICB9XG4gICAgICBsZXQgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICA7Wydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gPSB0cGwuYXR0cmlidXRlc1thdHRyXS5jbG9uZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgZGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXRhaWxcbiAgfVxuXG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgaWYgKHIgIT09IHRoaXMuX2N1cnZlUmFkaXVzKSB7XG4gICAgICB0aGlzLl9jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJ2ZVJhZGl1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHBsYW5hciBib3VuZHMgZm9yIGFsbCBnbHlwaHNcbiAgICogICAgICAgIHRvIGJlIHJlbmRlcmVkLCA0IGVudHJpZXMgZm9yIGVhY2ggZ2x5cGg6IHgxLHgyLHkxLHkxXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAqICAgICAgICB0aGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgW21pblgsIG1pblksIG1heFgsIG1heFldIGFjcm9zcyBhbGwgZ2x5cGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgKiAgICAgICAgY29uc2VjdXRpdmUgZ2x5cGhzOiBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLiBUaGlzIGNhbiBiZVxuICAgKiAgICAgICAgdXNlZCB3aXRoIGBhcHBseUNsaXBSZWN0YCB0byBjaG9vc2UgYW4gb3B0aW1pemVkIGBpbnN0YW5jZUNvdW50YC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAqL1xuICB1cGRhdGVHbHlwaHMoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCBibG9ja0JvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQm91bmRzQXR0ck5hbWUsIGdseXBoQm91bmRzLCA0KTtcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhDb2xvckF0dHJOYW1lLCBnbHlwaENvbG9ycywgMyk7XG4gICAgdGhpcy5fYmxvY2tCb3VuZHMgPSBibG9ja0JvdW5kcztcbiAgICB0aGlzLl9jaHVua2VkQm91bmRzID0gY2h1bmtlZEJvdW5kcztcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2Jsb2NrQm91bmRzO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIGNvbnN0IHsgY3VydmVSYWRpdXMsIGJvdW5kaW5nQm94OiBiYm94IH0gPSB0aGlzO1xuICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHsgUEksIGZsb29yLCBtaW4sIG1heCwgc2luLCBjb3MgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IGhhbGZQaSA9IFBJIC8gMjtcbiAgICAgICAgY29uc3QgdHdvUGkgPSBQSSAqIDI7XG4gICAgICAgIGNvbnN0IGFic1IgPSBNYXRoLmFicyhjdXJ2ZVJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGJvdW5kc1swXSAvIGFic1I7XG4gICAgICAgIGNvbnN0IHJpZ2h0QW5nbGUgPSBib3VuZHNbMl0gLyBhYnNSO1xuICAgICAgICBjb25zdCBtaW5YID0gZmxvb3IoKGxlZnRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgID8gLWFic1IgOiBtaW4oc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IGZsb29yKChsZWZ0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IGFic1IgOiBtYXgoc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WiA9IGZsb29yKChsZWZ0QW5nbGUgKyBQSSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgUEkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSICogMiA6IG1heChhYnNSIC0gY29zKGxlZnRBbmdsZSkgKiBhYnNSLCBhYnNSIC0gY29zKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGJib3gubWluLnNldChtaW5YLCBib3VuZHNbMV0sIGN1cnZlUmFkaXVzIDwgMCA/IC1tYXhaIDogMCk7XG4gICAgICAgIGJib3gubWF4LnNldChtYXhYLCBib3VuZHNbM10sIGN1cnZlUmFkaXVzIDwgMCA/IDAgOiBtYXhaKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJib3gubWluLnNldChib3VuZHNbMF0sIGJvdW5kc1sxXSwgMCk7XG4gICAgICAgIGJib3gubWF4LnNldChib3VuZHNbMl0sIGJvdW5kc1szXSwgMCk7XG4gICAgICB9XG4gICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuYm91bmRpbmdTcGhlcmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNsaXBwaW5nIHJlY3QsIGFuZCB0aGUgY2h1bmtlZEJvdW5kcyBmcm9tIHRoZSBsYXN0IHVwZGF0ZUdseXBocyBjYWxsLCBjaG9vc2UgdGhlIGxvd2VzdFxuICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICogZm9yIGxvbmcgYmxvY2tzIG9mIHRleHQgdGhhdCBhcmUgY2xpcHBlZCwgdG8gc2tpcCB2ZXJ0ZXggc2hhZGVyIGV2YWx1YXRpb24gZm9yIGdseXBocyB0aGF0IHdvdWxkXG4gICAqIGJlIGNsaXBwZWQgYW55d2F5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc2luY2UgYGRyYXdFbGVtZW50c0luc3RhbmNlZFtBTkdMRV1gIG9ubHkgYWNjZXB0cyBhbiBpbnN0YW5jZSBjb3VudCBhbmQgbm90IGEgc3RhcnRpbmdcbiAgICogb2Zmc2V0LCB0aGlzIG9wdGltaXphdGlvbiBiZWNvbWVzIGxlc3MgZWZmZWN0aXZlIGFzIHRoZSBjbGlwUmVjdCBtb3ZlcyBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICogYnV0IGF0IHRoZSBleHBlbnNlIG9mIG11Y2ggbGFyZ2VyIGF0dHJpYnV0ZSBidWZmZXJzIChzZWUgY2xhc3Nkb2MgYWJvdmUuKVxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAqL1xuICBhcHBseUNsaXBSZWN0KGNsaXBSZWN0KSB7XG4gICAgbGV0IGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICBsZXQgY2h1bmtzID0gdGhpcy5fY2h1bmtlZEJvdW5kcztcbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb3VudCA9IGNodW5rc1tpXS5lbmQ7XG4gICAgICAgIGxldCByZWN0ID0gY2h1bmtzW2ldLnJlY3Q7XG4gICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgaWYgKHJlY3RbMV0gPCBjbGlwUmVjdC53ICYmIHJlY3RbM10gPiBjbGlwUmVjdC55ICYmIHJlY3RbMF0gPCBjbGlwUmVjdC56ICYmIHJlY3RbMl0gPiBjbGlwUmVjdC54KSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBjb3VudDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckF0dHIoZ2VvbSwgYXR0ck5hbWUsIG5ld0FycmF5LCBpdGVtU2l6ZSkge1xuICBjb25zdCBhdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICBpZiAobmV3QXJyYXkpIHtcbiAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgaWYgKGF0dHIgJiYgYXR0ci5hcnJheS5sZW5ndGggPT09IG5ld0FycmF5Lmxlbmd0aCkge1xuICAgICAgYXR0ci5hcnJheS5zZXQobmV3QXJyYXkpO1xuICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb20uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ld0FycmF5LCBpdGVtU2l6ZSkpO1xuICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjYWNoZWQgbWF4IGluc3RhbmNlIGNvdW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTk3MDZcbiAgICAgIC8vIEl0J3MgdW5jbGVhciBpZiB0aGlzIGlzIGEgdGhyZWVqcyBidWcgb3IgYSB0cnVseSB1bnN1cHBvcnRlZCBzY2VuYXJpbzsgZGlzY3Vzc2lvbiBpblxuICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgIC8vIGRpZmZlcmVudCBzaXplIGlzIHN1cHBvcnRlZCwgYnV0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xNzQxOCBzdHJvbmdseVxuICAgICAgLy8gaW1wbGllcyBpdCBzaG91bGQgYmUgc3VwcG9ydGVkLiBJdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG9cbiAgICAgIGRlbGV0ZSBnZW9tLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgZ2VvbS5kaXNwb3NlKCk7IC8vZm9yIHIxMTgrLCBtb3JlIHJvYnVzdCBmZWVsaW5nLCBidXQgbW9yZSBoZWF2eS1oYW5kZWQgdGhhbiBJJ2QgbGlrZVxuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgZ2VvbS5kZWxldGVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICB9XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IFZFUlRFWF9ERUZTID0gYFxudW5pZm9ybSB2ZWMyIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERkdseXBoU2l6ZTtcbnVuaWZvcm0gdmVjNCB1VHJvaWthVG90YWxCb3VuZHM7XG51bmlmb3JtIHZlYzQgdVRyb2lrYUNsaXBSZWN0O1xudW5pZm9ybSBtYXQzIHVUcm9pa2FPcmllbnQ7XG51bmlmb3JtIGJvb2wgdVRyb2lrYVVzZUdseXBoQ29sb3JzO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRGlzdGFuY2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMyIHVUcm9pa2FQb3NpdGlvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUN1cnZlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgYVRyb2lrYUdseXBoQm91bmRzO1xuYXR0cmlidXRlIGZsb2F0IGFUcm9pa2FHbHlwaEluZGV4O1xuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbmNvbnN0IFZFUlRFWF9UUkFOU0ZPUk0gPSBgXG52ZWM0IGJvdW5kcyA9IGFUcm9pa2FHbHlwaEJvdW5kcztcbmJvdW5kcy54eiArPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueDtcbmJvdW5kcy55dyAtPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueTtcblxudmVjNCBvdXRsaW5lQm91bmRzID0gdmVjNChcbiAgYm91bmRzLnh5IC0gdVRyb2lrYURpc3RhbmNlT2Zmc2V0IC0gdVRyb2lrYUJsdXJSYWRpdXMsXG4gIGJvdW5kcy56dyArIHVUcm9pa2FEaXN0YW5jZU9mZnNldCArIHVUcm9pa2FCbHVyUmFkaXVzXG4pO1xudmVjNCBjbGlwcGVkQm91bmRzID0gdmVjNChcbiAgY2xhbXAob3V0bGluZUJvdW5kcy54eSwgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpLFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnp3LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dylcbik7XG5cbnZlYzIgY2xpcHBlZFhZID0gKG1peChjbGlwcGVkQm91bmRzLnh5LCBjbGlwcGVkQm91bmRzLnp3LCBwb3NpdGlvbi54eSkgLSBib3VuZHMueHkpIC8gKGJvdW5kcy56dyAtIGJvdW5kcy54eSk7XG5cbnBvc2l0aW9uLnh5ID0gbWl4KGJvdW5kcy54eSwgYm91bmRzLnp3LCBjbGlwcGVkWFkpO1xuXG51diA9IChwb3NpdGlvbi54eSAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLnp3IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KTtcblxuZmxvYXQgcmFkID0gdVRyb2lrYUN1cnZlUmFkaXVzO1xuaWYgKHJhZCAhPSAwLjApIHtcbiAgZmxvYXQgYW5nbGUgPSBwb3NpdGlvbi54IC8gcmFkO1xuICBwb3NpdGlvbi54eiA9IHZlYzIoc2luKGFuZ2xlKSAqIHJhZCwgcmFkIC0gY29zKGFuZ2xlKSAqIHJhZCk7XG4gIG5vcm1hbC54eiA9IHZlYzIoc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG59XG4gIFxucG9zaXRpb24gPSB1VHJvaWthT3JpZW50ICogcG9zaXRpb247XG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xuXG52VHJvaWthR2x5cGhVViA9IGNsaXBwZWRYWS54eTtcbnZUcm9pa2FHbHlwaERpbWVuc2lvbnMgPSB2ZWMyKGJvdW5kc1syXSAtIGJvdW5kc1swXSwgYm91bmRzWzNdIC0gYm91bmRzWzFdKTtcblxuJHsnJy8qIE5PVEU6IGl0IHNlZW1zIGltcG9ydGFudCB0byBjYWxjdWxhdGUgdGhlIGdseXBoJ3MgYm91bmRpbmcgdGV4dHVyZSBVVnMgaGVyZSBpbiB0aGVcbiAgdmVydGV4IHNoYWRlciwgcmF0aGVyIHRoYW4gaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgYXMgdGhlIGxhdHRlciBnaXZlcyBzdHJhbmdlIGFydGlmYWN0c1xuICBvbiBzb21lIGdseXBocyAodGhvc2UgaW4gdGhlIGxlZnRtb3N0IHRleHR1cmUgY29sdW1uKSBvbiBzb21lIHN5c3RlbXMuIFRoZSBleGFjdCByZWFzb25cbiAgaXNuJ3QgdW5kZXJzdG9vZCBidXQgZG9pbmcgdGhpcyBoZXJlLCB0aGVuIG1peCgpLWluZyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBzZWVtcyB0byB3b3JrLiAqL31cbmZsb2F0IHR4Q29scyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZS54IC8gdVRyb2lrYVNERkdseXBoU2l6ZTtcbnZlYzIgdHhVdlBlclNxdWFyZSA9IHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG52ZWMyIHR4U3RhcnRVViA9IHR4VXZQZXJTcXVhcmUgKiB2ZWMyKFxuICBtb2QoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApLCB0eENvbHMpLFxuICBmbG9vcihmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCkgLyB0eENvbHMpXG4pO1xudlRyb2lrYVRleHR1cmVVVkJvdW5kcyA9IHZlYzQodHhTdGFydFVWLCB2ZWMyKHR4U3RhcnRVVikgKyB0eFV2UGVyU3F1YXJlKTtcbnZUcm9pa2FUZXh0dXJlQ2hhbm5lbCA9IG1vZChhVHJvaWthR2x5cGhJbmRleCwgNC4wKTtcbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRmlsbE9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FPdXRsaW5lT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBGUkFHTUVOVF9UUkFOU0ZPUk0gPSBgXG5mbG9hdCBhYURpc3QgPSB0cm9pa2FHZXRBQURpc3QoKTtcbmZsb2F0IGZyYWdEaXN0YW5jZSA9IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKTtcbmZsb2F0IGVkZ2VBbHBoYSA9IHVUcm9pa2FTREZEZWJ1ZyA/XG4gIHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZUcm9pa2FHbHlwaFVWKSA6XG4gIHRyb2lrYUdldEVkZ2VBbHBoYShmcmFnRGlzdGFuY2UsIHVUcm9pa2FEaXN0YW5jZU9mZnNldCwgbWF4KGFhRGlzdCwgdVRyb2lrYUJsdXJSYWRpdXMpKTtcblxuI2lmICFkZWZpbmVkKElTX0RFUFRIX01BVEVSSUFMKSAmJiAhZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbnZlYzQgZmlsbFJHQkEgPSBnbF9GcmFnQ29sb3I7XG5maWxsUkdCQS5hICo9IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnZlYzQgc3Ryb2tlUkdCQSA9IHVUcm9pa2FTdHJva2VXaWR0aCA9PSAwLjAgPyBmaWxsUkdCQSA6IHZlYzQodVRyb2lrYVN0cm9rZUNvbG9yLCB1VHJvaWthU3Ryb2tlT3BhY2l0eSk7XG5pZiAoZmlsbFJHQkEuYSA9PSAwLjApIGZpbGxSR0JBLnJnYiA9IHN0cm9rZVJHQkEucmdiO1xuZ2xfRnJhZ0NvbG9yID0gbWl4KGZpbGxSR0JBLCBzdHJva2VSR0JBLCBzbW9vdGhzdGVwKFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoIC0gYWFEaXN0LFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoICsgYWFEaXN0LFxuICBmcmFnRGlzdGFuY2VcbikpO1xuZ2xfRnJhZ0NvbG9yLmEgKj0gZWRnZUFscGhhO1xuI2VuZGlmXG5cbmlmIChlZGdlQWxwaGEgPT0gMC4wKSB7XG4gIGRpc2NhcmQ7XG59XG5gO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgY29uc3QgdGV4dE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgZXh0ZW5zaW9uczoge1xuICAgICAgZGVyaXZhdGl2ZXM6IHRydWVcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU0RGRXhwb25lbnQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IFZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgdVRyb2lrYUNsaXBSZWN0OiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FEaXN0YW5jZU9mZnNldDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FPdXRsaW5lT3BhY2l0eToge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FGaWxsT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FQb3NpdGlvbk9mZnNldDoge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FCbHVyUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZUNvbG9yOiB7dmFsdWU6IG5ldyBDb2xvcigpfSxcbiAgICAgIHVUcm9pa2FTdHJva2VPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgdVRyb2lrYU9yaWVudDoge3ZhbHVlOiBuZXcgTWF0cml4MygpfSxcbiAgICAgIHVUcm9pa2FVc2VHbHlwaENvbG9yczoge3ZhbHVlOiB0cnVlfSxcbiAgICAgIHVUcm9pa2FTREZEZWJ1Zzoge3ZhbHVlOiBmYWxzZX1cbiAgICB9LFxuICAgIHZlcnRleERlZnM6IFZFUlRFWF9ERUZTLFxuICAgIHZlcnRleFRyYW5zZm9ybTogVkVSVEVYX1RSQU5TRk9STSxcbiAgICBmcmFnbWVudERlZnM6IEZSQUdNRU5UX0RFRlMsXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybTogRlJBR01FTlRfVFJBTlNGT1JNLFxuICAgIGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSkge1xuICAgICAgbGV0IHVEaWZmdXNlUkUgPSAvXFxidW5pZm9ybVxccyt2ZWMzXFxzK2RpZmZ1c2VcXGIvO1xuICAgICAgaWYgKHVEaWZmdXNlUkUudGVzdChmcmFnbWVudFNoYWRlcikpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIGBkaWZmdXNlYCB3aXRoIG91ciB2YXJ5aW5nXG4gICAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAucmVwbGFjZSh1RGlmZnVzZVJFLCAndmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxiZGlmZnVzZVxcYi9nLCAndlRyb2lrYUdseXBoQ29sb3InKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2ZXJ0ZXggc2hhZGVyIGRlY2xhcmVzIHRoZSB1bmlmb3JtIHNvIHdlIGNhbiBncmFiIGl0IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgaWYgKCF1RGlmZnVzZVJFLnRlc3QodmVydGV4U2hhZGVyKSkge1xuICAgICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAgICAgdm9pZE1haW5SZWdFeHAsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxuJCZcXG52VHJvaWthR2x5cGhDb2xvciA9IHVUcm9pa2FVc2VHbHlwaENvbG9ycyA/IGFUcm9pa2FHbHlwaENvbG9yIC8gMjU1LjAgOiBkaWZmdXNlO1xcbidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcmNlIHRyYW5zcGFyZW5jeSAtIFRPRE8gaXMgdGhpcyByZWFzb25hYmxlP1xuICB0ZXh0TWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgIGlzVHJvaWthVGV4dE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgLy8gV2ViR0xTaGFkb3dNYXAgcmV2ZXJzZXMgdGhlIHNpZGUgb2YgdGhlIHNoYWRvdyBtYXRlcmlhbCBieSBkZWZhdWx0LCB3aGljaCBmYWlsc1xuICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICBzaGFkb3dTaWRlOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZGVcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIC8vbm8tb3BcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXh0TWF0ZXJpYWxcbn1cblxuY29uc3QgZGVmYXVsdE1hdGVyaWFsID0gLyojX19QVVJFX18qLyBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICBjb2xvcjogMHhmZmZmZmYsXG4gIHNpZGU6IERvdWJsZVNpZGUsXG4gIHRyYW5zcGFyZW50OiB0cnVlXG59KTtcbmNvbnN0IGRlZmF1bHRTdHJva2VDb2xvciA9IDB4ODA4MDgwO1xuXG5jb25zdCB0ZW1wTWF0NCA9IC8qI19fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IHRlbXBWZWMzYSA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBWZWMzYiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBBcnJheSA9IFtdO1xuY29uc3Qgb3JpZ2luID0gLyojX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgZGVmYXVsdE9yaWVudCA9ICcreCt5JztcblxuZnVuY3Rpb24gZmlyc3Qobykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvXG59XG5cbmxldCBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxKSxcbiAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgKTtcbiAgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5sZXQgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCAzMiwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5cbmNvbnN0IHN5bmNTdGFydEV2ZW50ID0geyB0eXBlOiAnc3luY3N0YXJ0JyB9O1xuY29uc3Qgc3luY0NvbXBsZXRlRXZlbnQgPSB7IHR5cGU6ICdzeW5jY29tcGxldGUnIH07XG5cbmNvbnN0IFNZTkNBQkxFX1BST1BTID0gW1xuICAnZm9udCcsXG4gICdmb250U2l6ZScsXG4gICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnbWF4V2lkdGgnLFxuICAnb3ZlcmZsb3dXcmFwJyxcbiAgJ3RleHQnLFxuICAnZGlyZWN0aW9uJyxcbiAgJ3RleHRBbGlnbicsXG4gICd0ZXh0SW5kZW50JyxcbiAgJ3doaXRlU3BhY2UnLFxuICAnYW5jaG9yWCcsXG4gICdhbmNob3JZJyxcbiAgJ2NvbG9yUmFuZ2VzJyxcbiAgJ3NkZkdseXBoU2l6ZSdcbl07XG5cbmNvbnN0IENPUFlBQkxFX1BST1BTID0gU1lOQ0FCTEVfUFJPUFMuY29uY2F0KFxuICAnbWF0ZXJpYWwnLFxuICAnY29sb3InLFxuICAnZGVwdGhPZmZzZXQnLFxuICAnY2xpcFJlY3QnLFxuICAnY3VydmVSYWRpdXMnLFxuICAnb3JpZW50YXRpb24nLFxuICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbik7XG5cbi8qKlxuICogQGNsYXNzIFRleHRcbiAqXG4gKiBBIFRocmVlSlMgTWVzaCB0aGF0IHJlbmRlcnMgYSBzdHJpbmcgb2YgdGV4dCBvbiBhIHBsYW5lIGluIDNEIHNwYWNlIHVzaW5nIHNpZ25lZCBkaXN0YW5jZVxuICogZmllbGRzIChTREYpLlxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdseXBoc0dlb21ldHJ5KCk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG51bGwpO1xuXG4gICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0XG4gICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHRoaXMudGV4dCA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAqIERlZmluZXMgdGhlIGhvcml6b250YWwgcG9zaXRpb24gaW4gdGhlIHRleHQgYmxvY2sgdGhhdCBzaG91bGQgbGluZSB1cCB3aXRoIHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAqIG9yICdyaWdodCcuXG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvclhcbiAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB5IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzIChub3RlOiBkb3duIGlzIG5lZ2F0aXZlIHkpLCBhIHN0cmluZ1xuICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ3RvcC1jYXAnLCAndG9wLWV4JywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjdXJ2ZVJhZGl1c1xuICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgKiB0aGUgY3lsaW5kZXIncyBjZW50ZXJsaW5lIChvcmllbnRlZCB2ZXJ0aWNhbGx5KSB0aGF0IGRpc3RhbmNlIGluIGZyb250IG9mIHRoZSB0ZXh0LCBmb3IgYSBjb25jYXZlXG4gICAgICogY3VydmF0dXJlLCB3aGlsZSBuZWdhdGl2ZSBudW1iZXJzIHB1dCBpdCBiZWhpbmQgdGhlIHRleHQgZm9yIGEgY29udmV4IGN1cnZhdHVyZS4gVGhlIGNlbnRlcmxpbmVcbiAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIGVhY2ggZ2x5cGggaXMgYnkgZGVmYXVsdCByZW5kZXJlZCB3aXRoIGEgc2ltcGxlIHF1YWQsIGVhY2ggZ2x5cGggcmVtYWlucyBhIGZsYXQgcGxhbmVcbiAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAqL1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBTZXRzIHRoZSBiYXNlIGRpcmVjdGlvbiBmb3IgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIFwiYXV0b1wiIHdpbGwgY2hvb3NlIGEgZGlyZWN0aW9uIGJhc2VkXG4gICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnYXV0byc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBVUkwgb2YgYSBjdXN0b20gZm9udCB0byBiZSB1c2VkLiBGb250IGZpbGVzIGNhbiBiZSBpbiAudHRmLCAub3RmLCBvciAud29mZiAobm90IC53b2ZmMikgZm9ybWF0cy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgUm9ib3RvIGZvbnQgbG9hZGVkIGZyb20gR29vZ2xlIEZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udCA9IG51bGw7IC8vd2lsbCB1c2UgZGVmYXVsdCBmcm9tIFRleHRCdWlsZGVyXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICogVGhlIHNpemUgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBmb250IGluIGxvY2FsIHVuaXRzOyBjb3JyZXNwb25kcyB0byB0aGUgZW0tYm94IGhlaWdodFxuICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFNpemUgPSAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgKiBTZXRzIGEgdW5pZm9ybSBhZGp1c3RtZW50IHRvIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzIGFmdGVyIGtlcm5pbmcgaXMgYXBwbGllZC4gUG9zaXRpdmVcbiAgICAgKiBudW1iZXJzIGluY3JlYXNlIHNwYWNpbmcgYW5kIG5lZ2F0aXZlIG51bWJlcnMgZGVjcmVhc2UgaXQuXG4gICAgICovXG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGxpbmVIZWlnaHRcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBsaW5lIG9mIHRleHQsIGFzIGEgbXVsdGlwbGUgb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvICdub3JtYWwnXG4gICAgICogd2hpY2ggY2hvb3NlcyBhIHJlYXNvbmFibGUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBjaG9zZW4gZm9udCdzIGFzY2VuZGVyL2Rlc2NlbmRlciBtZXRyaWNzLlxuICAgICAqL1xuICAgIHRoaXMubGluZUhlaWdodCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhXaWR0aFxuICAgICAqIFRoZSBtYXhpbXVtIHdpZHRoIG9mIHRoZSB0ZXh0IGJsb2NrLCBhYm92ZSB3aGljaCB0ZXh0IG1heSBzdGFydCB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogYHdoaXRlU3BhY2VgIGFuZCBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHRoaXMubWF4V2lkdGggPSBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3ZlcmZsb3dXcmFwXG4gICAgICogRGVmaW5lcyBob3cgdGV4dCB3cmFwcyBpZiB0aGUgYHdoaXRlU3BhY2VgIHByb3BlcnR5IGlzIGBub3JtYWxgLiBDYW4gYmUgZWl0aGVyIGAnbm9ybWFsJ2BcbiAgICAgKiB0byBicmVhayBhdCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIG9yIGAnYnJlYWstd29yZCdgIHRvIGFsbG93IGJyZWFraW5nIHdpdGhpbiB3b3Jkcy5cbiAgICAgKiBEZWZhdWx0cyB0byBgJ25vcm1hbCdgLlxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dXcmFwID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRBbGlnblxuICAgICAqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiBlYWNoIGxpbmUgb2YgdGV4dCB3aXRoaW4gdGhlIG92ZXJhbGwgdGV4dCBib3VuZGluZyBib3guXG4gICAgICovXG4gICAgdGhpcy50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRleHRJbmRlbnRcbiAgICAgKiBJbmRlbnRhdGlvbiBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpbmU7IHNlZSBDU1MgYHRleHQtaW5kZW50YC5cbiAgICAgKi9cbiAgICB0aGlzLnRleHRJbmRlbnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB3aGl0ZVNwYWNlXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRleHQgc2hvdWxkIHdyYXAgd2hlbiBhIGxpbmUgcmVhY2hlcyB0aGUgYG1heFdpZHRoYC4gQ2FuXG4gICAgICogYmUgZWl0aGVyIGAnbm9ybWFsJ2AgKHRoZSBkZWZhdWx0KSwgdG8gYWxsb3cgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZSBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0eSxcbiAgICAgKiBvciBgJ25vd3JhcCdgIHRvIHByZXZlbnQgd3JhcHBpbmcuIE5vdGUgdGhhdCBgJ25vcm1hbCdgIGhlcmUgaG9ub3JzIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgICAqIG1hbnVhbGx5IGJyZWFrIGxpbmVzLCBtYWtpbmcgaXQgYmVoYXZlIG1vcmUgbGlrZSBgJ3ByZS13cmFwJ2AgZG9lcyBpbiBDU1MuXG4gICAgICovXG4gICAgdGhpcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG5cblxuICAgIC8vID09PSBQcmVzZW50YXRpb24gcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtUSFJFRS5NYXRlcmlhbH0gbWF0ZXJpYWxcbiAgICAgKiBEZWZpbmVzIGEgX2Jhc2VfIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHRleHQuIFRoaXMgbWF0ZXJpYWwgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgd2l0aCBhIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBpdCwgdGhhdCBhZGRzIHNoYWRlciBjb2RlIHRvXG4gICAgICogZGVjcmVhc2UgdGhlIGFscGhhIGZvciBlYWNoIGZyYWdtZW50IChwaXhlbCkgb3V0c2lkZSB0aGUgdGV4dCBnbHlwaHMsIHdpdGggYW50aWFsaWFzaW5nLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBkZXJpdmUgZnJvbSBhIHNpbXBsZSB3aGl0ZSBNZXNoQmFzaWNNYXRlcmlhbCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICAgICAqIG9mIHRoZSBvdGhlciBtZXNoIG1hdGVyaWFscyB0byBnYWluIG90aGVyIGZlYXR1cmVzIGxpa2UgbGlnaHRpbmcsIHRleHR1cmUgbWFwcywgZXRjLlxuICAgICAqXG4gICAgICogQWxzbyBzZWUgdGhlIGBjb2xvcmAgc2hvcnRjdXQgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBjb2xvclxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgYGNvbG9yYCBvZiB0aGUgdGV4dCdzIG1hdGVyaWFsLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAgICogaWYgeW91IGRvbid0IHdhbnQgdG8gc3BlY2lmeSBhIHdob2xlIGN1c3RvbSBgbWF0ZXJpYWxgLiBBbHNvLCBpZiB5b3UgZG8gdXNlIGEgY3VzdG9tXG4gICAgICogYG1hdGVyaWFsYCwgdGhpcyBjb2xvciB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgdGhpcyBwYXJ0aWN1YXIgVGV4dCBpbnN0YW5jZSwgZXZlbiBpZlxuICAgICAqIHRoYXQgc2FtZSBtYXRlcmlhbCBpbnN0YW5jZSBpcyBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFRleHQgb2JqZWN0cy5cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge29iamVjdHxudWxsfSBjb2xvclJhbmdlc1xuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGlzIGFsbG93cyBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG9mIGNvbG9ycyBmb3IgaW5kaXZpZHVhbCBvciByYW5nZXMgb2YgY2hhcmFjdGVycyxcbiAgICAgKiB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXRlcmlhbCdzIGBjb2xvcmAuIEl0cyBmb3JtYXQgaXMgYW4gT2JqZWN0IHdob3NlIGtleXMgZWFjaFxuICAgICAqIGRlZmluZSBhIHN0YXJ0aW5nIGNoYXJhY3RlciBpbmRleCBmb3IgYSByYW5nZSwgYW5kIHdob3NlIHZhbHVlcyBhcmUgdGhlIGNvbG9yIGZvciBlYWNoXG4gICAgICogcmFuZ2UuIFRoZSBjb2xvciB2YWx1ZSBjYW4gYmUgYSBudW1lcmljIGhleCBjb2xvciB2YWx1ZSwgYSBgVEhSRUUuQ29sb3JgIG9iamVjdCwgb3JcbiAgICAgKiBhbnkgb2YgdGhlIHN0cmluZ3MgYWNjZXB0ZWQgYnkgYFRIUkVFLkNvbG9yYC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yUmFuZ2VzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVXaWR0aFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgd2lkdGggb2YgYW4gb3V0bGluZS9oYWxvIHRvIGJlIGRyYXduIGFyb3VuZCBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBvdXRsaW5lQ29sb3JgIGFuZCBgb3V0bGluZU9wYWNpdHlgLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAsIHdoaWNoIG1lYW5zXG4gICAgICogbm8gb3V0bGluZSB3aWxsIGJlIGRyYXduIHVubGVzcyBhbiBgb3V0bGluZU9mZnNldFgvWWAgb3IgYG91dGxpbmVCbHVyYCBpcyBzZXQuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gb3V0bGluZUNvbG9yXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAqIERlZmF1bHRzIHRvIGJsYWNrLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZUNvbG9yID0gMHgwMDAwMDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG91dGxpbmVPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAqIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVCbHVyXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgYmx1ciByYWRpdXMgYXBwbGllZCB0byB0aGUgb3V0ZXIgZWRnZSBvZiB0aGUgdGV4dCdzIG91dGxpbmUuIElmIHRoZSBgb3V0bGluZVdpZHRoYCBpc1xuICAgICAqIHplcm8sIHRoZSBibHVyIHdpbGwgYmUgYXBwbGllZCBhdCB0aGUgZ2x5cGggZWRnZSwgbGlrZSBDU1MncyBgdGV4dC1zaGFkb3dgIGJsdXIgcmFkaXVzLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lQmx1ciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIGhvcml6b250YWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT2Zmc2V0WCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIHZlcnRpY2FsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9mZnNldFkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gc3Ryb2tlV2lkdGhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIHdpZHRoIG9mIGFuIGlubmVyIHN0cm9rZSBkcmF3biBpbnNpZGUgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgc3Ryb2tlQ29sb3JgIGFuZCBgc3Ryb2tlT3BhY2l0eWAuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IHN0cm9rZUNvbG9yXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGdyYXkuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VDb2xvciA9IGRlZmF1bHRTdHJva2VDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gc3Ryb2tlT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZmlsbE9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIGdseXBoJ3MgZmlsbCBmcm9tIDAgdG8gMS4gVGhpcyBiZWhhdmVzIGxpa2UgdGhlIG1hdGVyaWFsJ3MgYG9wYWNpdHlgIGJ1dCBhbGxvd3NcbiAgICAgKiBnaXZpbmcgdGhlIGZpbGwgYSBkaWZmZXJlbnQgb3BhY2l0eSB0aGFuIHRoZSBgc3Ryb2tlT3BhY2l0eWAuIEEgZmlsbE9wYWNpdHkgb2YgYDBgIG1ha2VzIHRoZVxuICAgICAqIGludGVyaW9yIG9mIHRoZSBnbHlwaCBpbnZpc2libGUsIGxlYXZpbmcganVzdCB0aGUgYHN0cm9rZVdpZHRoYC4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBkZXB0aE9mZnNldFxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgbWF0ZXJpYWwncyBgcG9seWdvbk9mZnNldGAgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyxcbiAgICAgKiB3aGljaCBjYW4gYmUgdXNlZnVsIGluIHByZXZlbnRpbmcgei1maWdodGluZyB3aGVuIHRoaXMgdGV4dCBpcyBsYWlkIG9uIHRvcCBvZiBhbm90aGVyXG4gICAgICogcGxhbmUgaW4gdGhlIHNjZW5lLiBQb3NpdGl2ZSBudW1iZXJzIGFyZSBmdXJ0aGVyIGZyb20gdGhlIGNhbWVyYSwgbmVnYXRpdmVzIGNsb3Nlci5cbiAgICAgKi9cbiAgICB0aGlzLmRlcHRoT2Zmc2V0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGNsaXBSZWN0XG4gICAgICogSWYgc3BlY2lmaWVkLCBkZWZpbmVzIGEgYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXWAgb2YgYSByZWN0YW5nbGUgb3V0c2lkZSBvZiB3aGljaCBhbGxcbiAgICAgKiBwaXhlbHMgd2lsbCBiZSBkaXNjYXJkZWQuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gY2xpcCBvdmVyZmxvd2luZyB0ZXh0IHdoZW5cbiAgICAgKiBgd2hpdGVTcGFjZT0nbm93cmFwJ2AuXG4gICAgICovXG4gICAgdGhpcy5jbGlwUmVjdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9yaWVudGF0aW9uXG4gICAgICogRGVmaW5lcyB0aGUgYXhpcyBwbGFuZSBvbiB3aGljaCB0aGUgdGV4dCBzaG91bGQgYmUgbGFpZCBvdXQgd2hlbiB0aGUgbWVzaCBoYXMgbm8gZXh0cmFcbiAgICAgKiByb3RhdGlvbiB0cmFuc2Zvcm0uIEl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyB3aXRoIHR3byBheGVzOiB0aGUgaG9yaXpvbnRhbCBheGlzIHdpdGhcbiAgICAgKiBwb3NpdGl2ZSBwb2ludGluZyByaWdodCwgYW5kIHRoZSB2ZXJ0aWNhbCBheGlzIHdpdGggcG9zaXRpdmUgcG9pbnRpbmcgdXAuIEJ5IGRlZmF1bHQgdGhpc1xuICAgICAqIGlzICcreCt5JywgbWVhbmluZyB0aGUgdGV4dCBzaXRzIG9uIHRoZSB4eSBwbGFuZSB3aXRoIHRoZSB0ZXh0J3MgdG9wIHRvd2FyZCBwb3NpdGl2ZSB5XG4gICAgICogYW5kIGZhY2luZyBwb3NpdGl2ZSB6LiBBIHZhbHVlIG9mICcreC16JyB3b3VsZCBwbGFjZSBpdCBvbiB0aGUgeHogcGxhbmUgd2l0aCB0aGUgdGV4dCdzXG4gICAgICogdG9wIHRvd2FyZCBuZWdhdGl2ZSB6IGFuZCBmYWNpbmcgcG9zaXRpdmUgeS5cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGF0aW9uID0gZGVmYXVsdE9yaWVudDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZ2x5cGhHZW9tZXRyeURldGFpbFxuICAgICAqIENvbnRyb2xzIG51bWJlciBvZiB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCBlYWNoIGdseXBoJ3MgcmVjdGFuZ3VsYXJcbiAgICAgKiBwbGFuZS4gRGVmYXVsdHMgdG8gMS4gVGhpcyBjYW4gYmUgaW5jcmVhc2VkIHRvIHByb3ZpZGUgbW9yZSBnZW9tZXRyaWNhbCBkZXRhaWwgZm9yIGN1c3RvbVxuICAgICAqIHZlcnRleCBzaGFkZXIgZWZmZWN0cywgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgdGhpcy5nbHlwaEdlb21ldHJ5RGV0YWlsID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxudWxsfSBzZGZHbHlwaFNpemVcbiAgICAgKiBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGIChzaWduZWQgZGlzdGFuY2UgZmllbGQpIHVzZWQgZm9yIHJlbmRlcmluZy4gVGhpcyBtdXN0IGJlIGFcbiAgICAgKiBwb3dlci1vZi10d28gbnVtYmVyLiBEZWZhdWx0cyB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eVxuICAgICAqIGZvciBtb3N0IGZvbnRzLiBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmdcbiAgICAgKiB0aGUgc2hhcnBuZXNzIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICogaW5jcmVhc2VkIG1lbW9yeSBmb290cHJpbnQgYW5kIGxvbmdlciBTREYgZ2VuZXJhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIHRoaXMuc2RmR2x5cGhTaXplID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGdwdUFjY2VsZXJhdGVTREZcbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIFNERiBnZW5lcmF0aW9uIHByb2Nlc3Mgd2lsbCBiZSBHUFUtYWNjZWxlcmF0ZWQgd2l0aCBXZWJHTCB3aGVuIHBvc3NpYmxlLFxuICAgICAqIG1ha2luZyBpdCBtdWNoIGZhc3RlciBlc3BlY2lhbGx5IGZvciBjb21wbGV4IGdseXBocywgYW5kIGZhbGxpbmcgYmFjayB0byBhIEphdmFTY3JpcHQgdmVyc2lvblxuICAgICAqIGV4ZWN1dGVkIGluIHdlYiB3b3JrZXJzIHdoZW4gc3VwcG9ydCBpc24ndCBhdmFpbGFibGUuIEl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IGRldGVjdCBzdXBwb3J0LFxuICAgICAqIGJ1dCBpdCdzIHN0aWxsIHNvbWV3aGF0IGV4cGVyaW1lbnRhbCwgc28geW91IGNhbiBzZXQgaXQgdG8gYGZhbHNlYCB0byBmb3JjZSBpdCB0byB1c2UgdGhlIEpTXG4gICAgICogdmVyc2lvbiBpZiB5b3UgZW5jb3VudGVyIGlzc3VlcyB3aXRoIGl0LlxuICAgICAqL1xuICAgIHRoaXMuZ3B1QWNjZWxlcmF0ZVNERiA9IHRydWU7XG5cbiAgICB0aGlzLmRlYnVnU0RGID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdGV4dCByZW5kZXJpbmcgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHRleHQtcmVsYXRlZCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAqIFRoaXMgaXMgYW4gYXN5bmMgcHJvY2Vzcywgc28geW91IGNhbiBwYXNzIGluIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpdFxuICAgKiBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgc3luYyhjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9uZWVkc1N5bmMpIHtcbiAgICAgIHRoaXMuX25lZWRzU3luYyA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiB0aGVyZSdzIGFub3RoZXIgc3luYyBzdGlsbCBpbiBwcm9ncmVzcywgcXVldWVcbiAgICAgIGlmICh0aGlzLl9pc1N5bmNpbmcpIHtcbiAgICAgICAgKHRoaXMuX3F1ZXVlZFN5bmNzIHx8ICh0aGlzLl9xdWV1ZWRTeW5jcyA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY1N0YXJ0RXZlbnQpO1xuXG4gICAgICAgIGdldFRleHRSZW5kZXJJbmZvKHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcbiAgICAgICAgICB0ZXh0SW5kZW50OiB0aGlzLnRleHRJbmRlbnQsXG4gICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgIG92ZXJmbG93V3JhcDogdGhpcy5vdmVyZmxvd1dyYXAsXG4gICAgICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICBjb2xvclJhbmdlczogdGhpcy5jb2xvclJhbmdlcyxcbiAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUsIC8vVE9ETyBwYXJhbWV0ZXJpemVcbiAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGVTREY6IHRoaXMuZ3B1QWNjZWxlcmF0ZVNERixcbiAgICAgICAgfSwgdGV4dFJlbmRlckluZm8gPT4ge1xuICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gU2F2ZSByZXN1bHQgZm9yIGxhdGVyIHVzZSBpbiBvbkJlZm9yZVJlbmRlclxuICAgICAgICAgIHRoaXMuX3RleHRSZW5kZXJJbmZvID0gdGV4dFJlbmRlckluZm87XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZXNcbiAgICAgICAgICB0aGlzLmdlb21ldHJ5LnVwZGF0ZUdseXBocyhcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmNodW5rZWRCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaENvbG9yc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYWQgZXh0cmEgc3luYyByZXF1ZXN0cyBxdWV1ZWQgdXAsIGtpY2sgaXQgb2ZmXG4gICAgICAgICAgY29uc3QgcXVldWVkID0gdGhpcy5fcXVldWVkU3luY3M7XG4gICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVkU3luY3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3luYygoKSA9PiB7XG4gICAgICAgICAgICAgIHF1ZXVlZC5mb3JFYWNoKGZuID0+IGZuICYmIGZuKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNDb21wbGV0ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYSBzeW5jIGlmIG5lZWRlZCAtIG5vdGUgaXQgd29uJ3QgY29tcGxldGUgdW50aWwgbmV4dCBmcmFtZSBhdCB0aGVcbiAgICogZWFybGllc3Qgc28gaWYgcG9zc2libGUgaXQncyBhIGdvb2QgaWRlYSB0byBjYWxsIHN5bmMoKSBtYW51YWxseSBhcyBzb29uIGFzXG4gICAqIGFsbCB0aGUgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uQmVmb3JlUmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgdGhpcy5zeW5jKCk7XG5cbiAgICAvLyBUaGlzIG1heSBub3QgYWx3YXlzIGJlIGEgdGV4dCBtYXRlcmlhbCwgZS5nLiBpZiB0aGVyZSdzIGEgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCBwcmVzZW50XG4gICAgaWYgKG1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIGZvcmNlIHRoZSBtYXRlcmlhbCB0byBGcm9udFNpZGUgdG8gYXZvaWQgdGhlIGRvdWJsZS1kcmF3LWNhbGwgcGVyZm9ybWFuY2UgaGl0XG4gICAgLy8gaW50cm9kdWNlZCBpbiBUaHJlZS5qcyByMTMwOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjE5NjcgLSBUaGUgc2lkZWRuZXNzXG4gICAgLy8gaXMgaW5zdGVhZCBhcHBsaWVkIHZpYSBkcmF3UmFuZ2UgaW4gdGhlIEdseXBoc0dlb21ldHJ5LlxuICAgIG1hdGVyaWFsLl9oYWRPd25TaWRlID0gbWF0ZXJpYWwuaGFzT3duUHJvcGVydHkoJ3NpZGUnKTtcbiAgICB0aGlzLmdlb21ldHJ5LnNldFNpZGUobWF0ZXJpYWwuX2FjdHVhbFNpZGUgPSBtYXRlcmlhbC5zaWRlKTtcbiAgICBtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuICB9XG5cbiAgb25BZnRlclJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWF0ZXJpYWwgc2lkZVxuICAgIGlmIChtYXRlcmlhbC5faGFkT3duU2lkZSkge1xuICAgICAgbWF0ZXJpYWwuc2lkZSA9IG1hdGVyaWFsLl9hY3R1YWxTaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWF0ZXJpYWwuc2lkZTsgLy8gYmFjayB0byBpbmhlcml0aW5nIGZyb20gYmFzZSBtYXRlcmlhbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCB0byBkaXNwb3NlIHRoZSBnZW9tZXRyeSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICogc2hhcmluZyB0aGUgc2FtZSBiYXNlIG1hdGVyaWFsIGl0IHdpbGwgcmVzdWx0IGluIGEgcGF1c2UgbmV4dCBmcmFtZSBhcyB0aGUgcHJvZ3JhbVxuICAgKiBpcyByZWNvbXBpbGVkLiBJbnN0ZWFkIHVzZXJzIGNhbiBkaXNwb3NlIHRoZSBiYXNlIG1hdGVyaWFsIG1hbnVhbGx5LCBsaWtlIG5vcm1hbCxcbiAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICogQHJlYWRvbmx5XG4gICAqIFRoZSBjdXJyZW50IHByb2Nlc3NlZCByZW5kZXJpbmcgZGF0YSBmb3IgdGhpcyBUZXh0TWVzaCwgcmV0dXJuZWQgYnkgdGhlIFRleHRCdWlsZGVyIGFmdGVyXG4gICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAqIHRoZSBhc3luY2hyb3VzIGBzeW5jKClgIHByb2Nlc3MgY29tcGxldGVzLlxuICAgKi9cbiAgZ2V0IHRleHRSZW5kZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0UmVuZGVySW5mbyB8fCBudWxsXG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0TWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHRleHQgb3V0bGluZSBpcyBjb25maWd1cmVkLCByZW5kZXIgaXQgYXMgYSBwcmVsaW1pbmFyeSBkcmF3IHVzaW5nIFRocmVlJ3MgbXVsdGktbWF0ZXJpYWxcbiAgICAvLyBmZWF0dXJlIChzZWUgR2x5cGhzR2VvbWV0cnkgd2hpY2ggc2V0cyB1cCBgZ3JvdXBzYCBmb3IgdGhpcyBwdXJwb3NlKSBEb2luZyBpdCB3aXRoIG11bHRpXG4gICAgLy8gbWF0ZXJpYWxzIGVuc3VyZXMgdGhlIGxheWVycyBhcmUgYWx3YXlzIHJlbmRlcmVkIGNvbnNlY3V0aXZlbHkgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuICAgIC8vIEVhY2ggbGF5ZXIgd2lsbCB0cmlnZ2VyIG9uQmVmb3JlUmVuZGVyIHdpdGggdGhlIGFwcHJvcHJpYXRlIG1hdGVyaWFsLlxuICAgIGlmICh0aGlzLm91dGxpbmVXaWR0aCB8fCB0aGlzLm91dGxpbmVCbHVyIHx8IHRoaXMub3V0bGluZU9mZnNldFggfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WSkge1xuICAgICAgbGV0IG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bDtcbiAgICAgIGlmICghb3V0bGluZU1hdGVyaWFsKSB7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bCA9IE9iamVjdC5jcmVhdGUoZGVyaXZlZE1hdGVyaWFsLCB7XG4gICAgICAgICAgaWQ6IHt2YWx1ZTogZGVyaXZlZE1hdGVyaWFsLmlkICsgMC4xfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbCA9IHRydWU7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5tYXAgPSBudWxsOyAvLz8/P1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwsXG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgfVxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICBpZiAoYmFzZU1hdGVyaWFsICYmIGJhc2VNYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkgeyAvL3ByZXZlbnQgZG91YmxlLWRlcml2YXRpb25cbiAgICAgIHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbC5iYXNlTWF0ZXJpYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZ2x5cGhHZW9tZXRyeURldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5kZXRhaWxcbiAgfVxuICBzZXQgZ2x5cGhHZW9tZXRyeURldGFpbChkZXRhaWwpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmRldGFpbCA9IGRldGFpbDtcbiAgfVxuXG4gIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1c1xuICB9XG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1cyA9IHI7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREZXB0aE1hdGVyaWFsKClcbiAgfVxuICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gIH1cblxuICBfcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCkge1xuICAgIGNvbnN0IGlzT3V0bGluZSA9IG1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIGNvbnN0IHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICBpZiAodGV4dEluZm8pIHtcbiAgICAgIGNvbnN0IHtzZGZUZXh0dXJlLCBibG9ja0JvdW5kc30gPSB0ZXh0SW5mbztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlLnZhbHVlID0gc2RmVGV4dHVyZTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlU2l6ZS52YWx1ZS5zZXQoc2RmVGV4dHVyZS5pbWFnZS53aWR0aCwgc2RmVGV4dHVyZS5pbWFnZS5oZWlnaHQpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkdseXBoU2l6ZS52YWx1ZSA9IHRleHRJbmZvLnNkZkdseXBoU2l6ZTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZFeHBvbmVudC52YWx1ZSA9IHRleHRJbmZvLnNkZkV4cG9uZW50O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVRvdGFsQm91bmRzLnZhbHVlLmZyb21BcnJheShibG9ja0JvdW5kcyk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthVXNlR2x5cGhDb2xvcnMudmFsdWUgPSAhaXNPdXRsaW5lICYmICEhdGV4dEluZm8uZ2x5cGhDb2xvcnM7XG5cbiAgICAgIGxldCBkaXN0YW5jZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYmx1clJhZGl1cyA9IDA7XG4gICAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgbGV0IGZpbGxPcGFjaXR5O1xuICAgICAgbGV0IHN0cm9rZU9wYWNpdHk7XG4gICAgICBsZXQgc3Ryb2tlQ29sb3I7XG4gICAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgICBsZXQgb2Zmc2V0WSA9IDA7XG5cbiAgICAgIGlmIChpc091dGxpbmUpIHtcbiAgICAgICAgbGV0IHtvdXRsaW5lV2lkdGgsIG91dGxpbmVPZmZzZXRYLCBvdXRsaW5lT2Zmc2V0WSwgb3V0bGluZUJsdXIsIG91dGxpbmVPcGFjaXR5fSA9IHRoaXM7XG4gICAgICAgIGRpc3RhbmNlT2Zmc2V0ID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVXaWR0aCkgfHwgMDtcbiAgICAgICAgYmx1clJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lQmx1cikgfHwgMCk7XG4gICAgICAgIGZpbGxPcGFjaXR5ID0gb3V0bGluZU9wYWNpdHk7XG4gICAgICAgIG9mZnNldFggPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFgpIHx8IDA7XG4gICAgICAgIG9mZnNldFkgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFkpIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJva2VXaWR0aCA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudCh0aGlzLnN0cm9rZVdpZHRoKSB8fCAwKTtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VDb2xvci52YWx1ZS5zZXQoc3Ryb2tlQ29sb3IgPT0gbnVsbCA/IGRlZmF1bHRTdHJva2VDb2xvciA6IHN0cm9rZUNvbG9yKTtcbiAgICAgICAgICBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgICAgIGlmIChzdHJva2VPcGFjaXR5ID09IG51bGwpIHN0cm9rZU9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxPcGFjaXR5ID0gdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgdW5pZm9ybXMudVRyb2lrYURpc3RhbmNlT2Zmc2V0LnZhbHVlID0gZGlzdGFuY2VPZmZzZXQ7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthUG9zaXRpb25PZmZzZXQudmFsdWUuc2V0KG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUJsdXJSYWRpdXMudmFsdWUgPSBibHVyUmFkaXVzO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZVdpZHRoLnZhbHVlID0gc3Ryb2tlV2lkdGg7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlT3BhY2l0eS52YWx1ZSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthRmlsbE9wYWNpdHkudmFsdWUgPSBmaWxsT3BhY2l0eSA9PSBudWxsID8gMSA6IGZpbGxPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlID0gdGhpcy5jdXJ2ZVJhZGl1cyB8fCAwO1xuXG4gICAgICBsZXQgY2xpcFJlY3QgPSB0aGlzLmNsaXBSZWN0O1xuICAgICAgaWYgKGNsaXBSZWN0ICYmIEFycmF5LmlzQXJyYXkoY2xpcFJlY3QpICYmIGNsaXBSZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuZnJvbUFycmF5KGNsaXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGNsaXBwaW5nIC0gY2hvb3NlIGEgZmluaXRlIHJlY3QgdGhhdCBzaG91bGRuJ3QgZXZlciBiZSByZWFjaGVkIGJ5IG92ZXJmbG93aW5nIGdseXBocyBvciBvdXRsaW5lc1xuICAgICAgICBjb25zdCBwYWQgPSAodGhpcy5mb250U2l6ZSB8fCAwLjEpICogMTAwO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuc2V0KFxuICAgICAgICAgIGJsb2NrQm91bmRzWzBdIC0gcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzFdIC0gcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzJdICsgcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzNdICsgcGFkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmdlb21ldHJ5LmFwcGx5Q2xpcFJlY3QodW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlKTtcbiAgICB9XG4gICAgdW5pZm9ybXMudVRyb2lrYVNERkRlYnVnLnZhbHVlID0gISF0aGlzLmRlYnVnU0RGO1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSAhIXRoaXMuZGVwdGhPZmZzZXQ7XG4gICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMuZGVwdGhPZmZzZXQgfHwgMDtcblxuICAgIC8vIFNob3J0Y3V0IGZvciBzZXR0aW5nIG1hdGVyaWFsIGNvbG9yIHZpYSBgY29sb3JgIHByb3Agb24gdGhlIG1lc2g7IHRoaXMgaXNcbiAgICAvLyBhcHBsaWVkIG9ubHkgdG8gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gYXZvaWQgbXV0YXRpbmcgYSBzaGFyZWQgYmFzZSBtYXRlcmlhbC5cbiAgICBjb25zdCBjb2xvciA9IGlzT3V0bGluZSA/ICh0aGlzLm91dGxpbmVDb2xvciB8fCAwKSA6IHRoaXMuY29sb3I7XG5cbiAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIG1hdGVyaWFsLmNvbG9yOyAvL2luaGVyaXQgZnJvbSBiYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbG9yT2JqID0gbWF0ZXJpYWwuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykgPyBtYXRlcmlhbC5jb2xvciA6IChtYXRlcmlhbC5jb2xvciA9IG5ldyBDb2xvcigpKTtcbiAgICAgIGlmIChjb2xvciAhPT0gY29sb3JPYmouX2lucHV0IHx8IHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29sb3JPYmouc2V0KGNvbG9yT2JqLl9pbnB1dCA9IGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiYXNlIG9yaWVudGF0aW9uXG4gICAgbGV0IG9yaWVudCA9IHRoaXMub3JpZW50YXRpb24gfHwgZGVmYXVsdE9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSBtYXRlcmlhbC5fb3JpZW50YXRpb24pIHtcbiAgICAgIGxldCByb3RNYXQgPSB1bmlmb3Jtcy51VHJvaWthT3JpZW50LnZhbHVlO1xuICAgICAgb3JpZW50ID0gb3JpZW50LnJlcGxhY2UoL1teLSt4eXpdL2csICcnKTtcbiAgICAgIGxldCBtYXRjaCA9IG9yaWVudCAhPT0gZGVmYXVsdE9yaWVudCAmJiBvcmllbnQubWF0Y2goL14oWy0rXSkoW3h5el0pKFstK10pKFt4eXpdKSQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgWywgaFNpZ24sIGhBeGlzLCB2U2lnbiwgdkF4aXNdID0gbWF0Y2g7XG4gICAgICAgIHRlbXBWZWMzYS5zZXQoMCwgMCwgMClbaEF4aXNdID0gaFNpZ24gPT09ICctJyA/IDEgOiAtMTtcbiAgICAgICAgdGVtcFZlYzNiLnNldCgwLCAwLCAwKVt2QXhpc10gPSB2U2lnbiA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICB0ZW1wTWF0NC5sb29rQXQob3JpZ2luLCB0ZW1wVmVjM2EuY3Jvc3ModGVtcFZlYzNiKSwgdGVtcFZlYzNiKTtcbiAgICAgICAgcm90TWF0LnNldEZyb21NYXRyaXg0KHRlbXBNYXQ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdE1hdC5pZGVudGl0eSgpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwuX29yaWVudGF0aW9uID0gb3JpZW50O1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVBlcmNlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG1hdGNoID0gdmFsdWUubWF0Y2goL14oLT9bXFxkLl0rKSUkLyk7XG4gICAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICAgIHZhbHVlID0gKGlzTmFOKHBjdCkgPyAwIDogcGN0IC8gMTAwKSAqIHRoaXMuZm9udFNpemU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIGxvY2FsIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICovXG4gIGxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHMocG9zaXRpb24sIHRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcbiAgICB0YXJnZXQuY29weShwb3NpdGlvbik7IC8vc2ltcGxlIG5vbi1jdXJ2ZWQgY2FzZSBpcyAxOjFcbiAgICBjb25zdCByID0gdGhpcy5jdXJ2ZVJhZGl1cztcbiAgICBpZiAocikgeyAvL2ZsYXR0ZW4gdGhlIGN1cnZlXG4gICAgICB0YXJnZXQueCA9IE1hdGguYXRhbjIocG9zaXRpb24ueCwgTWF0aC5hYnMocikgLSBNYXRoLmFicyhwb3NpdGlvbi56KSkgKiBNYXRoLmFicyhyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIHdvcmxkIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICovXG4gIHdvcmxkUG9zaXRpb25Ub1RleHRDb29yZHMocG9zaXRpb24sIHRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcbiAgICB0ZW1wVmVjM2EuY29weShwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQb3NpdGlvblRvVGV4dENvb3Jkcyh0aGlzLndvcmxkVG9Mb2NhbCh0ZW1wVmVjM2EpLCB0YXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlIEN1c3RvbSByYXljYXN0aW5nIHRvIHRlc3QgYWdhaW5zdCB0aGUgd2hvbGUgdGV4dCBibG9jaydzIG1heCByZWN0YW5ndWxhciBib3VuZHNcbiAgICogVE9ETyBpcyB0aGVyZSBhbnkgcmVhc29uIHRvIG1ha2UgdGhpcyBtb3JlIGdyYW51bGFyLCBsaWtlIHdpdGhpbiBpbmRpdmlkdWFsIGxpbmUgb3IgZ2x5cGggcmVjdHM/XG4gICAqL1xuICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgIGNvbnN0IHt0ZXh0UmVuZGVySW5mbywgY3VydmVSYWRpdXN9ID0gdGhpcztcbiAgICBpZiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzO1xuICAgICAgY29uc3QgcmF5Y2FzdE1lc2ggPSBjdXJ2ZVJhZGl1cyA/IGdldEN1cnZlZFJheWNhc3RNZXNoKCkgOiBnZXRGbGF0UmF5Y2FzdE1lc2goKTtcbiAgICAgIGNvbnN0IGdlb20gPSByYXljYXN0TWVzaC5nZW9tZXRyeTtcbiAgICAgIGNvbnN0IHtwb3NpdGlvbiwgdXZ9ID0gZ2VvbS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1di5jb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB4ID0gYm91bmRzWzBdICsgKHV2LmdldFgoaSkgKiAoYm91bmRzWzJdIC0gYm91bmRzWzBdKSk7XG4gICAgICAgIGNvbnN0IHkgPSBib3VuZHNbMV0gKyAodXYuZ2V0WShpKSAqIChib3VuZHNbM10gLSBib3VuZHNbMV0pKTtcbiAgICAgICAgbGV0IHogPSAwO1xuICAgICAgICBpZiAoY3VydmVSYWRpdXMpIHtcbiAgICAgICAgICB6ID0gY3VydmVSYWRpdXMgLSBNYXRoLmNvcyh4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgICAgeCA9IE1hdGguc2luKHggLyBjdXJ2ZVJhZGl1cykgKiBjdXJ2ZVJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbi5zZXRYWVooaSwgeCwgeSwgeik7XG4gICAgICB9XG4gICAgICBnZW9tLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZTtcbiAgICAgIGdlb20uYm91bmRpbmdCb3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgcmF5Y2FzdE1lc2gubWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuICAgICAgcmF5Y2FzdE1lc2gubWF0ZXJpYWwuc2lkZSA9IHRoaXMubWF0ZXJpYWwuc2lkZTtcbiAgICAgIHRlbXBBcnJheS5sZW5ndGggPSAwO1xuICAgICAgcmF5Y2FzdE1lc2gucmF5Y2FzdChyYXljYXN0ZXIsIHRlbXBBcnJheSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wQXJyYXlbaV0ub2JqZWN0ID0gdGhpcztcbiAgICAgICAgaW50ZXJzZWN0cy5wdXNoKHRlbXBBcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29weShzb3VyY2UpIHtcbiAgICAvLyBQcmV2ZW50IGNvcHlpbmcgdGhlIGdlb21ldHJ5IHJlZmVyZW5jZSBzbyB3ZSBkb24ndCBlbmQgdXAgc2hhcmluZyBhdHRyaWJ1dGVzIGJldHdlZW4gaW5zdGFuY2VzXG4gICAgY29uc3QgZ2VvbSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tO1xuXG4gICAgQ09QWUFCTEVfUFJPUFMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHRoaXNbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcylcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSBzZXR0ZXJzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRleHQgbGF5b3V0OlxuU1lOQ0FCTEVfUFJPUFMuZm9yRWFjaChwcm9wID0+IHtcbiAgY29uc3QgcHJpdmF0ZUtleSA9ICdfcHJpdmF0ZV8nICsgcHJvcDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV1cbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW3ByaXZhdGVLZXldKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vPT09IFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggY2FyZXRzIGFuZCBzZWxlY3Rpb24gcmFuZ2VzID09PS8vXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVGV4dENhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIHggcG9zaXRpb24gb2YgdGhlIGNhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgcG9zaXRpb24gb2YgdGhlIGNhcmV0J3MgYm90dG9tXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNoYXJJbmRleCAtIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nIG9mIHRoaXMgY2FyZXQncyB0YXJnZXRcbiAqICAgY2hhcmFjdGVyOyB0aGUgY2FyZXQgd2lsbCBiZSBmb3IgdGhlIHBvc2l0aW9uIF9iZWZvcmVfIHRoYXQgY2hhcmFjdGVyLlxuICovXG5cbi8qKlxuICogR2l2ZW4gYSBsb2NhbCB4L3kgY29vcmRpbmF0ZSBpbiB0aGUgdGV4dCBibG9jayBwbGFuZSwgZmluZCB0aGUgbmVhcmVzdCBjYXJldCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvIC0gYSByZXN1bHQgb2JqZWN0IGZyb20gVGV4dEJ1aWxkZXIjZ2V0VGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7VGV4dENhcmV0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FyZXRBdFBvaW50KHRleHRSZW5kZXJJbmZvLCB4LCB5KSB7XG4gIGxldCBjbG9zZXN0Q2FyZXQgPSBudWxsO1xuICBjb25zdCB7Y2FyZXRIZWlnaHR9ID0gdGV4dFJlbmRlckluZm87XG4gIGNvbnN0IGNhcmV0c0J5Um93ID0gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbyk7XG5cbiAgLy8gRmluZCBuZWFyZXN0IHJvdyBieSB5IGZpcnN0XG4gIGxldCBjbG9zZXN0Um93WSA9IEluZmluaXR5O1xuICBjYXJldHNCeVJvdy5mb3JFYWNoKChjYXJldHMsIHJvd1kpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoeSAtIChyb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkgPCBNYXRoLmFicyh5IC0gKGNsb3Nlc3RSb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkpIHtcbiAgICAgIGNsb3Nlc3RSb3dZID0gcm93WTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gIGNhcmV0c0J5Um93LmdldChjbG9zZXN0Um93WSkuZm9yRWFjaChjYXJldCA9PiB7XG4gICAgaWYgKCFjbG9zZXN0Q2FyZXQgfHwgTWF0aC5hYnMoeCAtIGNhcmV0LngpIDwgTWF0aC5hYnMoeCAtIGNsb3Nlc3RDYXJldC54KSkge1xuICAgICAgY2xvc2VzdENhcmV0ID0gY2FyZXQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsb3Nlc3RDYXJldFxufVxuXG5cbmNvbnN0IF9yZWN0c0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHaXZlbiBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBpbmRleGVzLCByZXR1cm4gYSBsaXN0IG9mIHJlY3RhbmdsZXMgY292ZXJpbmcgYWxsIHRoZVxuICogY2hhcmFjdGVycyB3aXRoaW4gdGhhdCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgaW4gdGhlIHNlbGVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAqIEByZXR1cm4ge0FycmF5PHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219PiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3RzKHRleHRSZW5kZXJJbmZvLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZWN0cztcbiAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgLSB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgbGV0IHByZXZSZXN1bHQgPSBfcmVjdHNDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICAgIGlmIChwcmV2UmVzdWx0ICYmIHByZXZSZXN1bHQuc3RhcnQgPT09IHN0YXJ0ICYmIHByZXZSZXN1bHQuZW5kID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBwcmV2UmVzdWx0LnJlY3RzXG4gICAgfVxuXG4gICAgY29uc3Qge2NhcmV0UG9zaXRpb25zLCBjYXJldEhlaWdodH0gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgIC8vIGEgbmV3IHJlY3Qgd2hlbmV2ZXIgcmVhY2hpbmcgYSBuZXcgbGluZSBvciBhIG5ldyBiaWRpIGRpcmVjdGlvblxuICAgIHJlY3RzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogM107XG4gICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMV07XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMl07XG4gICAgICBpZiAoIWN1cnJlbnRSZWN0IHx8IGJvdHRvbSAhPT0gY3VycmVudFJlY3QuYm90dG9tIHx8IGxlZnQgPiBjdXJyZW50UmVjdC5yaWdodCB8fCByaWdodCA8IGN1cnJlbnRSZWN0LmxlZnQpIHtcbiAgICAgICAgY3VycmVudFJlY3QgPSB7XG4gICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgcmlnaHQ6IC1JbmZpbml0eSxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICB0b3A6IGJvdHRvbSArIGNhcmV0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHJlY3RzLnB1c2goY3VycmVudFJlY3QpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlY3QubGVmdCA9IE1hdGgubWluKGxlZnQsIGN1cnJlbnRSZWN0LmxlZnQpO1xuICAgICAgY3VycmVudFJlY3QucmlnaHQgPSBNYXRoLm1heChyaWdodCwgY3VycmVudFJlY3QucmlnaHQpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGFueSBvdmVybGFwcGluZyByZWN0cywgZS5nLiB0aG9zZSBmb3JtZWQgYnkgYWRqYWNlbnQgYmlkaSBydW5zXG4gICAgcmVjdHMuc29ydCgoYSwgYikgPT4gYi5ib3R0b20gLSBhLmJvdHRvbSB8fCBhLmxlZnQgLSBiLmxlZnQpO1xuICAgIGZvciAobGV0IGkgPSByZWN0cy5sZW5ndGggLSAxOyBpLS0gPiAwOykge1xuICAgICAgY29uc3QgcmVjdEEgPSByZWN0c1tpXTtcbiAgICAgIGNvbnN0IHJlY3RCID0gcmVjdHNbaSArIDFdO1xuICAgICAgaWYgKHJlY3RBLmJvdHRvbSA9PT0gcmVjdEIuYm90dG9tICYmIHJlY3RBLmxlZnQgPD0gcmVjdEIucmlnaHQgJiYgcmVjdEEucmlnaHQgPj0gcmVjdEIubGVmdCkge1xuICAgICAgICByZWN0Qi5sZWZ0ID0gTWF0aC5taW4ocmVjdEIubGVmdCwgcmVjdEEubGVmdCk7XG4gICAgICAgIHJlY3RCLnJpZ2h0ID0gTWF0aC5tYXgocmVjdEIucmlnaHQsIHJlY3RBLnJpZ2h0KTtcbiAgICAgICAgcmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWN0c0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywge3N0YXJ0LCBlbmQsIHJlY3RzfSk7XG4gIH1cbiAgcmV0dXJuIHJlY3RzXG59XG5cbmNvbnN0IF9jYXJldHNCeVJvd0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gIGxldCBjYXJldHNCeVJvdyA9IF9jYXJldHNCeVJvd0NhY2hlLmdldCh0ZXh0UmVuZGVySW5mbyk7XG4gIGlmICghY2FyZXRzQnlSb3cpIHtcbiAgICBjb25zdCB7Y2FyZXRQb3NpdGlvbnMsIGNhcmV0SGVpZ2h0fSA9IHRleHRSZW5kZXJJbmZvO1xuICAgIGNhcmV0c0J5Um93ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IHJvd1kgPSBjYXJldFBvc2l0aW9uc1tpICsgMl07XG4gICAgICBsZXQgcm93Q2FyZXRzID0gY2FyZXRzQnlSb3cuZ2V0KHJvd1kpO1xuICAgICAgaWYgKCFyb3dDYXJldHMpIHtcbiAgICAgICAgY2FyZXRzQnlSb3cuc2V0KHJvd1ksIHJvd0NhcmV0cyA9IFtdKTtcbiAgICAgIH1cbiAgICAgIHJvd0NhcmV0cy5wdXNoKHtcbiAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaV0sXG4gICAgICAgIHk6IHJvd1ksXG4gICAgICAgIGhlaWdodDogY2FyZXRIZWlnaHQsXG4gICAgICAgIGNoYXJJbmRleDogaSAvIDNcbiAgICAgIH0pO1xuICAgICAgLy8gQWRkIG9uZSBtb3JlIGNhcmV0IGFmdGVyIHRoZSBmaW5hbCBjaGFyXG4gICAgICBpZiAoaSArIDMgPj0gY2FyZXRQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJvd0NhcmV0cy5wdXNoKHtcbiAgICAgICAgICB4OiBjYXJldFBvc2l0aW9uc1tpICsgMV0sXG4gICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICBoZWlnaHQ6IGNhcmV0SGVpZ2h0LFxuICAgICAgICAgIGNoYXJJbmRleDogaSAvIDMgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIGNhcmV0c0J5Um93KTtcbiAgcmV0dXJuIGNhcmV0c0J5Um93XG59XG5cbmV4cG9ydCB7IEdseXBoc0dlb21ldHJ5LCBUZXh0LCBjb25maWd1cmVUZXh0QnVpbGRlciwgY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCwgZHVtcFNERlRleHR1cmVzLCBnZXRDYXJldEF0UG9pbnQsIGdldFNlbGVjdGlvblJlY3RzLCBwcmVsb2FkRm9udCwgdHlwZXNldHRlcldvcmtlck1vZHVsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n");

/***/ })

};
;