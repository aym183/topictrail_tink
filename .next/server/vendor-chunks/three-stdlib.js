"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/interactive/SelectionBox.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-stdlib/interactive/SelectionBox.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionBox: () => (/* binding */ SelectionBox)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst frustum = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\nconst center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tmpPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecNear = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecTopLeft = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecTopRight = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecDownRight = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecDownLeft = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecFarTopLeft = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecFarTopRight = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecFarDownRight = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vecFarDownLeft = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vectemp1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vectemp2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst vectemp3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera;\n    this.scene = scene;\n    this.startPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.endPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.collection = [];\n    this.deep = deep || Number.MAX_VALUE;\n  }\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint;\n    this.endPoint = endPoint || this.endPoint;\n    this.collection = [];\n    this.updateFrustum(this.startPoint, this.endPoint);\n    this.searchChildInFrustum(frustum, this.scene);\n    return this.collection;\n  }\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint;\n    endPoint = endPoint || this.endPoint;\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON;\n    }\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON;\n    }\n    this.camera.updateProjectionMatrix();\n    this.camera.updateMatrixWorld();\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint);\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n      endPoint.x = Math.max(startPoint.x, endPoint.x);\n      endPoint.y = Math.min(startPoint.y, endPoint.y);\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n      vecTopLeft.copy(tmpPoint);\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n      vecDownRight.copy(endPoint);\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vectemp1.copy(vecTopLeft).sub(vecNear);\n      vectemp2.copy(vecTopRight).sub(vecNear);\n      vectemp3.copy(vecDownRight).sub(vecNear);\n      vectemp1.normalize();\n      vectemp2.normalize();\n      vectemp3.normalize();\n      vectemp1.multiplyScalar(this.deep);\n      vectemp2.multiplyScalar(this.deep);\n      vectemp3.multiplyScalar(this.deep);\n      vectemp1.add(vecNear);\n      vectemp2.add(vecNear);\n      vectemp3.add(vecNear);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n      planes[5].normal.multiplyScalar(-1);\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x);\n      const top = Math.max(startPoint.y, endPoint.y);\n      const right = Math.max(startPoint.x, endPoint.x);\n      const down = Math.min(startPoint.y, endPoint.y);\n      vecTopLeft.set(left, top, -1);\n      vecTopRight.set(right, top, -1);\n      vecDownRight.set(right, down, -1);\n      vecDownLeft.set(left, down, -1);\n      vecFarTopLeft.set(left, top, 1);\n      vecFarTopRight.set(right, top, 1);\n      vecFarDownRight.set(right, down, 1);\n      vecFarDownLeft.set(left, down, 1);\n      vecTopLeft.unproject(this.camera);\n      vecTopRight.unproject(this.camera);\n      vecDownRight.unproject(this.camera);\n      vecDownLeft.unproject(this.camera);\n      vecFarTopLeft.unproject(this.camera);\n      vecFarTopRight.unproject(this.camera);\n      vecFarDownRight.unproject(this.camera);\n      vecFarDownLeft.unproject(this.camera);\n      var planes = frustum.planes;\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n      planes[5].normal.multiplyScalar(-1);\n    } else {\n      console.error(\"THREE.SelectionBox: Unsupported camera type.\");\n    }\n  }\n  searchChildInFrustum(frustum2, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== void 0) {\n        if (object.geometry.boundingSphere === null)\n          object.geometry.computeBoundingSphere();\n        center.copy(object.geometry.boundingSphere.center);\n        center.applyMatrix4(object.matrixWorld);\n        if (frustum2.containsPoint(center)) {\n          this.collection.push(object);\n        }\n      }\n    }\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum2, object.children[x]);\n      }\n    }\n  }\n}\n\n//# sourceMappingURL=SelectionBox.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2ludGVyYWN0aXZlL1NlbGVjdGlvbkJveC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUN6QyxvQkFBb0IsMENBQU87QUFDM0IsbUJBQW1CLDBDQUFPO0FBQzFCLHFCQUFxQiwwQ0FBTztBQUM1QixvQkFBb0IsMENBQU87QUFDM0IsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQix5QkFBeUIsMENBQU87QUFDaEMsd0JBQXdCLDBDQUFPO0FBQy9CLDBCQUEwQiwwQ0FBTztBQUNqQywyQkFBMkIsMENBQU87QUFDbEMsNEJBQTRCLDBDQUFPO0FBQ25DLDJCQUEyQiwwQ0FBTztBQUNsQyxxQkFBcUIsMENBQU87QUFDNUIscUJBQXFCLDBDQUFPO0FBQzVCLHFCQUFxQiwwQ0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBTztBQUNqQyx3QkFBd0IsMENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvaW50ZXJhY3RpdmUvU2VsZWN0aW9uQm94LmpzP2ZiN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnJ1c3R1bSwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG5jb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgdG1wUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgdmVjTmVhciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWNUb3BMZWZ0ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHZlY1RvcFJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHZlY0Rvd25SaWdodCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWNEb3duTGVmdCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWNGYXJUb3BMZWZ0ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHZlY0ZhclRvcFJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHZlY0ZhckRvd25SaWdodCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWNGYXJEb3duTGVmdCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWN0ZW1wMSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWN0ZW1wMiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2ZWN0ZW1wMyA9IG5ldyBWZWN0b3IzKCk7XG5jbGFzcyBTZWxlY3Rpb25Cb3gge1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHNjZW5lLCBkZWVwKSB7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuc3RhcnRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5lbmRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gW107XG4gICAgdGhpcy5kZWVwID0gZGVlcCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIHNlbGVjdChzdGFydFBvaW50LCBlbmRQb2ludCkge1xuICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQgfHwgdGhpcy5zdGFydFBvaW50O1xuICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludCB8fCB0aGlzLmVuZFBvaW50O1xuICAgIHRoaXMuY29sbGVjdGlvbiA9IFtdO1xuICAgIHRoaXMudXBkYXRlRnJ1c3R1bSh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xuICAgIHRoaXMuc2VhcmNoQ2hpbGRJbkZydXN0dW0oZnJ1c3R1bSwgdGhpcy5zY2VuZSk7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbjtcbiAgfVxuICB1cGRhdGVGcnVzdHVtKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQgfHwgdGhpcy5zdGFydFBvaW50O1xuICAgIGVuZFBvaW50ID0gZW5kUG9pbnQgfHwgdGhpcy5lbmRQb2ludDtcbiAgICBpZiAoc3RhcnRQb2ludC54ID09PSBlbmRQb2ludC54KSB7XG4gICAgICBlbmRQb2ludC54ICs9IE51bWJlci5FUFNJTE9OO1xuICAgIH1cbiAgICBpZiAoc3RhcnRQb2ludC55ID09PSBlbmRQb2ludC55KSB7XG4gICAgICBlbmRQb2ludC55ICs9IE51bWJlci5FUFNJTE9OO1xuICAgIH1cbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICBpZiAodGhpcy5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgdG1wUG9pbnQuY29weShzdGFydFBvaW50KTtcbiAgICAgIHRtcFBvaW50LnggPSBNYXRoLm1pbihzdGFydFBvaW50LngsIGVuZFBvaW50LngpO1xuICAgICAgdG1wUG9pbnQueSA9IE1hdGgubWF4KHN0YXJ0UG9pbnQueSwgZW5kUG9pbnQueSk7XG4gICAgICBlbmRQb2ludC54ID0gTWF0aC5tYXgoc3RhcnRQb2ludC54LCBlbmRQb2ludC54KTtcbiAgICAgIGVuZFBvaW50LnkgPSBNYXRoLm1pbihzdGFydFBvaW50LnksIGVuZFBvaW50LnkpO1xuICAgICAgdmVjTmVhci5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5jYW1lcmEubWF0cml4V29ybGQpO1xuICAgICAgdmVjVG9wTGVmdC5jb3B5KHRtcFBvaW50KTtcbiAgICAgIHZlY1RvcFJpZ2h0LnNldChlbmRQb2ludC54LCB0bXBQb2ludC55LCAwKTtcbiAgICAgIHZlY0Rvd25SaWdodC5jb3B5KGVuZFBvaW50KTtcbiAgICAgIHZlY0Rvd25MZWZ0LnNldCh0bXBQb2ludC54LCBlbmRQb2ludC55LCAwKTtcbiAgICAgIHZlY1RvcExlZnQudW5wcm9qZWN0KHRoaXMuY2FtZXJhKTtcbiAgICAgIHZlY1RvcFJpZ2h0LnVucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICB2ZWNEb3duUmlnaHQudW5wcm9qZWN0KHRoaXMuY2FtZXJhKTtcbiAgICAgIHZlY0Rvd25MZWZ0LnVucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICB2ZWN0ZW1wMS5jb3B5KHZlY1RvcExlZnQpLnN1Yih2ZWNOZWFyKTtcbiAgICAgIHZlY3RlbXAyLmNvcHkodmVjVG9wUmlnaHQpLnN1Yih2ZWNOZWFyKTtcbiAgICAgIHZlY3RlbXAzLmNvcHkodmVjRG93blJpZ2h0KS5zdWIodmVjTmVhcik7XG4gICAgICB2ZWN0ZW1wMS5ub3JtYWxpemUoKTtcbiAgICAgIHZlY3RlbXAyLm5vcm1hbGl6ZSgpO1xuICAgICAgdmVjdGVtcDMubm9ybWFsaXplKCk7XG4gICAgICB2ZWN0ZW1wMS5tdWx0aXBseVNjYWxhcih0aGlzLmRlZXApO1xuICAgICAgdmVjdGVtcDIubXVsdGlwbHlTY2FsYXIodGhpcy5kZWVwKTtcbiAgICAgIHZlY3RlbXAzLm11bHRpcGx5U2NhbGFyKHRoaXMuZGVlcCk7XG4gICAgICB2ZWN0ZW1wMS5hZGQodmVjTmVhcik7XG4gICAgICB2ZWN0ZW1wMi5hZGQodmVjTmVhcik7XG4gICAgICB2ZWN0ZW1wMy5hZGQodmVjTmVhcik7XG4gICAgICB2YXIgcGxhbmVzID0gZnJ1c3R1bS5wbGFuZXM7XG4gICAgICBwbGFuZXNbMF0uc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHZlY05lYXIsIHZlY1RvcExlZnQsIHZlY1RvcFJpZ2h0KTtcbiAgICAgIHBsYW5lc1sxXS5zZXRGcm9tQ29wbGFuYXJQb2ludHModmVjTmVhciwgdmVjVG9wUmlnaHQsIHZlY0Rvd25SaWdodCk7XG4gICAgICBwbGFuZXNbMl0uc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHZlY0Rvd25SaWdodCwgdmVjRG93bkxlZnQsIHZlY05lYXIpO1xuICAgICAgcGxhbmVzWzNdLnNldEZyb21Db3BsYW5hclBvaW50cyh2ZWNEb3duTGVmdCwgdmVjVG9wTGVmdCwgdmVjTmVhcik7XG4gICAgICBwbGFuZXNbNF0uc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHZlY1RvcFJpZ2h0LCB2ZWNEb3duUmlnaHQsIHZlY0Rvd25MZWZ0KTtcbiAgICAgIHBsYW5lc1s1XS5zZXRGcm9tQ29wbGFuYXJQb2ludHModmVjdGVtcDMsIHZlY3RlbXAyLCB2ZWN0ZW1wMSk7XG4gICAgICBwbGFuZXNbNV0ubm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnRQb2ludC54LCBlbmRQb2ludC54KTtcbiAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWF4KHN0YXJ0UG9pbnQueSwgZW5kUG9pbnQueSk7XG4gICAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0UG9pbnQueCwgZW5kUG9pbnQueCk7XG4gICAgICBjb25zdCBkb3duID0gTWF0aC5taW4oc3RhcnRQb2ludC55LCBlbmRQb2ludC55KTtcbiAgICAgIHZlY1RvcExlZnQuc2V0KGxlZnQsIHRvcCwgLTEpO1xuICAgICAgdmVjVG9wUmlnaHQuc2V0KHJpZ2h0LCB0b3AsIC0xKTtcbiAgICAgIHZlY0Rvd25SaWdodC5zZXQocmlnaHQsIGRvd24sIC0xKTtcbiAgICAgIHZlY0Rvd25MZWZ0LnNldChsZWZ0LCBkb3duLCAtMSk7XG4gICAgICB2ZWNGYXJUb3BMZWZ0LnNldChsZWZ0LCB0b3AsIDEpO1xuICAgICAgdmVjRmFyVG9wUmlnaHQuc2V0KHJpZ2h0LCB0b3AsIDEpO1xuICAgICAgdmVjRmFyRG93blJpZ2h0LnNldChyaWdodCwgZG93biwgMSk7XG4gICAgICB2ZWNGYXJEb3duTGVmdC5zZXQobGVmdCwgZG93biwgMSk7XG4gICAgICB2ZWNUb3BMZWZ0LnVucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICB2ZWNUb3BSaWdodC51bnByb2plY3QodGhpcy5jYW1lcmEpO1xuICAgICAgdmVjRG93blJpZ2h0LnVucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICB2ZWNEb3duTGVmdC51bnByb2plY3QodGhpcy5jYW1lcmEpO1xuICAgICAgdmVjRmFyVG9wTGVmdC51bnByb2plY3QodGhpcy5jYW1lcmEpO1xuICAgICAgdmVjRmFyVG9wUmlnaHQudW5wcm9qZWN0KHRoaXMuY2FtZXJhKTtcbiAgICAgIHZlY0ZhckRvd25SaWdodC51bnByb2plY3QodGhpcy5jYW1lcmEpO1xuICAgICAgdmVjRmFyRG93bkxlZnQudW5wcm9qZWN0KHRoaXMuY2FtZXJhKTtcbiAgICAgIHZhciBwbGFuZXMgPSBmcnVzdHVtLnBsYW5lcztcbiAgICAgIHBsYW5lc1swXS5zZXRGcm9tQ29wbGFuYXJQb2ludHModmVjVG9wTGVmdCwgdmVjRmFyVG9wTGVmdCwgdmVjRmFyVG9wUmlnaHQpO1xuICAgICAgcGxhbmVzWzFdLnNldEZyb21Db3BsYW5hclBvaW50cyh2ZWNUb3BSaWdodCwgdmVjRmFyVG9wUmlnaHQsIHZlY0ZhckRvd25SaWdodCk7XG4gICAgICBwbGFuZXNbMl0uc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHZlY0ZhckRvd25SaWdodCwgdmVjRmFyRG93bkxlZnQsIHZlY0Rvd25MZWZ0KTtcbiAgICAgIHBsYW5lc1szXS5zZXRGcm9tQ29wbGFuYXJQb2ludHModmVjRmFyRG93bkxlZnQsIHZlY0ZhclRvcExlZnQsIHZlY1RvcExlZnQpO1xuICAgICAgcGxhbmVzWzRdLnNldEZyb21Db3BsYW5hclBvaW50cyh2ZWNUb3BSaWdodCwgdmVjRG93blJpZ2h0LCB2ZWNEb3duTGVmdCk7XG4gICAgICBwbGFuZXNbNV0uc2V0RnJvbUNvcGxhbmFyUG9pbnRzKHZlY0ZhckRvd25SaWdodCwgdmVjRmFyVG9wUmlnaHQsIHZlY0ZhclRvcExlZnQpO1xuICAgICAgcGxhbmVzWzVdLm5vcm1hbC5tdWx0aXBseVNjYWxhcigtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5TZWxlY3Rpb25Cb3g6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLlwiKTtcbiAgICB9XG4gIH1cbiAgc2VhcmNoQ2hpbGRJbkZydXN0dW0oZnJ1c3R1bTIsIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzKSB7XG4gICAgICBpZiAob2JqZWN0Lm1hdGVyaWFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG9iamVjdC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbClcbiAgICAgICAgICBvYmplY3QuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICAgIGNlbnRlci5jb3B5KG9iamVjdC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIpO1xuICAgICAgICBjZW50ZXIuYXBwbHlNYXRyaXg0KG9iamVjdC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIGlmIChmcnVzdHVtMi5jb250YWluc1BvaW50KGNlbnRlcikpIHtcbiAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24ucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvYmplY3QuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgdGhpcy5zZWFyY2hDaGlsZEluRnJ1c3R1bShmcnVzdHVtMiwgb2JqZWN0LmNoaWxkcmVuW3hdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFNlbGVjdGlvbkJveFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdGlvbkJveC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/interactive/SelectionBox.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/SVGLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGLoader: () => (/* binding */ SVGLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst COLOR_SPACE_SVG = \"srgb\";\nclass SVGLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.defaultDPI = 90;\n    this.defaultUnit = \"px\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1)\n        return;\n      const transform = getNodeTransform(node);\n      let isDefsNode = false;\n      let path = null;\n      switch (node.nodeName) {\n        case \"svg\":\n          style = parseStyle(node, style);\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\"))\n            path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          isDefsNode = true;\n          break;\n        case \"use\":\n          style = parseStyle(node, style);\n          const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n          const usedNodeId = href.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n          }\n          break;\n      }\n      if (path) {\n        if (style.fill !== void 0 && style.fill !== \"none\") {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n        }\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = { node, style };\n      }\n      const childNodes = node.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const node2 = childNodes[i];\n        if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n          continue;\n        }\n        parseNode(node2, style);\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n    function parsePathNode(node) {\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const control = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      const firstPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      if (d === \"\" || d === \"none\")\n        return null;\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data2 = command.slice(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5]\n              );\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              );\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)\n                continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5]\n              );\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data2);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data2, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0)\n                continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n              if (j === 0 && doSetFirstPoint === true)\n                firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n        return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1)\n          continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n        }\n      }\n    }\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n      const dx2 = (start.x - end.x) / 2;\n      const dy2 = (start.y - end.y) / 2;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag)\n        q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n      if (ux * vy - uy * vx < 0)\n        ang = -ang;\n      return ang;\n    }\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const bci = 1 - 0.551915024494;\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      path.moveTo(x + rx, y);\n      path.lineTo(x + w - rx, y);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      }\n      path.lineTo(x + w, y + h - ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      }\n      path.lineTo(x + rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      }\n      path.lineTo(x, y + ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseStyle(node, style) {\n      style = Object.assign({}, style);\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i) => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === void 0)\n          adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\"))\n              console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n        if (node.hasAttribute(svgName))\n          style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName])\n          style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\")\n          style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"fill-rule\", \"fillRule\");\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\", exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current2, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n        error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\")\n            result.push(Number(number));\n          else\n            result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n        if (state === SEP) {\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n      newNumber();\n      return result;\n    }\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = void 0;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n      const currentTransform2 = tempTransform0;\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\")\n            continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos);\n            const array = parseFloats(transformText.slice(openParPos + 1));\n            currentTransform2.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = 0;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform2.translate(tx, ty);\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n                  angle = array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    cx = array[1];\n                    cy = array[2];\n                  }\n                  tempTransform1.makeTranslation(-cx, -cy);\n                  tempTransform2.makeRotation(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.makeTranslation(cx, cy);\n                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform2.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform2);\n        }\n      }\n      return transform;\n    }\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n      function transfEllipseGeneric(curve) {\n        const a = curve.xRadius;\n        const b = curve.yRadius;\n        const cosTheta = Math.cos(curve.aRotation);\n        const sinTheta = Math.sin(curve.aRotation);\n        const v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(a * cosTheta, a * sinTheta, 0);\n        const v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b * sinTheta, b * cosTheta, 0);\n        const f1 = v1.applyMatrix3(m);\n        const f2 = v2.applyMatrix3(m);\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n        const mFInv = tempTransform1.copy(mF).invert();\n        const mFInvT = tempTransform2.copy(mFInv).transpose();\n        const mQ = mFInvT.multiply(mFInv);\n        const mQe = mQ.elements;\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n        const rt1sqrt = Math.sqrt(ed.rt1);\n        const rt2sqrt = Math.sqrt(ed.rt2);\n        curve.xRadius = 1 / rt1sqrt;\n        curve.yRadius = 1 / rt2sqrt;\n        curve.aRotation = Math.atan2(ed.sn, ed.cs);\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n          const transformAngle = (phi) => {\n            const { x: cosR, y: sinR } = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n            return Math.atan2(sinR, cosR);\n          };\n          curve.aStartAngle = transformAngle(curve.aStartAngle);\n          curve.aEndAngle = transformAngle(curve.aEndAngle);\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n      }\n      function transfEllipseNoSkew(curve) {\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        curve.xRadius *= sx;\n        curve.yRadius *= sy;\n        const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n        curve.aRotation += theta;\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1;\n          curve.aEndAngle *= -1;\n          curve.aClockwise = !curve.aClockwise;\n        }\n      }\n      const subPaths = path.subPaths;\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve);\n            } else {\n              transfEllipseNoSkew(curve);\n            }\n          }\n        }\n      }\n    }\n    function isTransformFlipped(m) {\n      const te = m.elements;\n      return te[0] * te[4] - te[1] * te[3] < 0;\n    }\n    function isTransformSkewed(m) {\n      const te = m.elements;\n      const basisDot = te[0] * te[3] + te[1] * te[4];\n      if (basisDot === 0)\n        return false;\n      const sx = getTransformScaleX(m);\n      const sy = getTransformScaleY(m);\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n    }\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    }\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t;\n      const sm = A + C;\n      const df = A - C;\n      const rt = Math.sqrt(df * df + 4 * B * B);\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt);\n        t = 1 / rt1;\n        rt2 = A * t * C - B * t * B;\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt);\n      } else {\n        rt1 = 0.5 * rt;\n        rt2 = -0.5 * rt;\n      }\n      if (df > 0) {\n        cs = df + rt;\n      } else {\n        cs = df - rt;\n      }\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = -2 * B / cs;\n        sn = 1 / Math.sqrt(1 + t * t);\n        cs = t * sn;\n      } else if (Math.abs(B) === 0) {\n        cs = 1;\n        sn = 0;\n      } else {\n        t = -0.5 * cs / B;\n        cs = 1 / Math.sqrt(1 + t * t);\n        sn = t * cs;\n      }\n      if (df > 0) {\n        t = cs;\n        cs = -sn;\n        sn = t;\n      }\n      return { rt1, rt2, cs, sn };\n    }\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n    const tempTransform1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n    const tempTransform2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n    const tempTransform3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n    const tempV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const currentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n    parseNode(xml.documentElement, {\n      fill: \"#000\",\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4\n    });\n    const data = { paths, xml: xml.documentElement };\n    return data;\n  }\n  static createShapes(shapePath) {\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return { x, y, t: classifyResult.t };\n          }\n        }\n        return null;\n      } else {\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return { x, y, t: t1 };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(\n            (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON\n          ) === void 0) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach((path) => {\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n      if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMinX2, centerBoundingBox.y), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scanlineMaxX2, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach((i2) => {\n        if (i2.identifier === simplePath.identifier) {\n          baseIntersections.push(i2);\n        } else {\n          otherIntersections.push(i2);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else if (_fillRule === \"nonzero\") {\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i2 = 0; i2 < stack.length; i2++) {\n          const identifier = stack[i2];\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n        return { identifier: simplePath.identifier, isHole, for: isHoleFor };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n      for (let i = 0; i < points.length; i++) {\n        const p2 = points[i];\n        if (p2.y > maxY) {\n          maxY = p2.y;\n        }\n        if (p2.y < minY) {\n          minY = p2.y;\n        }\n        if (p2.x > maxX) {\n          maxX = p2.x;\n        }\n        if (p2.x < minX) {\n          minX = p2.x;\n        }\n      }\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        curves: p.curves,\n        points,\n        isCW: three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new three__WEBPACK_IMPORTED_MODULE_0__.Box2(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(minX, minY), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier;\n    }\n    const isAHole = simplePaths.map(\n      (p) => isHoleTo(\n        p,\n        simplePaths,\n        scanlineMinX,\n        scanlineMaxX,\n        shapePath.userData ? shapePath.userData.style.fillRule : void 0\n      )\n    );\n    const shapesToReturn = [];\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new three__WEBPACK_IMPORTED_MODULE_0__.Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier];\n          const path = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    width = width !== void 0 ? width : 1;\n    color = color !== void 0 ? color : \"#000\";\n    lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n    lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n    miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    const tempV2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_6 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const tempV2_7 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const lastPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const lastPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const point0L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const point0R = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const currentPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const currentPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const nextPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const nextPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const innerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const outerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n    minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2)\n      return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0, u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          nextPoint = points[1];\n        } else\n          nextPoint = void 0;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== void 0) {\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1)\n          initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n        if (dot > Number.EPSILON) {\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                if (innerSideModified) {\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n      } else {\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1)\n        angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 0);\n      addVertex(currentPointR, u1, 1);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u, 1);\n          addVertex(innerPoint, u, 0);\n          addVertex(nextPointR, u, 1);\n        }\n      } else {\n        if (joinIsOnLeftSide2) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n      if (innerSideModified2) {\n        if (joinIsOnLeftSide2) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n            if (joinIsOnLeftSide2) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points2) {\n      let dupPoints = false;\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints)\n        return points2;\n      const newPoints = [];\n      newPoints.push(points2[0]);\n      for (let i = 1, n = points2.length - 1; i < n; i++) {\n        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n          newPoints.push(points2[i]);\n        }\n      }\n      newPoints.push(points2[points2.length - 1]);\n      return newPoints;\n    }\n  }\n}\n\n//# sourceMappingURL=SVGLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvU1ZHTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdKO0FBQ3hKO0FBQ0Esd0JBQXdCLHlDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDLHdCQUF3QiwwQ0FBTztBQUMvQiwwQkFBMEIsMENBQU87QUFDakMsNkJBQTZCLDBDQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBSTtBQUM5QjtBQUNBLHVCQUF1Qiw0Q0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUFJO0FBQzlCO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQ0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQixNQUFNLDBDQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBTztBQUN0QywrQkFBK0IsMENBQU87QUFDdEMsK0JBQStCLDBDQUFPO0FBQ3RDLCtCQUErQiwwQ0FBTztBQUN0Qyx1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLGlDQUFpQywwQ0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdEQUF3RDtBQUM1RixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQU87QUFDM0M7QUFDQSw0QkFBNEIsMENBQU8sMENBQTBDLDBDQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQVU7QUFDeEI7QUFDQSx5QkFBeUIsdUNBQUksS0FBSywwQ0FBTyxrQkFBa0IsMENBQU87QUFDbEU7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1Q0FBSTtBQUMvQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBYztBQUN2QywwQ0FBMEMseURBQXNCO0FBQ2hFLHdDQUF3Qyx5REFBc0I7QUFDOUQsb0NBQW9DLHlEQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU87QUFDaEMseUJBQXlCLDBDQUFPO0FBQ2hDLHlCQUF5QiwwQ0FBTztBQUNoQyx5QkFBeUIsMENBQU87QUFDaEMseUJBQXlCLDBDQUFPO0FBQ2hDLHlCQUF5QiwwQ0FBTztBQUNoQyx5QkFBeUIsMENBQU87QUFDaEMsMkJBQTJCLDBDQUFPO0FBQ2xDLDJCQUEyQiwwQ0FBTztBQUNsQyx3QkFBd0IsMENBQU87QUFDL0Isd0JBQXdCLDBDQUFPO0FBQy9CLDhCQUE4QiwwQ0FBTztBQUNyQyw4QkFBOEIsMENBQU87QUFDckMsMkJBQTJCLDBDQUFPO0FBQ2xDLDJCQUEyQiwwQ0FBTztBQUNsQywyQkFBMkIsMENBQU87QUFDbEMsMkJBQTJCLDBDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvU1ZHTG9hZGVyLmpzP2VlMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBNYXRyaXgzLCBWZWN0b3IyLCBWZWN0b3IzLCBTaGFwZVV0aWxzLCBCb3gyLCBTaGFwZSwgUGF0aCwgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIFNoYXBlUGF0aCB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgQ09MT1JfU1BBQ0VfU1ZHID0gXCJzcmdiXCI7XG5jbGFzcyBTVkdMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kZWZhdWx0RFBJID0gOTA7XG4gICAgdGhpcy5kZWZhdWx0VW5pdCA9IFwicHhcIjtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHNjb3BlLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbkxvYWQoc2NvcGUucGFyc2UodGV4dCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgcGFyc2UodGV4dCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBmdW5jdGlvbiBwYXJzZU5vZGUobm9kZSwgc3R5bGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXROb2RlVHJhbnNmb3JtKG5vZGUpO1xuICAgICAgbGV0IGlzRGVmc05vZGUgPSBmYWxzZTtcbiAgICAgIGxldCBwYXRoID0gbnVsbDtcbiAgICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgcGFyc2VDU1NTdHlsZXNoZWV0KG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJkXCIpKVxuICAgICAgICAgICAgcGF0aCA9IHBhcnNlUGF0aE5vZGUobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgc3R5bGUgPSBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKTtcbiAgICAgICAgICBwYXRoID0gcGFyc2VSZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgIHBhdGggPSBwYXJzZVBvbHlnb25Ob2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9seWxpbmVcIjpcbiAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgIHBhdGggPSBwYXJzZVBvbHlsaW5lTm9kZShub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgcGF0aCA9IHBhcnNlQ2lyY2xlTm9kZShub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgIHBhdGggPSBwYXJzZUVsbGlwc2VOb2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgIHN0eWxlID0gcGFyc2VTdHlsZShub2RlLCBzdHlsZSk7XG4gICAgICAgICAgcGF0aCA9IHBhcnNlTGluZU5vZGUobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWZzXCI6XG4gICAgICAgICAgaXNEZWZzTm9kZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1c2VcIjpcbiAgICAgICAgICBzdHlsZSA9IHBhcnNlU3R5bGUobm9kZSwgc3R5bGUpO1xuICAgICAgICAgIGNvbnN0IGhyZWYgPSBub2RlLmdldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcImhyZWZcIikgfHwgXCJcIjtcbiAgICAgICAgICBjb25zdCB1c2VkTm9kZUlkID0gaHJlZi5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgY29uc3QgdXNlZE5vZGUgPSBub2RlLnZpZXdwb3J0RWxlbWVudC5nZXRFbGVtZW50QnlJZCh1c2VkTm9kZUlkKTtcbiAgICAgICAgICBpZiAodXNlZE5vZGUpIHtcbiAgICAgICAgICAgIHBhcnNlTm9kZSh1c2VkTm9kZSwgc3R5bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTVkdMb2FkZXI6ICd1c2Ugbm9kZScgcmVmZXJlbmNlcyBub24tZXhpc3RlbnQgbm9kZSBpZDogXCIgKyB1c2VkTm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBpZiAoc3R5bGUuZmlsbCAhPT0gdm9pZCAwICYmIHN0eWxlLmZpbGwgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgcGF0aC5jb2xvci5zZXRTdHlsZShzdHlsZS5maWxsLCBDT0xPUl9TUEFDRV9TVkcpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybVBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIHBhdGgudXNlckRhdGEgPSB7IG5vZGUsIHN0eWxlIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUyID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGlzRGVmc05vZGUgJiYgbm9kZTIubm9kZU5hbWUgIT09IFwic3R5bGVcIiAmJiBub2RlMi5ub2RlTmFtZSAhPT0gXCJkZWZzXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZU5vZGUobm9kZTIsIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybS5jb3B5KHRyYW5zZm9ybVN0YWNrW3RyYW5zZm9ybVN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VQYXRoTm9kZShub2RlKSB7XG4gICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgY29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgY29uc3QgY29udHJvbCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIGxldCBpc0ZpcnN0UG9pbnQgPSB0cnVlO1xuICAgICAgbGV0IGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuICAgICAgY29uc3QgZCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZFwiKTtcbiAgICAgIGlmIChkID09PSBcIlwiIHx8IGQgPT09IFwibm9uZVwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGNvbW1hbmRzID0gZC5tYXRjaCgvW2EtZGYtel1bXmEtZGYtel0qL2dpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY29tbWFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNvbW1hbmQuY2hhckF0KDApO1xuICAgICAgICBjb25zdCBkYXRhMiA9IGNvbW1hbmQuc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICBpZiAoaXNGaXJzdFBvaW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgZG9TZXRGaXJzdFBvaW50ID0gdHJ1ZTtcbiAgICAgICAgICBpc0ZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtYmVycztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGogPT09IDApXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2pdO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqXTtcbiAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA2KSB7XG4gICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAxXSxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyAzXSxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyA0XSxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2ogKyA1XVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgY29udHJvbC55ID0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyA0XTtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IG51bWJlcnNbaiArIDVdO1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0KSB7XG4gICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICBnZXRSZWZsZWN0aW9uKHBvaW50LngsIGNvbnRyb2wueCksXG4gICAgICAgICAgICAgICAgZ2V0UmVmbGVjdGlvbihwb2ludC55LCBjb250cm9sLnkpLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDBdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDJdO1xuICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKG51bWJlcnNbaiArIDBdLCBudW1iZXJzW2ogKyAxXSwgbnVtYmVyc1tqICsgMl0sIG51bWJlcnNbaiArIDNdKTtcbiAgICAgICAgICAgICAgY29udHJvbC54ID0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICBwb2ludC54ID0gbnVtYmVyc1tqICsgMl07XG4gICAgICAgICAgICAgIHBvaW50LnkgPSBudW1iZXJzW2ogKyAzXTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICBjb25zdCByeCA9IGdldFJlZmxlY3Rpb24ocG9pbnQueCwgY29udHJvbC54KTtcbiAgICAgICAgICAgICAgY29uc3QgcnkgPSBnZXRSZWZsZWN0aW9uKHBvaW50LnksIGNvbnRyb2wueSk7XG4gICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIG51bWJlcnNbaiArIDBdLCBudW1iZXJzW2ogKyAxXSk7XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IHJ4O1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSByeTtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBwb2ludC55ID0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMiwgWzMsIDRdLCA3KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNykge1xuICAgICAgICAgICAgICBpZiAobnVtYmVyc1tqICsgNV0gPT0gcG9pbnQueCAmJiBudW1iZXJzW2ogKyA2XSA9PSBwb2ludC55KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvaW50LmNsb25lKCk7XG4gICAgICAgICAgICAgIHBvaW50LnggPSBudW1iZXJzW2ogKyA1XTtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IG51bWJlcnNbaiArIDZdO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICBwYXJzZUFyY0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2pdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDRdLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyAwXTtcbiAgICAgICAgICAgICAgcG9pbnQueSArPSBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgY29udHJvbC55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaiA9PT0gMClcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2pdO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbal07XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgIHBvaW50LnggKz0gbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgIGNvbnRyb2wueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA2KSB7XG4gICAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgM10sXG4gICAgICAgICAgICAgICAgcG9pbnQueCArIG51bWJlcnNbaiArIDRdLFxuICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyA1XVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1tqICsgMl07XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXTtcbiAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyA0XTtcbiAgICAgICAgICAgICAgcG9pbnQueSArPSBudW1iZXJzW2ogKyA1XTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCkge1xuICAgICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgZ2V0UmVmbGVjdGlvbihwb2ludC54LCBjb250cm9sLngpLFxuICAgICAgICAgICAgICAgIGdldFJlZmxlY3Rpb24ocG9pbnQueSwgY29udHJvbC55KSxcbiAgICAgICAgICAgICAgICBwb2ludC54ICsgbnVtYmVyc1tqICsgMF0sXG4gICAgICAgICAgICAgICAgcG9pbnQueSArIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAyXSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgM11cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1tqICsgMV07XG4gICAgICAgICAgICAgIHBvaW50LnggKz0gbnVtYmVyc1tqICsgMl07XG4gICAgICAgICAgICAgIHBvaW50LnkgKz0gbnVtYmVyc1tqICsgM107XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgIG51bWJlcnMgPSBwYXJzZUZsb2F0cyhkYXRhMik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICsgbnVtYmVyc1tqICsgMV0sXG4gICAgICAgICAgICAgICAgcG9pbnQueCArIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgIHBvaW50LnkgKyBudW1iZXJzW2ogKyAzXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1tqICsgMF07XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzW2ogKyAxXTtcbiAgICAgICAgICAgICAgcG9pbnQueCArPSBudW1iZXJzW2ogKyAyXTtcbiAgICAgICAgICAgICAgcG9pbnQueSArPSBudW1iZXJzW2ogKyAzXTtcbiAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZpcnN0UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgbnVtYmVycyA9IHBhcnNlRmxvYXRzKGRhdGEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMikge1xuICAgICAgICAgICAgICBjb25zdCByeCA9IGdldFJlZmxlY3Rpb24ocG9pbnQueCwgY29udHJvbC54KTtcbiAgICAgICAgICAgICAgY29uc3QgcnkgPSBnZXRSZWZsZWN0aW9uKHBvaW50LnksIGNvbnRyb2wueSk7XG4gICAgICAgICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIHBvaW50LnggKyBudW1iZXJzW2ogKyAwXSwgcG9pbnQueSArIG51bWJlcnNbaiArIDFdKTtcbiAgICAgICAgICAgICAgY29udHJvbC54ID0gcng7XG4gICAgICAgICAgICAgIGNvbnRyb2wueSA9IHJ5O1xuICAgICAgICAgICAgICBwb2ludC54ID0gcG9pbnQueCArIG51bWJlcnNbaiArIDBdO1xuICAgICAgICAgICAgICBwb2ludC55ID0gcG9pbnQueSArIG51bWJlcnNbaiArIDFdO1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludC5jb3B5KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICBudW1iZXJzID0gcGFyc2VGbG9hdHMoZGF0YTIsIFszLCA0XSwgNyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcpIHtcbiAgICAgICAgICAgICAgaWYgKG51bWJlcnNbaiArIDVdID09IDAgJiYgbnVtYmVyc1tqICsgNl0gPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb2ludC5jbG9uZSgpO1xuICAgICAgICAgICAgICBwb2ludC54ICs9IG51bWJlcnNbaiArIDVdO1xuICAgICAgICAgICAgICBwb2ludC55ICs9IG51bWJlcnNbaiArIDZdO1xuICAgICAgICAgICAgICBjb250cm9sLnggPSBwb2ludC54O1xuICAgICAgICAgICAgICBjb250cm9sLnkgPSBwb2ludC55O1xuICAgICAgICAgICAgICBwYXJzZUFyY0NvbW1hbmQoXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBudW1iZXJzW2pdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDFdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDJdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDNdLFxuICAgICAgICAgICAgICAgIG51bWJlcnNbaiArIDRdLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdFBvaW50LmNvcHkocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgcGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHBhdGguY3VycmVudFBhdGguY3VydmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcG9pbnQuY29weShmaXJzdFBvaW50KTtcbiAgICAgICAgICAgICAgcGF0aC5jdXJyZW50UGF0aC5jdXJyZW50UG9pbnQuY29weShwb2ludCk7XG4gICAgICAgICAgICAgIGlzRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ1NTU3R5bGVzaGVldChub2RlKSB7XG4gICAgICBpZiAoIW5vZGUuc2hlZXQgfHwgIW5vZGUuc2hlZXQuY3NzUnVsZXMgfHwgIW5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IG5vZGUuc2hlZXQuY3NzUnVsZXNbaV07XG4gICAgICAgIGlmIChzdHlsZXNoZWV0LnR5cGUgIT09IDEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yTGlzdCA9IHN0eWxlc2hlZXQuc2VsZWN0b3JUZXh0LnNwbGl0KC8sL2dtKS5maWx0ZXIoQm9vbGVhbikubWFwKChpMikgPT4gaTIudHJpbSgpKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWxlY3Rvckxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzdHlsZXNoZWV0LnN0eWxlKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBcIlwiKSk7XG4gICAgICAgICAgc3R5bGVzaGVldHNbc2VsZWN0b3JMaXN0W2pdXSA9IE9iamVjdC5hc3NpZ24oc3R5bGVzaGVldHNbc2VsZWN0b3JMaXN0W2pdXSB8fCB7fSwgZGVmaW5pdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQXJjQ29tbWFuZChwYXRoLCByeCwgcnksIHhfYXhpc19yb3RhdGlvbiwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChyeCA9PSAwIHx8IHJ5ID09IDApIHtcbiAgICAgICAgcGF0aC5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeF9heGlzX3JvdGF0aW9uID0geF9heGlzX3JvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIHJ4ID0gTWF0aC5hYnMocngpO1xuICAgICAgcnkgPSBNYXRoLmFicyhyeSk7XG4gICAgICBjb25zdCBkeDIgPSAoc3RhcnQueCAtIGVuZC54KSAvIDI7XG4gICAgICBjb25zdCBkeTIgPSAoc3RhcnQueSAtIGVuZC55KSAvIDI7XG4gICAgICBjb25zdCB4MXAgPSBNYXRoLmNvcyh4X2F4aXNfcm90YXRpb24pICogZHgyICsgTWF0aC5zaW4oeF9heGlzX3JvdGF0aW9uKSAqIGR5MjtcbiAgICAgIGNvbnN0IHkxcCA9IC1NYXRoLnNpbih4X2F4aXNfcm90YXRpb24pICogZHgyICsgTWF0aC5jb3MoeF9heGlzX3JvdGF0aW9uKSAqIGR5MjtcbiAgICAgIGxldCByeHMgPSByeCAqIHJ4O1xuICAgICAgbGV0IHJ5cyA9IHJ5ICogcnk7XG4gICAgICBjb25zdCB4MXBzID0geDFwICogeDFwO1xuICAgICAgY29uc3QgeTFwcyA9IHkxcCAqIHkxcDtcbiAgICAgIGNvbnN0IGNyID0geDFwcyAvIHJ4cyArIHkxcHMgLyByeXM7XG4gICAgICBpZiAoY3IgPiAxKSB7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNxcnQoY3IpO1xuICAgICAgICByeCA9IHMgKiByeDtcbiAgICAgICAgcnkgPSBzICogcnk7XG4gICAgICAgIHJ4cyA9IHJ4ICogcng7XG4gICAgICAgIHJ5cyA9IHJ5ICogcnk7XG4gICAgICB9XG4gICAgICBjb25zdCBkcSA9IHJ4cyAqIHkxcHMgKyByeXMgKiB4MXBzO1xuICAgICAgY29uc3QgcHEgPSAocnhzICogcnlzIC0gZHEpIC8gZHE7XG4gICAgICBsZXQgcSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBwcSkpO1xuICAgICAgaWYgKGxhcmdlX2FyY19mbGFnID09PSBzd2VlcF9mbGFnKVxuICAgICAgICBxID0gLXE7XG4gICAgICBjb25zdCBjeHAgPSBxICogcnggKiB5MXAgLyByeTtcbiAgICAgIGNvbnN0IGN5cCA9IC1xICogcnkgKiB4MXAgLyByeDtcbiAgICAgIGNvbnN0IGN4ID0gTWF0aC5jb3MoeF9heGlzX3JvdGF0aW9uKSAqIGN4cCAtIE1hdGguc2luKHhfYXhpc19yb3RhdGlvbikgKiBjeXAgKyAoc3RhcnQueCArIGVuZC54KSAvIDI7XG4gICAgICBjb25zdCBjeSA9IE1hdGguc2luKHhfYXhpc19yb3RhdGlvbikgKiBjeHAgKyBNYXRoLmNvcyh4X2F4aXNfcm90YXRpb24pICogY3lwICsgKHN0YXJ0LnkgKyBlbmQueSkgLyAyO1xuICAgICAgY29uc3QgdGhldGEgPSBzdmdBbmdsZSgxLCAwLCAoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gc3ZnQW5nbGUoKHgxcCAtIGN4cCkgLyByeCwgKHkxcCAtIGN5cCkgLyByeSwgKC14MXAgLSBjeHApIC8gcngsICgteTFwIC0gY3lwKSAvIHJ5KSAlIChNYXRoLlBJICogMik7XG4gICAgICBwYXRoLmN1cnJlbnRQYXRoLmFic2VsbGlwc2UoY3gsIGN5LCByeCwgcnksIHRoZXRhLCB0aGV0YSArIGRlbHRhLCBzd2VlcF9mbGFnID09PSAwLCB4X2F4aXNfcm90YXRpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdmdBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgICAgY29uc3QgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG4gICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQodXggKiB1eCArIHV5ICogdXkpICogTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcbiAgICAgIGxldCBhbmcgPSBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGRvdCAvIGxlbikpKTtcbiAgICAgIGlmICh1eCAqIHZ5IC0gdXkgKiB2eCA8IDApXG4gICAgICAgIGFuZyA9IC1hbmc7XG4gICAgICByZXR1cm4gYW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJlY3ROb2RlKG5vZGUpIHtcbiAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieVwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInJ4XCIpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKFwicnlcIikgfHwgMCk7XG4gICAgICBjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeVwiKSB8fCBub2RlLmdldEF0dHJpYnV0ZShcInJ4XCIpIHx8IDApO1xuICAgICAgY29uc3QgdyA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSk7XG4gICAgICBjb25zdCBoID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSk7XG4gICAgICBjb25zdCBiY2kgPSAxIC0gMC41NTE5MTUwMjQ0OTQ7XG4gICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgcGF0aC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgIHBhdGgubGluZVRvKHggKyB3IC0gcngsIHkpO1xuICAgICAgaWYgKHJ4ICE9PSAwIHx8IHJ5ICE9PSAwKSB7XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgdyAtIHJ4ICogYmNpLCB5LCB4ICsgdywgeSArIHJ5ICogYmNpLCB4ICsgdywgeSArIHJ5KTtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJ5KTtcbiAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gcnkgKiBiY2ksIHggKyB3IC0gcnggKiBiY2ksIHkgKyBoLCB4ICsgdyAtIHJ4LCB5ICsgaCk7XG4gICAgICB9XG4gICAgICBwYXRoLmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlmIChyeCAhPT0gMCB8fCByeSAhPT0gMCkge1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oeCArIHJ4ICogYmNpLCB5ICsgaCwgeCwgeSArIGggLSByeSAqIGJjaSwgeCwgeSArIGggLSByeSk7XG4gICAgICB9XG4gICAgICBwYXRoLmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgaWYgKHJ4ICE9PSAwIHx8IHJ5ICE9PSAwKSB7XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgKiBiY2ksIHggKyByeCAqIGJjaSwgeSwgeCArIHJ4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVBvbHlnb25Ob2RlKG5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG1hdGNoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKGEpO1xuICAgICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhiKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2V4ID0gLyhbKy1dP1xcZCpcXC4/XFxkKyg/OmVbKy1dP1xcZCspPykoPzosfFxccykoWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pL2c7XG4gICAgICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpLnJlcGxhY2UocmVnZXgsIGl0ZXJhdG9yKTtcbiAgICAgIHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVBvbHlsaW5lTm9kZShub2RlKSB7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRvcihtYXRjaCwgYSwgYikge1xuICAgICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhhKTtcbiAgICAgICAgY29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoYik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdleCA9IC8oWystXT9cXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pKD86LHxcXHMpKFsrLV0/XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KS9nO1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBub2RlLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKS5yZXBsYWNlKHJlZ2V4LCBpdGVyYXRvcik7XG4gICAgICBwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2lyY2xlTm9kZShub2RlKSB7XG4gICAgICBjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImN4XCIpIHx8IDApO1xuICAgICAgY29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJjeVwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiclwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgc3VicGF0aC5hYnNhcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgIHBhdGguc3ViUGF0aHMucHVzaChzdWJwYXRoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUVsbGlwc2VOb2RlKG5vZGUpIHtcbiAgICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwiY3hcIikgfHwgMCk7XG4gICAgICBjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcImN5XCIpIHx8IDApO1xuICAgICAgY29uc3QgcnggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwicnhcIikgfHwgMCk7XG4gICAgICBjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJyeVwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgc3VicGF0aC5hYnNlbGxpcHNlKHgsIHksIHJ4LCByeSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgIHBhdGguc3ViUGF0aHMucHVzaChzdWJwYXRoKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVOb2RlKG5vZGUpIHtcbiAgICAgIGNvbnN0IHgxID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcIngxXCIpIHx8IDApO1xuICAgICAgY29uc3QgeTEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieTFcIikgfHwgMCk7XG4gICAgICBjb25zdCB4MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMobm9kZS5nZXRBdHRyaWJ1dGUoXCJ4MlwiKSB8fCAwKTtcbiAgICAgIGNvbnN0IHkyID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInkyXCIpIHx8IDApO1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICAgIHBhdGgubW92ZVRvKHgxLCB5MSk7XG4gICAgICBwYXRoLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgcGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSBmYWxzZTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gICAgICBzdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlKTtcbiAgICAgIGxldCBzdHlsZXNoZWV0U3R5bGVzID0ge307XG4gICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJjbGFzc1wiKSkge1xuICAgICAgICBjb25zdCBjbGFzc1NlbGVjdG9ycyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikuc3BsaXQoL1xccy8pLmZpbHRlcihCb29sZWFuKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN0eWxlc2hlZXRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHN0eWxlc2hlZXRTdHlsZXMsIHN0eWxlc2hlZXRzW1wiLlwiICsgY2xhc3NTZWxlY3RvcnNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKFwiaWRcIikpIHtcbiAgICAgICAgc3R5bGVzaGVldFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbXCIjXCIgKyBub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhZGRTdHlsZShzdmdOYW1lLCBqc05hbWUsIGFkanVzdEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmIChhZGp1c3RGdW5jdGlvbiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGFkanVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gY29weSh2KSB7XG4gICAgICAgICAgICBpZiAodi5zdGFydHNXaXRoKFwidXJsXCIpKVxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTVkdMb2FkZXI6IHVybCBhY2Nlc3MgaW4gYXR0cmlidXRlcyBpcyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKHN2Z05hbWUpKVxuICAgICAgICAgIHN0eWxlW2pzTmFtZV0gPSBhZGp1c3RGdW5jdGlvbihub2RlLmdldEF0dHJpYnV0ZShzdmdOYW1lKSk7XG4gICAgICAgIGlmIChzdHlsZXNoZWV0U3R5bGVzW3N2Z05hbWVdKVxuICAgICAgICAgIHN0eWxlW2pzTmFtZV0gPSBhZGp1c3RGdW5jdGlvbihzdHlsZXNoZWV0U3R5bGVzW3N2Z05hbWVdKTtcbiAgICAgICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZVtzdmdOYW1lXSAhPT0gXCJcIilcbiAgICAgICAgICBzdHlsZVtqc05hbWVdID0gYWRqdXN0RnVuY3Rpb24obm9kZS5zdHlsZVtzdmdOYW1lXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGFtcCh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0V2l0aFVuaXRzKHYpKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb3NpdGl2ZSh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBwYXJzZUZsb2F0V2l0aFVuaXRzKHYpKTtcbiAgICAgIH1cbiAgICAgIGFkZFN0eWxlKFwiZmlsbFwiLCBcImZpbGxcIik7XG4gICAgICBhZGRTdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcImZpbGxPcGFjaXR5XCIsIGNsYW1wKTtcbiAgICAgIGFkZFN0eWxlKFwiZmlsbC1ydWxlXCIsIFwiZmlsbFJ1bGVcIik7XG4gICAgICBhZGRTdHlsZShcIm9wYWNpdHlcIiwgXCJvcGFjaXR5XCIsIGNsYW1wKTtcbiAgICAgIGFkZFN0eWxlKFwic3Ryb2tlXCIsIFwic3Ryb2tlXCIpO1xuICAgICAgYWRkU3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZU9wYWNpdHlcIiwgY2xhbXApO1xuICAgICAgYWRkU3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCJzdHJva2VXaWR0aFwiLCBwb3NpdGl2ZSk7XG4gICAgICBhZGRTdHlsZShcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZUxpbmVKb2luXCIpO1xuICAgICAgYWRkU3R5bGUoXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZUxpbmVDYXBcIik7XG4gICAgICBhZGRTdHlsZShcInN0cm9rZS1taXRlcmxpbWl0XCIsIFwic3Ryb2tlTWl0ZXJMaW1pdFwiLCBwb3NpdGl2ZSk7XG4gICAgICBhZGRTdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZWZsZWN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gKGIgLSBhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdHMoaW5wdXQsIGZsYWdzLCBzdHJpZGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQ6IFwiICsgdHlwZW9mIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFJFID0ge1xuICAgICAgICBTRVBBUkFUT1I6IC9bIFxcdFxcclxcblxcLC5cXC0rXS8sXG4gICAgICAgIFdISVRFU1BBQ0U6IC9bIFxcdFxcclxcbl0vLFxuICAgICAgICBESUdJVDogL1tcXGRdLyxcbiAgICAgICAgU0lHTjogL1stK10vLFxuICAgICAgICBQT0lOVDogL1xcLi8sXG4gICAgICAgIENPTU1BOiAvLC8sXG4gICAgICAgIEVYUDogL2UvaSxcbiAgICAgICAgRkxBR1M6IC9bMDFdL1xuICAgICAgfTtcbiAgICAgIGNvbnN0IFNFUCA9IDA7XG4gICAgICBjb25zdCBJTlQgPSAxO1xuICAgICAgY29uc3QgRkxPQVQgPSAyO1xuICAgICAgY29uc3QgRVhQID0gMztcbiAgICAgIGxldCBzdGF0ZSA9IFNFUDtcbiAgICAgIGxldCBzZWVuQ29tbWEgPSB0cnVlO1xuICAgICAgbGV0IG51bWJlciA9IFwiXCIsIGV4cG9uZW50ID0gXCJcIjtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZnVuY3Rpb24gdGhyb3dTeW50YXhFcnJvcihjdXJyZW50MiwgaSwgcGFydGlhbCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCInICsgY3VycmVudDIgKyAnXCIgYXQgaW5kZXggJyArIGkgKyBcIi5cIik7XG4gICAgICAgIGVycm9yLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5ld051bWJlcigpIHtcbiAgICAgICAgaWYgKG51bWJlciAhPT0gXCJcIikge1xuICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gXCJcIilcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihudW1iZXIpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaChOdW1iZXIobnVtYmVyKSAqIE1hdGgucG93KDEwLCBOdW1iZXIoZXhwb25lbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gXCJcIjtcbiAgICAgICAgZXhwb25lbnQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBpbnB1dFtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmxhZ3MpICYmIGZsYWdzLmluY2x1ZGVzKHJlc3VsdC5sZW5ndGggJSBzdHJpZGUpICYmIFJFLkZMQUdTLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICBzdGF0ZSA9IElOVDtcbiAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG5ld051bWJlcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU0VQKSB7XG4gICAgICAgICAgaWYgKFJFLldISVRFU1BBQ0UudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpIHx8IFJFLlNJR04udGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgc3RhdGUgPSBJTlQ7XG4gICAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRS5QT0lOVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEZMT0FUO1xuICAgICAgICAgICAgbnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUkUuQ09NTUEudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKHNlZW5Db21tYSkge1xuICAgICAgICAgICAgICB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQsIGksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IElOVCkge1xuICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gY3VycmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUkUuUE9JTlQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgbnVtYmVyICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICBzdGF0ZSA9IEZMT0FUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRS5FWFAudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgc3RhdGUgPSBFWFA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFJFLlNJR04udGVzdChjdXJyZW50KSAmJiBudW1iZXIubGVuZ3RoID09PSAxICYmIFJFLlNJR04udGVzdChudW1iZXJbMF0pKSB7XG4gICAgICAgICAgICB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQsIGksIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gRkxPQVQpIHtcbiAgICAgICAgICBpZiAoUkUuRElHSVQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgbnVtYmVyICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFJFLkVYUC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEVYUDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoUkUuUE9JTlQudGVzdChjdXJyZW50KSAmJiBudW1iZXJbbnVtYmVyLmxlbmd0aCAtIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IEVYUCkge1xuICAgICAgICAgIGlmIChSRS5ESUdJVC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBleHBvbmVudCArPSBjdXJyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRS5TSUdOLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBleHBvbmVudCArPSBjdXJyZW50O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBvbmVudC5sZW5ndGggPT09IDEgJiYgUkUuU0lHTi50ZXN0KGV4cG9uZW50KSkge1xuICAgICAgICAgICAgICB0aHJvd1N5bnRheEVycm9yKGN1cnJlbnQsIGksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChSRS5XSElURVNQQUNFLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICBzdGF0ZSA9IFNFUDtcbiAgICAgICAgICBzZWVuQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChSRS5DT01NQS50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgbmV3TnVtYmVyKCk7XG4gICAgICAgICAgc3RhdGUgPSBTRVA7XG4gICAgICAgICAgc2VlbkNvbW1hID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChSRS5TSUdOLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICBzdGF0ZSA9IElOVDtcbiAgICAgICAgICBudW1iZXIgPSBjdXJyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKFJFLlBPSU5ULnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICBuZXdOdW1iZXIoKTtcbiAgICAgICAgICBzdGF0ZSA9IEZMT0FUO1xuICAgICAgICAgIG51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dTeW50YXhFcnJvcihjdXJyZW50LCBpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdOdW1iZXIoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHVuaXRzID0gW1wibW1cIiwgXCJjbVwiLCBcImluXCIsIFwicHRcIiwgXCJwY1wiLCBcInB4XCJdO1xuICAgIGNvbnN0IHVuaXRDb252ZXJzaW9uID0ge1xuICAgICAgbW06IHtcbiAgICAgICAgbW06IDEsXG4gICAgICAgIGNtOiAwLjEsXG4gICAgICAgIGluOiAxIC8gMjUuNCxcbiAgICAgICAgcHQ6IDcyIC8gMjUuNCxcbiAgICAgICAgcGM6IDYgLyAyNS40LFxuICAgICAgICBweDogLTFcbiAgICAgIH0sXG4gICAgICBjbToge1xuICAgICAgICBtbTogMTAsXG4gICAgICAgIGNtOiAxLFxuICAgICAgICBpbjogMSAvIDIuNTQsXG4gICAgICAgIHB0OiA3MiAvIDIuNTQsXG4gICAgICAgIHBjOiA2IC8gMi41NCxcbiAgICAgICAgcHg6IC0xXG4gICAgICB9LFxuICAgICAgaW46IHtcbiAgICAgICAgbW06IDI1LjQsXG4gICAgICAgIGNtOiAyLjU0LFxuICAgICAgICBpbjogMSxcbiAgICAgICAgcHQ6IDcyLFxuICAgICAgICBwYzogNixcbiAgICAgICAgcHg6IC0xXG4gICAgICB9LFxuICAgICAgcHQ6IHtcbiAgICAgICAgbW06IDI1LjQgLyA3MixcbiAgICAgICAgY206IDIuNTQgLyA3MixcbiAgICAgICAgaW46IDEgLyA3MixcbiAgICAgICAgcHQ6IDEsXG4gICAgICAgIHBjOiA2IC8gNzIsXG4gICAgICAgIHB4OiAtMVxuICAgICAgfSxcbiAgICAgIHBjOiB7XG4gICAgICAgIG1tOiAyNS40IC8gNixcbiAgICAgICAgY206IDIuNTQgLyA2LFxuICAgICAgICBpbjogMSAvIDYsXG4gICAgICAgIHB0OiA3MiAvIDYsXG4gICAgICAgIHBjOiAxLFxuICAgICAgICBweDogLTFcbiAgICAgIH0sXG4gICAgICBweDoge1xuICAgICAgICBweDogMVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdFdpdGhVbml0cyhzdHJpbmcpIHtcbiAgICAgIGxldCB0aGVVbml0ID0gXCJweFwiO1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgfHwgc3RyaW5nIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdW5pdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdSA9IHVuaXRzW2ldO1xuICAgICAgICAgIGlmIChzdHJpbmcuZW5kc1dpdGgodSkpIHtcbiAgICAgICAgICAgIHRoZVVuaXQgPSB1O1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZygwLCBzdHJpbmcubGVuZ3RoIC0gdS5sZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgc2NhbGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhlVW5pdCA9PT0gXCJweFwiICYmIHNjb3BlLmRlZmF1bHRVbml0ICE9PSBcInB4XCIpIHtcbiAgICAgICAgc2NhbGUgPSB1bml0Q29udmVyc2lvbltcImluXCJdW3Njb3BlLmRlZmF1bHRVbml0XSAvIHNjb3BlLmRlZmF1bHREUEk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IHVuaXRDb252ZXJzaW9uW3RoZVVuaXRdW3Njb3BlLmRlZmF1bHRVbml0XTtcbiAgICAgICAgaWYgKHNjYWxlIDwgMCkge1xuICAgICAgICAgIHNjYWxlID0gdW5pdENvbnZlcnNpb25bdGhlVW5pdF1bXCJpblwiXSAqIHNjb3BlLmRlZmF1bHREUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZSAqIHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Tm9kZVRyYW5zZm9ybShub2RlKSB7XG4gICAgICBpZiAoIShub2RlLmhhc0F0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSB8fCBub2RlLm5vZGVOYW1lID09PSBcInVzZVwiICYmIChub2RlLmhhc0F0dHJpYnV0ZShcInhcIikgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoXCJ5XCIpKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBwYXJzZU5vZGVUcmFuc2Zvcm0obm9kZSk7XG4gICAgICBpZiAodHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICB0cmFuc2Zvcm0ucHJlbXVsdGlwbHkodHJhbnNmb3JtU3RhY2tbdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgfVxuICAgICAgY3VycmVudFRyYW5zZm9ybS5jb3B5KHRyYW5zZm9ybSk7XG4gICAgICB0cmFuc2Zvcm1TdGFjay5wdXNoKHRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU5vZGVUcmFuc2Zvcm0obm9kZSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0yID0gdGVtcFRyYW5zZm9ybTA7XG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJ1c2VcIiAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJ4XCIpIHx8IG5vZGUuaGFzQXR0cmlidXRlKFwieVwiKSkpIHtcbiAgICAgICAgY29uc3QgdHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKG5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSk7XG4gICAgICAgIGNvbnN0IHR5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyhub2RlLmdldEF0dHJpYnV0ZShcInlcIikpO1xuICAgICAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3Jtc1RleHRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikuc3BsaXQoXCIpXCIpO1xuICAgICAgICBmb3IgKGxldCB0SW5kZXggPSB0cmFuc2Zvcm1zVGV4dHMubGVuZ3RoIC0gMTsgdEluZGV4ID49IDA7IHRJbmRleC0tKSB7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGV4dCA9IHRyYW5zZm9ybXNUZXh0c1t0SW5kZXhdLnRyaW0oKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtVGV4dCA9PT0gXCJcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG9wZW5QYXJQb3MgPSB0cmFuc2Zvcm1UZXh0LmluZGV4T2YoXCIoXCIpO1xuICAgICAgICAgIGNvbnN0IGNsb3NlUGFyUG9zID0gdHJhbnNmb3JtVGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9wZW5QYXJQb3MgPiAwICYmIG9wZW5QYXJQb3MgPCBjbG9zZVBhclBvcykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVHlwZSA9IHRyYW5zZm9ybVRleHQuc2xpY2UoMCwgb3BlblBhclBvcyk7XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IHBhcnNlRmxvYXRzKHRyYW5zZm9ybVRleHQuc2xpY2Uob3BlblBhclBvcyArIDEpKTtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLmlkZW50aXR5KCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybVR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRyYW5zbGF0ZVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhcnJheVswXTtcbiAgICAgICAgICAgICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHkgPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgbGV0IGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICAgIGxldCBjeCA9IDA7XG4gICAgICAgICAgICAgICAgICBsZXQgY3kgPSAwO1xuICAgICAgICAgICAgICAgICAgYW5nbGUgPSBhcnJheVswXSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3ggPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3kgPSBhcnJheVsyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2Zvcm0xLm1ha2VUcmFuc2xhdGlvbigtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICB0ZW1wVHJhbnNmb3JtMi5tYWtlUm90YXRpb24oYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTMubXVsdGlwbHlNYXRyaWNlcyh0ZW1wVHJhbnNmb3JtMiwgdGVtcFRyYW5zZm9ybTEpO1xuICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zZm9ybTEubWFrZVRyYW5zbGF0aW9uKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5tdWx0aXBseU1hdHJpY2VzKHRlbXBUcmFuc2Zvcm0xLCB0ZW1wVHJhbnNmb3JtMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGVcIjpcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlWCA9IGFycmF5WzBdO1xuICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlWSA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSBhcnJheVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJza2V3WFwiOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnNldCgxLCBNYXRoLnRhbihhcnJheVswXSAqIE1hdGguUEkgLyAxODApLCAwLCAwLCAxLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJza2V3WVwiOlxuICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0yLnNldCgxLCAwLCAwLCBNYXRoLnRhbihhcnJheVswXSAqIE1hdGguUEkgLyAxODApLCAxLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtMi5zZXQoYXJyYXlbMF0sIGFycmF5WzJdLCBhcnJheVs0XSwgYXJyYXlbMV0sIGFycmF5WzNdLCBhcnJheVs1XSwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2Zvcm0ucHJlbXVsdGlwbHkoY3VycmVudFRyYW5zZm9ybTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zZlZlYzIodjIpIHtcbiAgICAgICAgdGVtcFYzLnNldCh2Mi54LCB2Mi55LCAxKS5hcHBseU1hdHJpeDMobSk7XG4gICAgICAgIHYyLnNldCh0ZW1wVjMueCwgdGVtcFYzLnkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdHJhbnNmRWxsaXBzZUdlbmVyaWMoY3VydmUpIHtcbiAgICAgICAgY29uc3QgYSA9IGN1cnZlLnhSYWRpdXM7XG4gICAgICAgIGNvbnN0IGIgPSBjdXJ2ZS55UmFkaXVzO1xuICAgICAgICBjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKGN1cnZlLmFSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oY3VydmUuYVJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgdjEgPSBuZXcgVmVjdG9yMyhhICogY29zVGhldGEsIGEgKiBzaW5UaGV0YSwgMCk7XG4gICAgICAgIGNvbnN0IHYyID0gbmV3IFZlY3RvcjMoLWIgKiBzaW5UaGV0YSwgYiAqIGNvc1RoZXRhLCAwKTtcbiAgICAgICAgY29uc3QgZjEgPSB2MS5hcHBseU1hdHJpeDMobSk7XG4gICAgICAgIGNvbnN0IGYyID0gdjIuYXBwbHlNYXRyaXgzKG0pO1xuICAgICAgICBjb25zdCBtRiA9IHRlbXBUcmFuc2Zvcm0wLnNldChmMS54LCBmMi54LCAwLCBmMS55LCBmMi55LCAwLCAwLCAwLCAxKTtcbiAgICAgICAgY29uc3QgbUZJbnYgPSB0ZW1wVHJhbnNmb3JtMS5jb3B5KG1GKS5pbnZlcnQoKTtcbiAgICAgICAgY29uc3QgbUZJbnZUID0gdGVtcFRyYW5zZm9ybTIuY29weShtRkludikudHJhbnNwb3NlKCk7XG4gICAgICAgIGNvbnN0IG1RID0gbUZJbnZULm11bHRpcGx5KG1GSW52KTtcbiAgICAgICAgY29uc3QgbVFlID0gbVEuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGVkID0gZWlnZW5EZWNvbXBvc2l0aW9uKG1RZVswXSwgbVFlWzFdLCBtUWVbNF0pO1xuICAgICAgICBjb25zdCBydDFzcXJ0ID0gTWF0aC5zcXJ0KGVkLnJ0MSk7XG4gICAgICAgIGNvbnN0IHJ0MnNxcnQgPSBNYXRoLnNxcnQoZWQucnQyKTtcbiAgICAgICAgY3VydmUueFJhZGl1cyA9IDEgLyBydDFzcXJ0O1xuICAgICAgICBjdXJ2ZS55UmFkaXVzID0gMSAvIHJ0MnNxcnQ7XG4gICAgICAgIGN1cnZlLmFSb3RhdGlvbiA9IE1hdGguYXRhbjIoZWQuc24sIGVkLmNzKTtcbiAgICAgICAgY29uc3QgaXNGdWxsRWxsaXBzZSA9IChjdXJ2ZS5hRW5kQW5nbGUgLSBjdXJ2ZS5hU3RhcnRBbmdsZSkgJSAoMiAqIE1hdGguUEkpIDwgTnVtYmVyLkVQU0lMT047XG4gICAgICAgIGlmICghaXNGdWxsRWxsaXBzZSkge1xuICAgICAgICAgIGNvbnN0IG1Ec3FydCA9IHRlbXBUcmFuc2Zvcm0xLnNldChydDFzcXJ0LCAwLCAwLCAwLCBydDJzcXJ0LCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICBjb25zdCBtUlQgPSB0ZW1wVHJhbnNmb3JtMi5zZXQoZWQuY3MsIGVkLnNuLCAwLCAtZWQuc24sIGVkLmNzLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICBjb25zdCBtRFJGID0gbURzcXJ0Lm11bHRpcGx5KG1SVCkubXVsdGlwbHkobUYpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybUFuZ2xlID0gKHBoaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB4OiBjb3NSLCB5OiBzaW5SIH0gPSBuZXcgVmVjdG9yMyhNYXRoLmNvcyhwaGkpLCBNYXRoLnNpbihwaGkpLCAwKS5hcHBseU1hdHJpeDMobURSRik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihzaW5SLCBjb3NSKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnZlLmFTdGFydEFuZ2xlID0gdHJhbnNmb3JtQW5nbGUoY3VydmUuYVN0YXJ0QW5nbGUpO1xuICAgICAgICAgIGN1cnZlLmFFbmRBbmdsZSA9IHRyYW5zZm9ybUFuZ2xlKGN1cnZlLmFFbmRBbmdsZSk7XG4gICAgICAgICAgaWYgKGlzVHJhbnNmb3JtRmxpcHBlZChtKSkge1xuICAgICAgICAgICAgY3VydmUuYUNsb2Nrd2lzZSA9ICFjdXJ2ZS5hQ2xvY2t3aXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdHJhbnNmRWxsaXBzZU5vU2tldyhjdXJ2ZSkge1xuICAgICAgICBjb25zdCBzeCA9IGdldFRyYW5zZm9ybVNjYWxlWChtKTtcbiAgICAgICAgY29uc3Qgc3kgPSBnZXRUcmFuc2Zvcm1TY2FsZVkobSk7XG4gICAgICAgIGN1cnZlLnhSYWRpdXMgKj0gc3g7XG4gICAgICAgIGN1cnZlLnlSYWRpdXMgKj0gc3k7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gc3ggPiBOdW1iZXIuRVBTSUxPTiA/IE1hdGguYXRhbjIobS5lbGVtZW50c1sxXSwgbS5lbGVtZW50c1swXSkgOiBNYXRoLmF0YW4yKC1tLmVsZW1lbnRzWzNdLCBtLmVsZW1lbnRzWzRdKTtcbiAgICAgICAgY3VydmUuYVJvdGF0aW9uICs9IHRoZXRhO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1GbGlwcGVkKG0pKSB7XG4gICAgICAgICAgY3VydmUuYVN0YXJ0QW5nbGUgKj0gLTE7XG4gICAgICAgICAgY3VydmUuYUVuZEFuZ2xlICo9IC0xO1xuICAgICAgICAgIGN1cnZlLmFDbG9ja3dpc2UgPSAhY3VydmUuYUNsb2Nrd2lzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3ViUGF0aHMgPSBwYXRoLnN1YlBhdGhzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHN1YlBhdGhzW2ldO1xuICAgICAgICBjb25zdCBjdXJ2ZXMgPSBzdWJQYXRoLmN1cnZlcztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJ2ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJ2ZSA9IGN1cnZlc1tqXTtcbiAgICAgICAgICBpZiAoY3VydmUuaXNMaW5lQ3VydmUpIHtcbiAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjEpO1xuICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52Mik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZS5pc0N1YmljQmV6aWVyQ3VydmUpIHtcbiAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjApO1xuICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MSk7XG4gICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYyKTtcbiAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VydmUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSkge1xuICAgICAgICAgICAgdHJhbnNmVmVjMihjdXJ2ZS52MCk7XG4gICAgICAgICAgICB0cmFuc2ZWZWMyKGN1cnZlLnYxKTtcbiAgICAgICAgICAgIHRyYW5zZlZlYzIoY3VydmUudjIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VydmUuaXNFbGxpcHNlQ3VydmUpIHtcbiAgICAgICAgICAgIHRlbXBWMi5zZXQoY3VydmUuYVgsIGN1cnZlLmFZKTtcbiAgICAgICAgICAgIHRyYW5zZlZlYzIodGVtcFYyKTtcbiAgICAgICAgICAgIGN1cnZlLmFYID0gdGVtcFYyLng7XG4gICAgICAgICAgICBjdXJ2ZS5hWSA9IHRlbXBWMi55O1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtU2tld2VkKG0pKSB7XG4gICAgICAgICAgICAgIHRyYW5zZkVsbGlwc2VHZW5lcmljKGN1cnZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyYW5zZkVsbGlwc2VOb1NrZXcoY3VydmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RyYW5zZm9ybUZsaXBwZWQobSkge1xuICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIHRlWzBdICogdGVbNF0gLSB0ZVsxXSAqIHRlWzNdIDwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUcmFuc2Zvcm1Ta2V3ZWQobSkge1xuICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgY29uc3QgYmFzaXNEb3QgPSB0ZVswXSAqIHRlWzNdICsgdGVbMV0gKiB0ZVs0XTtcbiAgICAgIGlmIChiYXNpc0RvdCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3Qgc3ggPSBnZXRUcmFuc2Zvcm1TY2FsZVgobSk7XG4gICAgICBjb25zdCBzeSA9IGdldFRyYW5zZm9ybVNjYWxlWShtKTtcbiAgICAgIHJldHVybiBNYXRoLmFicyhiYXNpc0RvdCAvIChzeCAqIHN5KSkgPiBOdW1iZXIuRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVYKG0pIHtcbiAgICAgIGNvbnN0IHRlID0gbS5lbGVtZW50cztcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGVbMF0gKiB0ZVswXSArIHRlWzFdICogdGVbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TY2FsZVkobSkge1xuICAgICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0ZVszXSAqIHRlWzNdICsgdGVbNF0gKiB0ZVs0XSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVpZ2VuRGVjb21wb3NpdGlvbihBLCBCLCBDKSB7XG4gICAgICBsZXQgcnQxLCBydDIsIGNzLCBzbiwgdDtcbiAgICAgIGNvbnN0IHNtID0gQSArIEM7XG4gICAgICBjb25zdCBkZiA9IEEgLSBDO1xuICAgICAgY29uc3QgcnQgPSBNYXRoLnNxcnQoZGYgKiBkZiArIDQgKiBCICogQik7XG4gICAgICBpZiAoc20gPiAwKSB7XG4gICAgICAgIHJ0MSA9IDAuNSAqIChzbSArIHJ0KTtcbiAgICAgICAgdCA9IDEgLyBydDE7XG4gICAgICAgIHJ0MiA9IEEgKiB0ICogQyAtIEIgKiB0ICogQjtcbiAgICAgIH0gZWxzZSBpZiAoc20gPCAwKSB7XG4gICAgICAgIHJ0MiA9IDAuNSAqIChzbSAtIHJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ0MSA9IDAuNSAqIHJ0O1xuICAgICAgICBydDIgPSAtMC41ICogcnQ7XG4gICAgICB9XG4gICAgICBpZiAoZGYgPiAwKSB7XG4gICAgICAgIGNzID0gZGYgKyBydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzID0gZGYgLSBydDtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhjcykgPiAyICogTWF0aC5hYnMoQikpIHtcbiAgICAgICAgdCA9IC0yICogQiAvIGNzO1xuICAgICAgICBzbiA9IDEgLyBNYXRoLnNxcnQoMSArIHQgKiB0KTtcbiAgICAgICAgY3MgPSB0ICogc247XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKEIpID09PSAwKSB7XG4gICAgICAgIGNzID0gMTtcbiAgICAgICAgc24gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IC0wLjUgKiBjcyAvIEI7XG4gICAgICAgIGNzID0gMSAvIE1hdGguc3FydCgxICsgdCAqIHQpO1xuICAgICAgICBzbiA9IHQgKiBjcztcbiAgICAgIH1cbiAgICAgIGlmIChkZiA+IDApIHtcbiAgICAgICAgdCA9IGNzO1xuICAgICAgICBjcyA9IC1zbjtcbiAgICAgICAgc24gPSB0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgcnQxLCBydDIsIGNzLCBzbiB9O1xuICAgIH1cbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlc2hlZXRzID0ge307XG4gICAgY29uc3QgdHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMCA9IG5ldyBNYXRyaXgzKCk7XG4gICAgY29uc3QgdGVtcFRyYW5zZm9ybTEgPSBuZXcgTWF0cml4MygpO1xuICAgIGNvbnN0IHRlbXBUcmFuc2Zvcm0yID0gbmV3IE1hdHJpeDMoKTtcbiAgICBjb25zdCB0ZW1wVHJhbnNmb3JtMyA9IG5ldyBNYXRyaXgzKCk7XG4gICAgY29uc3QgdGVtcFYyID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCB0ZW1wVjMgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpO1xuICAgIGNvbnN0IHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJpbWFnZS9zdmcreG1sXCIpO1xuICAgIHBhcnNlTm9kZSh4bWwuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBmaWxsOiBcIiMwMDBcIixcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlTGluZUpvaW46IFwibWl0ZXJcIixcbiAgICAgIHN0cm9rZUxpbmVDYXA6IFwiYnV0dFwiLFxuICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogNFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSB7IHBhdGhzLCB4bWw6IHhtbC5kb2N1bWVudEVsZW1lbnQgfTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlU2hhcGVzKHNoYXBlUGF0aCkge1xuICAgIGNvbnN0IEJJR05VTUJFUiA9IDk5OTk5OTk5OTtcbiAgICBjb25zdCBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUgPSB7XG4gICAgICBPUklHSU46IDAsXG4gICAgICBERVNUSU5BVElPTjogMSxcbiAgICAgIEJFVFdFRU46IDIsXG4gICAgICBMRUZUOiAzLFxuICAgICAgUklHSFQ6IDQsXG4gICAgICBCRUhJTkQ6IDUsXG4gICAgICBCRVlPTkQ6IDZcbiAgICB9O1xuICAgIGNvbnN0IGNsYXNzaWZ5UmVzdWx0ID0ge1xuICAgICAgbG9jOiBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOLFxuICAgICAgdDogMFxuICAgIH07XG4gICAgZnVuY3Rpb24gZmluZEVkZ2VJbnRlcnNlY3Rpb24oYTAsIGExLCBiMCwgYjEpIHtcbiAgICAgIGNvbnN0IHgxID0gYTAueDtcbiAgICAgIGNvbnN0IHgyID0gYTEueDtcbiAgICAgIGNvbnN0IHgzID0gYjAueDtcbiAgICAgIGNvbnN0IHg0ID0gYjEueDtcbiAgICAgIGNvbnN0IHkxID0gYTAueTtcbiAgICAgIGNvbnN0IHkyID0gYTEueTtcbiAgICAgIGNvbnN0IHkzID0gYjAueTtcbiAgICAgIGNvbnN0IHk0ID0gYjEueTtcbiAgICAgIGNvbnN0IG5vbTEgPSAoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4Myk7XG4gICAgICBjb25zdCBub20yID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICAgICAgY29uc3QgZGVub20gPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG4gICAgICBjb25zdCB0MSA9IG5vbTEgLyBkZW5vbTtcbiAgICAgIGNvbnN0IHQyID0gbm9tMiAvIGRlbm9tO1xuICAgICAgaWYgKGRlbm9tID09PSAwICYmIG5vbTEgIT09IDAgfHwgdDEgPD0gMCB8fCB0MSA+PSAxIHx8IHQyIDwgMCB8fCB0MiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5vbTEgPT09IDAgJiYgZGVub20gPT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICBjbGFzc2lmeVBvaW50KGkgPT09IDAgPyBiMCA6IGIxLCBhMCwgYTEpO1xuICAgICAgICAgIGlmIChjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTikge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBpID09PSAwID8gYjAgOiBiMTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnksIHQ6IGNsYXNzaWZ5UmVzdWx0LnQgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzaWZ5UmVzdWx0LmxvYyA9PSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVUV0VFTikge1xuICAgICAgICAgICAgY29uc3QgeCA9ICsoeDEgKyBjbGFzc2lmeVJlc3VsdC50ICogKHgyIC0geDEpKS50b1ByZWNpc2lvbigxMCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gKyh5MSArIGNsYXNzaWZ5UmVzdWx0LnQgKiAoeTIgLSB5MSkpLnRvUHJlY2lzaW9uKDEwKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHQ6IGNsYXNzaWZ5UmVzdWx0LnQgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgIGNsYXNzaWZ5UG9pbnQoaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSk7XG4gICAgICAgICAgaWYgKGNsYXNzaWZ5UmVzdWx0LmxvYyA9PSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IGkgPT09IDAgPyBiMCA6IGIxO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSwgdDogY2xhc3NpZnlSZXN1bHQudCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gKyh4MSArIHQxICogKHgyIC0geDEpKS50b1ByZWNpc2lvbigxMCk7XG4gICAgICAgIGNvbnN0IHkgPSArKHkxICsgdDEgKiAoeTIgLSB5MSkpLnRvUHJlY2lzaW9uKDEwKTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSwgdDogdDEgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhc3NpZnlQb2ludChwLCBlZGdlU3RhcnQsIGVkZ2VFbmQpIHtcbiAgICAgIGNvbnN0IGF4ID0gZWRnZUVuZC54IC0gZWRnZVN0YXJ0Lng7XG4gICAgICBjb25zdCBheSA9IGVkZ2VFbmQueSAtIGVkZ2VTdGFydC55O1xuICAgICAgY29uc3QgYnggPSBwLnggLSBlZGdlU3RhcnQueDtcbiAgICAgIGNvbnN0IGJ5ID0gcC55IC0gZWRnZVN0YXJ0Lnk7XG4gICAgICBjb25zdCBzYSA9IGF4ICogYnkgLSBieCAqIGF5O1xuICAgICAgaWYgKHAueCA9PT0gZWRnZVN0YXJ0LnggJiYgcC55ID09PSBlZGdlU3RhcnQueSkge1xuICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOO1xuICAgICAgICBjbGFzc2lmeVJlc3VsdC50ID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHAueCA9PT0gZWRnZUVuZC54ICYmIHAueSA9PT0gZWRnZUVuZC55KSB7XG4gICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5ERVNUSU5BVElPTjtcbiAgICAgICAgY2xhc3NpZnlSZXN1bHQudCA9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzYSA8IC1OdW1iZXIuRVBTSUxPTikge1xuICAgICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuTEVGVDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNhID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLlJJR0hUO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXggKiBieCA8IDAgfHwgYXkgKiBieSA8IDApIHtcbiAgICAgICAgY2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFSElORDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgPCBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSB7XG4gICAgICAgIGNsYXNzaWZ5UmVzdWx0LmxvYyA9IEludGVyc2VjdGlvbkxvY2F0aW9uVHlwZS5CRVlPTkQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0O1xuICAgICAgaWYgKGF4ICE9PSAwKSB7XG4gICAgICAgIHQgPSBieCAvIGF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGJ5IC8gYXk7XG4gICAgICB9XG4gICAgICBjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVUV0VFTjtcbiAgICAgIGNsYXNzaWZ5UmVzdWx0LnQgPSB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zKHBhdGgxLCBwYXRoMikge1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uc1JhdyA9IFtdO1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHBhdGgxLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBwYXRoMUVkZ2VTdGFydCA9IHBhdGgxW2luZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IHBhdGgxRWRnZUVuZCA9IHBhdGgxW2luZGV4XTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXgyID0gMTsgaW5kZXgyIDwgcGF0aDIubGVuZ3RoOyBpbmRleDIrKykge1xuICAgICAgICAgIGNvbnN0IHBhdGgyRWRnZVN0YXJ0ID0gcGF0aDJbaW5kZXgyIC0gMV07XG4gICAgICAgICAgY29uc3QgcGF0aDJFZGdlRW5kID0gcGF0aDJbaW5kZXgyXTtcbiAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBmaW5kRWRnZUludGVyc2VjdGlvbihwYXRoMUVkZ2VTdGFydCwgcGF0aDFFZGdlRW5kLCBwYXRoMkVkZ2VTdGFydCwgcGF0aDJFZGdlRW5kKTtcbiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsICYmIGludGVyc2VjdGlvbnNSYXcuZmluZChcbiAgICAgICAgICAgIChpKSA9PiBpLnQgPD0gaW50ZXJzZWN0aW9uLnQgKyBOdW1iZXIuRVBTSUxPTiAmJiBpLnQgPj0gaW50ZXJzZWN0aW9uLnQgLSBOdW1iZXIuRVBTSUxPTlxuICAgICAgICAgICkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1Jhdy5wdXNoKGludGVyc2VjdGlvbik7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2gobmV3IFZlY3RvcjIoaW50ZXJzZWN0aW9uLngsIGludGVyc2VjdGlvbi55KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2NhbmxpbmVJbnRlcnNlY3Rpb25zKHNjYW5saW5lLCBib3VuZGluZ0JveCwgcGF0aHMpIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICBib3VuZGluZ0JveC5nZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIGNvbnN0IGFsbEludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHBhdGguYm91bmRpbmdCb3guY29udGFpbnNQb2ludChjZW50ZXIpKSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IGdldEludGVyc2VjdGlvbnMoc2NhbmxpbmUsIHBhdGgucG9pbnRzKTtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIGFsbEludGVyc2VjdGlvbnMucHVzaCh7IGlkZW50aWZpZXI6IHBhdGguaWRlbnRpZmllciwgaXNDVzogcGF0aC5pc0NXLCBwb2ludDogcCB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhbGxJbnRlcnNlY3Rpb25zLnNvcnQoKGkxLCBpMikgPT4ge1xuICAgICAgICByZXR1cm4gaTEucG9pbnQueCAtIGkyLnBvaW50Lng7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0hvbGVUbyhzaW1wbGVQYXRoLCBhbGxQYXRocywgc2NhbmxpbmVNaW5YMiwgc2NhbmxpbmVNYXhYMiwgX2ZpbGxSdWxlKSB7XG4gICAgICBpZiAoX2ZpbGxSdWxlID09PSBudWxsIHx8IF9maWxsUnVsZSA9PT0gdm9pZCAwIHx8IF9maWxsUnVsZSA9PT0gXCJcIikge1xuICAgICAgICBfZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbnRlckJvdW5kaW5nQm94ID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIHNpbXBsZVBhdGguYm91bmRpbmdCb3guZ2V0Q2VudGVyKGNlbnRlckJvdW5kaW5nQm94KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lID0gW25ldyBWZWN0b3IyKHNjYW5saW5lTWluWDIsIGNlbnRlckJvdW5kaW5nQm94LnkpLCBuZXcgVmVjdG9yMihzY2FubGluZU1heFgyLCBjZW50ZXJCb3VuZGluZ0JveC55KV07XG4gICAgICBjb25zdCBzY2FubGluZUludGVyc2VjdGlvbnMgPSBnZXRTY2FubGluZUludGVyc2VjdGlvbnMoc2NhbmxpbmUsIHNpbXBsZVBhdGguYm91bmRpbmdCb3gsIGFsbFBhdGhzKTtcbiAgICAgIHNjYW5saW5lSW50ZXJzZWN0aW9ucy5zb3J0KChpMSwgaTIpID0+IHtcbiAgICAgICAgcmV0dXJuIGkxLnBvaW50LnggLSBpMi5wb2ludC54O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBiYXNlSW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgICAgY29uc3Qgb3RoZXJJbnRlcnNlY3Rpb25zID0gW107XG4gICAgICBzY2FubGluZUludGVyc2VjdGlvbnMuZm9yRWFjaCgoaTIpID0+IHtcbiAgICAgICAgaWYgKGkyLmlkZW50aWZpZXIgPT09IHNpbXBsZVBhdGguaWRlbnRpZmllcikge1xuICAgICAgICAgIGJhc2VJbnRlcnNlY3Rpb25zLnB1c2goaTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVySW50ZXJzZWN0aW9ucy5wdXNoKGkyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBmaXJzdFhPZlBhdGggPSBiYXNlSW50ZXJzZWN0aW9uc1swXS5wb2ludC54O1xuICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgb3RoZXJJbnRlcnNlY3Rpb25zLmxlbmd0aCAmJiBvdGhlckludGVyc2VjdGlvbnNbaV0ucG9pbnQueCA8IGZpcnN0WE9mUGF0aCkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gb3RoZXJJbnRlcnNlY3Rpb25zW2ldLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG90aGVySW50ZXJzZWN0aW9uc1tpXS5pZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKHNpbXBsZVBhdGguaWRlbnRpZmllcik7XG4gICAgICBpZiAoX2ZpbGxSdWxlID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgICBjb25zdCBpc0hvbGUgPSBzdGFjay5sZW5ndGggJSAyID09PSAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBpc0hvbGVGb3IgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgcmV0dXJuIHsgaWRlbnRpZmllcjogc2ltcGxlUGF0aC5pZGVudGlmaWVyLCBpc0hvbGUsIGZvcjogaXNIb2xlRm9yIH07XG4gICAgICB9IGVsc2UgaWYgKF9maWxsUnVsZSA9PT0gXCJub256ZXJvXCIpIHtcbiAgICAgICAgbGV0IGlzSG9sZSA9IHRydWU7XG4gICAgICAgIGxldCBpc0hvbGVGb3IgPSBudWxsO1xuICAgICAgICBsZXQgbGFzdENXVmFsdWUgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgc3RhY2subGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHN0YWNrW2kyXTtcbiAgICAgICAgICBpZiAoaXNIb2xlKSB7XG4gICAgICAgICAgICBsYXN0Q1dWYWx1ZSA9IGFsbFBhdGhzW2lkZW50aWZpZXJdLmlzQ1c7XG4gICAgICAgICAgICBpc0hvbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzSG9sZUZvciA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q1dWYWx1ZSAhPT0gYWxsUGF0aHNbaWRlbnRpZmllcl0uaXNDVykge1xuICAgICAgICAgICAgbGFzdENXVmFsdWUgPSBhbGxQYXRoc1tpZGVudGlmaWVyXS5pc0NXO1xuICAgICAgICAgICAgaXNIb2xlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaWRlbnRpZmllcjogc2ltcGxlUGF0aC5pZGVudGlmaWVyLCBpc0hvbGUsIGZvcjogaXNIb2xlRm9yIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZpbGwtcnVsZTogXCInICsgX2ZpbGxSdWxlICsgJ1wiIGlzIGN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzY2FubGluZU1pblggPSBCSUdOVU1CRVI7XG4gICAgbGV0IHNjYW5saW5lTWF4WCA9IC1CSUdOVU1CRVI7XG4gICAgbGV0IHNpbXBsZVBhdGhzID0gc2hhcGVQYXRoLnN1YlBhdGhzLm1hcCgocCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRzID0gcC5nZXRQb2ludHMoKTtcbiAgICAgIGxldCBtYXhZID0gLUJJR05VTUJFUjtcbiAgICAgIGxldCBtaW5ZID0gQklHTlVNQkVSO1xuICAgICAgbGV0IG1heFggPSAtQklHTlVNQkVSO1xuICAgICAgbGV0IG1pblggPSBCSUdOVU1CRVI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwMiA9IHBvaW50c1tpXTtcbiAgICAgICAgaWYgKHAyLnkgPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IHAyLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAyLnkgPCBtaW5ZKSB7XG4gICAgICAgICAgbWluWSA9IHAyLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAyLnggPiBtYXhYKSB7XG4gICAgICAgICAgbWF4WCA9IHAyLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAyLnggPCBtaW5YKSB7XG4gICAgICAgICAgbWluWCA9IHAyLng7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY2FubGluZU1heFggPD0gbWF4WCkge1xuICAgICAgICBzY2FubGluZU1heFggPSBtYXhYICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2FubGluZU1pblggPj0gbWluWCkge1xuICAgICAgICBzY2FubGluZU1pblggPSBtaW5YIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlczogcC5jdXJ2ZXMsXG4gICAgICAgIHBvaW50cyxcbiAgICAgICAgaXNDVzogU2hhcGVVdGlscy5pc0Nsb2NrV2lzZShwb2ludHMpLFxuICAgICAgICBpZGVudGlmaWVyOiAtMSxcbiAgICAgICAgYm91bmRpbmdCb3g6IG5ldyBCb3gyKG5ldyBWZWN0b3IyKG1pblgsIG1pblkpLCBuZXcgVmVjdG9yMihtYXhYLCBtYXhZKSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc2ltcGxlUGF0aHMgPSBzaW1wbGVQYXRocy5maWx0ZXIoKHNwKSA9PiBzcC5wb2ludHMubGVuZ3RoID4gMSk7XG4gICAgZm9yIChsZXQgaWRlbnRpZmllciA9IDA7IGlkZW50aWZpZXIgPCBzaW1wbGVQYXRocy5sZW5ndGg7IGlkZW50aWZpZXIrKykge1xuICAgICAgc2ltcGxlUGF0aHNbaWRlbnRpZmllcl0uaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGlzQUhvbGUgPSBzaW1wbGVQYXRocy5tYXAoXG4gICAgICAocCkgPT4gaXNIb2xlVG8oXG4gICAgICAgIHAsXG4gICAgICAgIHNpbXBsZVBhdGhzLFxuICAgICAgICBzY2FubGluZU1pblgsXG4gICAgICAgIHNjYW5saW5lTWF4WCxcbiAgICAgICAgc2hhcGVQYXRoLnVzZXJEYXRhID8gc2hhcGVQYXRoLnVzZXJEYXRhLnN0eWxlLmZpbGxSdWxlIDogdm9pZCAwXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBzaGFwZXNUb1JldHVybiA9IFtdO1xuICAgIHNpbXBsZVBhdGhzLmZvckVhY2goKHApID0+IHtcbiAgICAgIGNvbnN0IGFtSUFIb2xlID0gaXNBSG9sZVtwLmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFhbUlBSG9sZS5pc0hvbGUpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAgICAgICAgc2hhcGUuY3VydmVzID0gcC5jdXJ2ZXM7XG4gICAgICAgIGNvbnN0IGhvbGVzID0gaXNBSG9sZS5maWx0ZXIoKGgpID0+IGguaXNIb2xlICYmIGguZm9yID09PSBwLmlkZW50aWZpZXIpO1xuICAgICAgICBob2xlcy5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaG9sZSA9IHNpbXBsZVBhdGhzW2guaWRlbnRpZmllcl07XG4gICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgICAgcGF0aC5jdXJ2ZXMgPSBob2xlLmN1cnZlcztcbiAgICAgICAgICBzaGFwZS5ob2xlcy5wdXNoKHBhdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2hhcGVzVG9SZXR1cm4ucHVzaChzaGFwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYXBlc1RvUmV0dXJuO1xuICB9XG4gIHN0YXRpYyBnZXRTdHJva2VTdHlsZSh3aWR0aCwgY29sb3IsIGxpbmVKb2luLCBsaW5lQ2FwLCBtaXRlckxpbWl0KSB7XG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdm9pZCAwID8gd2lkdGggOiAxO1xuICAgIGNvbG9yID0gY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogXCIjMDAwXCI7XG4gICAgbGluZUpvaW4gPSBsaW5lSm9pbiAhPT0gdm9pZCAwID8gbGluZUpvaW4gOiBcIm1pdGVyXCI7XG4gICAgbGluZUNhcCA9IGxpbmVDYXAgIT09IHZvaWQgMCA/IGxpbmVDYXAgOiBcImJ1dHRcIjtcbiAgICBtaXRlckxpbWl0ID0gbWl0ZXJMaW1pdCAhPT0gdm9pZCAwID8gbWl0ZXJMaW1pdCA6IDQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZUNvbG9yOiBjb2xvcixcbiAgICAgIHN0cm9rZVdpZHRoOiB3aWR0aCxcbiAgICAgIHN0cm9rZUxpbmVKb2luOiBsaW5lSm9pbixcbiAgICAgIHN0cm9rZUxpbmVDYXA6IGxpbmVDYXAsXG4gICAgICBzdHJva2VNaXRlckxpbWl0OiBtaXRlckxpbWl0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcG9pbnRzVG9TdHJva2UocG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3Qgbm9ybWFscyA9IFtdO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGlmIChTVkdMb2FkZXIucG9pbnRzVG9TdHJva2VXaXRoQnVmZmVycyhwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShcInV2XCIsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBzdGF0aWMgcG9pbnRzVG9TdHJva2VXaXRoQnVmZmVycyhwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzLCB2ZXJ0ZXhPZmZzZXQpIHtcbiAgICBjb25zdCB0ZW1wVjJfMSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgdGVtcFYyXzIgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHRlbXBWMl8zID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCB0ZW1wVjJfNCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgdGVtcFYyXzUgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHRlbXBWMl82ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCB0ZW1wVjJfNyA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgbGFzdFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgbGFzdFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcG9pbnQwTCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcG9pbnQwUiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgY3VycmVudFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgY3VycmVudFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgbmV4dFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgbmV4dFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgaW5uZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgb3V0ZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgYXJjRGl2aXNpb25zID0gYXJjRGl2aXNpb25zICE9PSB2b2lkIDAgPyBhcmNEaXZpc2lvbnMgOiAxMjtcbiAgICBtaW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlICE9PSB2b2lkIDAgPyBtaW5EaXN0YW5jZSA6IDFlLTM7XG4gICAgdmVydGV4T2Zmc2V0ID0gdmVydGV4T2Zmc2V0ICE9PSB2b2lkIDAgPyB2ZXJ0ZXhPZmZzZXQgOiAwO1xuICAgIHBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZWRQb2ludHMocG9pbnRzKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmIChudW1Qb2ludHMgPCAyKVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgaXNDbG9zZWQgPSBwb2ludHNbMF0uZXF1YWxzKHBvaW50c1tudW1Qb2ludHMgLSAxXSk7XG4gICAgbGV0IGN1cnJlbnRQb2ludDtcbiAgICBsZXQgcHJldmlvdXNQb2ludCA9IHBvaW50c1swXTtcbiAgICBsZXQgbmV4dFBvaW50O1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoMiA9IHN0eWxlLnN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBkZWx0YVUgPSAxIC8gKG51bVBvaW50cyAtIDEpO1xuICAgIGxldCB1MCA9IDAsIHUxO1xuICAgIGxldCBpbm5lclNpZGVNb2RpZmllZDtcbiAgICBsZXQgam9pbklzT25MZWZ0U2lkZTtcbiAgICBsZXQgaXNNaXRlcjtcbiAgICBsZXQgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcbiAgICBsZXQgbnVtVmVydGljZXMgPSAwO1xuICAgIGxldCBjdXJyZW50Q29vcmRpbmF0ZSA9IHZlcnRleE9mZnNldCAqIDM7XG4gICAgbGV0IGN1cnJlbnRDb29yZGluYXRlVVYgPSB2ZXJ0ZXhPZmZzZXQgKiAyO1xuICAgIGdldE5vcm1hbChwb2ludHNbMF0sIHBvaW50c1sxXSwgdGVtcFYyXzEpLm11bHRpcGx5U2NhbGFyKHN0cm9rZVdpZHRoMik7XG4gICAgbGFzdFBvaW50TC5jb3B5KHBvaW50c1swXSkuc3ViKHRlbXBWMl8xKTtcbiAgICBsYXN0UG9pbnRSLmNvcHkocG9pbnRzWzBdKS5hZGQodGVtcFYyXzEpO1xuICAgIHBvaW50MEwuY29weShsYXN0UG9pbnRMKTtcbiAgICBwb2ludDBSLmNvcHkobGFzdFBvaW50Uik7XG4gICAgZm9yIChsZXQgaVBvaW50ID0gMTsgaVBvaW50IDwgbnVtUG9pbnRzOyBpUG9pbnQrKykge1xuICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW2lQb2ludF07XG4gICAgICBpZiAoaVBvaW50ID09PSBudW1Qb2ludHMgLSAxKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1sxXTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbmV4dFBvaW50ID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2lQb2ludCArIDFdO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsMSA9IHRlbXBWMl8xO1xuICAgICAgZ2V0Tm9ybWFsKHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbm9ybWFsMSk7XG4gICAgICB0ZW1wVjJfMy5jb3B5KG5vcm1hbDEpLm11bHRpcGx5U2NhbGFyKHN0cm9rZVdpZHRoMik7XG4gICAgICBjdXJyZW50UG9pbnRMLmNvcHkoY3VycmVudFBvaW50KS5zdWIodGVtcFYyXzMpO1xuICAgICAgY3VycmVudFBvaW50Ui5jb3B5KGN1cnJlbnRQb2ludCkuYWRkKHRlbXBWMl8zKTtcbiAgICAgIHUxID0gdTAgKyBkZWx0YVU7XG4gICAgICBpbm5lclNpZGVNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKG5leHRQb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGdldE5vcm1hbChjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgdGVtcFYyXzIpO1xuICAgICAgICB0ZW1wVjJfMy5jb3B5KHRlbXBWMl8yKS5tdWx0aXBseVNjYWxhcihzdHJva2VXaWR0aDIpO1xuICAgICAgICBuZXh0UG9pbnRMLmNvcHkoY3VycmVudFBvaW50KS5zdWIodGVtcFYyXzMpO1xuICAgICAgICBuZXh0UG9pbnRSLmNvcHkoY3VycmVudFBvaW50KS5hZGQodGVtcFYyXzMpO1xuICAgICAgICBqb2luSXNPbkxlZnRTaWRlID0gdHJ1ZTtcbiAgICAgICAgdGVtcFYyXzMuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIHByZXZpb3VzUG9pbnQpO1xuICAgICAgICBpZiAobm9ybWFsMS5kb3QodGVtcFYyXzMpIDwgMCkge1xuICAgICAgICAgIGpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaVBvaW50ID09PSAxKVxuICAgICAgICAgIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlID0gam9pbklzT25MZWZ0U2lkZTtcbiAgICAgICAgdGVtcFYyXzMuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCk7XG4gICAgICAgIHRlbXBWMl8zLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBkb3QgPSBNYXRoLmFicyhub3JtYWwxLmRvdCh0ZW1wVjJfMykpO1xuICAgICAgICBpZiAoZG90ID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICBjb25zdCBtaXRlclNpZGUgPSBzdHJva2VXaWR0aDIgLyBkb3Q7XG4gICAgICAgICAgdGVtcFYyXzMubXVsdGlwbHlTY2FsYXIoLW1pdGVyU2lkZSk7XG4gICAgICAgICAgdGVtcFYyXzQuc3ViVmVjdG9ycyhjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQpO1xuICAgICAgICAgIHRlbXBWMl81LmNvcHkodGVtcFYyXzQpLnNldExlbmd0aChtaXRlclNpZGUpLmFkZCh0ZW1wVjJfMyk7XG4gICAgICAgICAgaW5uZXJQb2ludC5jb3B5KHRlbXBWMl81KS5uZWdhdGUoKTtcbiAgICAgICAgICBjb25zdCBtaXRlckxlbmd0aDIgPSB0ZW1wVjJfNS5sZW5ndGgoKTtcbiAgICAgICAgICBjb25zdCBzZWdtZW50TGVuZ3RoUHJldiA9IHRlbXBWMl80Lmxlbmd0aCgpO1xuICAgICAgICAgIHRlbXBWMl80LmRpdmlkZVNjYWxhcihzZWdtZW50TGVuZ3RoUHJldik7XG4gICAgICAgICAgdGVtcFYyXzYuc3ViVmVjdG9ycyhuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudExlbmd0aE5leHQgPSB0ZW1wVjJfNi5sZW5ndGgoKTtcbiAgICAgICAgICB0ZW1wVjJfNi5kaXZpZGVTY2FsYXIoc2VnbWVudExlbmd0aE5leHQpO1xuICAgICAgICAgIGlmICh0ZW1wVjJfNC5kb3QoaW5uZXJQb2ludCkgPCBzZWdtZW50TGVuZ3RoUHJldiAmJiB0ZW1wVjJfNi5kb3QoaW5uZXJQb2ludCkgPCBzZWdtZW50TGVuZ3RoTmV4dCkge1xuICAgICAgICAgICAgaW5uZXJTaWRlTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRlclBvaW50LmNvcHkodGVtcFYyXzUpLmFkZChjdXJyZW50UG9pbnQpO1xuICAgICAgICAgIGlubmVyUG9pbnQuYWRkKGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgaXNNaXRlciA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpbm5lclNpZGVNb2RpZmllZCkge1xuICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgbmV4dFBvaW50Ui5jb3B5KGlubmVyUG9pbnQpO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnRSLmNvcHkoaW5uZXJQb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0UG9pbnRMLmNvcHkoaW5uZXJQb2ludCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludEwuY29weShpbm5lclBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChzdHlsZS5zdHJva2VMaW5lSm9pbikge1xuICAgICAgICAgICAgY2FzZSBcImJldmVsXCI6XG4gICAgICAgICAgICAgIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbihqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICAgICAgICBjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQpO1xuICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgIG1ha2VDaXJjdWxhclNlY3RvcihjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIG5leHRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWtlQ2lyY3VsYXJTZWN0b3IoY3VycmVudFBvaW50LCBuZXh0UG9pbnRSLCBjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWl0ZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtaXRlci1jbGlwXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zdCBtaXRlckZyYWN0aW9uID0gc3Ryb2tlV2lkdGgyICogc3R5bGUuc3Ryb2tlTWl0ZXJMaW1pdCAvIG1pdGVyTGVuZ3RoMjtcbiAgICAgICAgICAgICAgaWYgKG1pdGVyRnJhY3Rpb24gPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZUxpbmVKb2luICE9PSBcIm1pdGVyLWNsaXBcIikge1xuICAgICAgICAgICAgICAgICAgbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1MSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBWMl82LnN1YlZlY3RvcnMob3V0ZXJQb2ludCwgY3VycmVudFBvaW50TCkubXVsdGlwbHlTY2FsYXIobWl0ZXJGcmFjdGlvbikuYWRkKGN1cnJlbnRQb2ludEwpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wVjJfNy5zdWJWZWN0b3JzKG91dGVyUG9pbnQsIG5leHRQb2ludEwpLm11bHRpcGx5U2NhbGFyKG1pdGVyRnJhY3Rpb24pLmFkZChuZXh0UG9pbnRMKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl82LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNywgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KHRlbXBWMl83LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wVjJfNi5zdWJWZWN0b3JzKG91dGVyUG9pbnQsIGN1cnJlbnRQb2ludFIpLm11bHRpcGx5U2NhbGFyKG1pdGVyRnJhY3Rpb24pLmFkZChjdXJyZW50UG9pbnRSKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFYyXzcuc3ViVmVjdG9ycyhvdXRlclBvaW50LCBuZXh0UG9pbnRSKS5tdWx0aXBseVNjYWxhcihtaXRlckZyYWN0aW9uKS5hZGQobmV4dFBvaW50Uik7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgodGVtcFYyXzcsIHUxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNywgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJTaWRlTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50TC5jb3B5KG91dGVyUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50Ui5jb3B5KG91dGVyUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgob3V0ZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChvdXRlclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRSLCB1MSwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzTWl0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Nsb3NlZCAmJiBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEpIHtcbiAgICAgICAgYWRkQ2FwR2VvbWV0cnkocG9pbnRzWzBdLCBwb2ludDBMLCBwb2ludDBSLCBqb2luSXNPbkxlZnRTaWRlLCB0cnVlLCB1MCk7XG4gICAgICB9XG4gICAgICB1MCA9IHUxO1xuICAgICAgcHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgIGxhc3RQb2ludEwuY29weShuZXh0UG9pbnRMKTtcbiAgICAgIGxhc3RQb2ludFIuY29weShuZXh0UG9pbnRSKTtcbiAgICB9XG4gICAgaWYgKCFpc0Nsb3NlZCkge1xuICAgICAgYWRkQ2FwR2VvbWV0cnkoY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBjdXJyZW50UG9pbnRSLCBqb2luSXNPbkxlZnRTaWRlLCBmYWxzZSwgdTEpO1xuICAgIH0gZWxzZSBpZiAoaW5uZXJTaWRlTW9kaWZpZWQgJiYgdmVydGljZXMpIHtcbiAgICAgIGxldCBsYXN0T3V0ZXIgPSBvdXRlclBvaW50O1xuICAgICAgbGV0IGxhc3RJbm5lciA9IGlubmVyUG9pbnQ7XG4gICAgICBpZiAoaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgIT09IGpvaW5Jc09uTGVmdFNpZGUpIHtcbiAgICAgICAgbGFzdE91dGVyID0gaW5uZXJQb2ludDtcbiAgICAgICAgbGFzdElubmVyID0gb3V0ZXJQb2ludDtcbiAgICAgIH1cbiAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgIGlmIChpc01pdGVyIHx8IGluaXRpYWxKb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgbGFzdElubmVyLnRvQXJyYXkodmVydGljZXMsIDAgKiAzKTtcbiAgICAgICAgICBsYXN0SW5uZXIudG9BcnJheSh2ZXJ0aWNlcywgMyAqIDMpO1xuICAgICAgICAgIGlmIChpc01pdGVyKSB7XG4gICAgICAgICAgICBsYXN0T3V0ZXIudG9BcnJheSh2ZXJ0aWNlcywgMSAqIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTWl0ZXIgfHwgIWluaXRpYWxKb2luSXNPbkxlZnRTaWRlKSB7XG4gICAgICAgICAgbGFzdElubmVyLnRvQXJyYXkodmVydGljZXMsIDEgKiAzKTtcbiAgICAgICAgICBsYXN0SW5uZXIudG9BcnJheSh2ZXJ0aWNlcywgMyAqIDMpO1xuICAgICAgICAgIGlmIChpc01pdGVyKSB7XG4gICAgICAgICAgICBsYXN0T3V0ZXIudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtVmVydGljZXM7XG4gICAgZnVuY3Rpb24gZ2V0Tm9ybWFsKHAxLCBwMiwgcmVzdWx0KSB7XG4gICAgICByZXN1bHQuc3ViVmVjdG9ycyhwMiwgcDEpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zZXQoLXJlc3VsdC55LCByZXN1bHQueCkubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFZlcnRleChwb3NpdGlvbiwgdSwgdikge1xuICAgICAgaWYgKHZlcnRpY2VzKSB7XG4gICAgICAgIHZlcnRpY2VzW2N1cnJlbnRDb29yZGluYXRlXSA9IHBvc2l0aW9uLng7XG4gICAgICAgIHZlcnRpY2VzW2N1cnJlbnRDb29yZGluYXRlICsgMV0gPSBwb3NpdGlvbi55O1xuICAgICAgICB2ZXJ0aWNlc1tjdXJyZW50Q29vcmRpbmF0ZSArIDJdID0gMDtcbiAgICAgICAgaWYgKG5vcm1hbHMpIHtcbiAgICAgICAgICBub3JtYWxzW2N1cnJlbnRDb29yZGluYXRlXSA9IDA7XG4gICAgICAgICAgbm9ybWFsc1tjdXJyZW50Q29vcmRpbmF0ZSArIDFdID0gMDtcbiAgICAgICAgICBub3JtYWxzW2N1cnJlbnRDb29yZGluYXRlICsgMl0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDb29yZGluYXRlICs9IDM7XG4gICAgICAgIGlmICh1dnMpIHtcbiAgICAgICAgICB1dnNbY3VycmVudENvb3JkaW5hdGVVVl0gPSB1O1xuICAgICAgICAgIHV2c1tjdXJyZW50Q29vcmRpbmF0ZVVWICsgMV0gPSB2O1xuICAgICAgICAgIGN1cnJlbnRDb29yZGluYXRlVVYgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbnVtVmVydGljZXMgKz0gMztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUNpcmN1bGFyU2VjdG9yKGNlbnRlciwgcDEsIHAyLCB1LCB2KSB7XG4gICAgICB0ZW1wVjJfMS5jb3B5KHAxKS5zdWIoY2VudGVyKS5ub3JtYWxpemUoKTtcbiAgICAgIHRlbXBWMl8yLmNvcHkocDIpLnN1YihjZW50ZXIpLm5vcm1hbGl6ZSgpO1xuICAgICAgbGV0IGFuZ2xlID0gTWF0aC5QSTtcbiAgICAgIGNvbnN0IGRvdCA9IHRlbXBWMl8xLmRvdCh0ZW1wVjJfMik7XG4gICAgICBpZiAoTWF0aC5hYnMoZG90KSA8IDEpXG4gICAgICAgIGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hY29zKGRvdCkpO1xuICAgICAgYW5nbGUgLz0gYXJjRGl2aXNpb25zO1xuICAgICAgdGVtcFYyXzMuY29weShwMSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBhcmNEaXZpc2lvbnMgLSAxOyBpIDwgaWw7IGkrKykge1xuICAgICAgICB0ZW1wVjJfNC5jb3B5KHRlbXBWMl8zKS5yb3RhdGVBcm91bmQoY2VudGVyLCBhbmdsZSk7XG4gICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfMywgdSwgdik7XG4gICAgICAgIGFkZFZlcnRleCh0ZW1wVjJfNCwgdSwgdik7XG4gICAgICAgIGFkZFZlcnRleChjZW50ZXIsIHUsIDAuNSk7XG4gICAgICAgIHRlbXBWMl8zLmNvcHkodGVtcFYyXzQpO1xuICAgICAgfVxuICAgICAgYWRkVmVydGV4KHRlbXBWMl80LCB1LCB2KTtcbiAgICAgIGFkZFZlcnRleChwMiwgdSwgdik7XG4gICAgICBhZGRWZXJ0ZXgoY2VudGVyLCB1LCAwLjUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VnbWVudFRyaWFuZ2xlcygpIHtcbiAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKGpvaW5Jc09uTGVmdFNpZGUyLCBpbm5lclNpZGVNb2RpZmllZDIsIHUpIHtcbiAgICAgIGlmIChpbm5lclNpZGVNb2RpZmllZDIpIHtcbiAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUyKSB7XG4gICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludFIsIHUwLCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTEsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1LCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdSwgMC41KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludFIsIHUxLCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdSwgMSk7XG4gICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRSLCB1LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUyKSB7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRMLCB1LCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1LCAwLjUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1LCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgobmV4dFBvaW50UiwgdSwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdSwgMC41KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oam9pbklzT25MZWZ0U2lkZTIsIGlubmVyU2lkZU1vZGlmaWVkMikge1xuICAgICAgaWYgKGlubmVyU2lkZU1vZGlmaWVkMikge1xuICAgICAgICBpZiAoam9pbklzT25MZWZ0U2lkZTIpIHtcbiAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludEwsIHUxLCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgobGFzdFBvaW50UiwgdTAsIDEpO1xuICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRMLCB1MSwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAxKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50TCwgdTAsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnQsIHUxLCAwLjUpO1xuICAgICAgICAgIGFkZFZlcnRleChpbm5lclBvaW50LCB1MSwgMSk7XG4gICAgICAgICAgYWRkVmVydGV4KGN1cnJlbnRQb2ludCwgdTEsIDAuNSk7XG4gICAgICAgICAgYWRkVmVydGV4KG5leHRQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgYWRkVmVydGV4KGxhc3RQb2ludEwsIHUwLCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgIGFkZFZlcnRleChsYXN0UG9pbnRMLCB1MCwgMCk7XG4gICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50UiwgdTEsIDEpO1xuICAgICAgICAgIGFkZFZlcnRleChjdXJyZW50UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgICAgYWRkVmVydGV4KGlubmVyUG9pbnQsIHUxLCAwKTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoY3VycmVudFBvaW50LCB1MSwgMC41KTtcbiAgICAgICAgICBhZGRWZXJ0ZXgoaW5uZXJQb2ludCwgdTEsIDApO1xuICAgICAgICAgIGFkZFZlcnRleChuZXh0UG9pbnRSLCB1MCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ2FwR2VvbWV0cnkoY2VudGVyLCBwMSwgcDIsIGpvaW5Jc09uTGVmdFNpZGUyLCBzdGFydCwgdSkge1xuICAgICAgc3dpdGNoIChzdHlsZS5zdHJva2VMaW5lQ2FwKSB7XG4gICAgICAgIGNhc2UgXCJyb3VuZFwiOlxuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgbWFrZUNpcmN1bGFyU2VjdG9yKGNlbnRlciwgcDIsIHAxLCB1LCAwLjUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWtlQ2lyY3VsYXJTZWN0b3IoY2VudGVyLCBwMSwgcDIsIHUsIDAuNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICB0ZW1wVjJfMS5zdWJWZWN0b3JzKHAxLCBjZW50ZXIpO1xuICAgICAgICAgICAgdGVtcFYyXzIuc2V0KHRlbXBWMl8xLnksIC10ZW1wVjJfMS54KTtcbiAgICAgICAgICAgIHRlbXBWMl8zLmFkZFZlY3RvcnModGVtcFYyXzEsIHRlbXBWMl8yKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgIHRlbXBWMl80LnN1YlZlY3RvcnModGVtcFYyXzIsIHRlbXBWMl8xKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgIGlmIChqb2luSXNPbkxlZnRTaWRlMikge1xuICAgICAgICAgICAgICB0ZW1wVjJfMy50b0FycmF5KHZlcnRpY2VzLCAxICogMyk7XG4gICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIDAgKiAzKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgMyAqIDMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGVtcFYyXzMudG9BcnJheSh2ZXJ0aWNlcywgMSAqIDMpO1xuICAgICAgICAgICAgICB1dnNbMyAqIDIgKyAxXSA9PT0gMSA/IHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIDMgKiAzKSA6IHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIDMgKiAzKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgMCAqIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wVjJfMS5zdWJWZWN0b3JzKHAyLCBjZW50ZXIpO1xuICAgICAgICAgICAgdGVtcFYyXzIuc2V0KHRlbXBWMl8xLnksIC10ZW1wVjJfMS54KTtcbiAgICAgICAgICAgIHRlbXBWMl8zLmFkZFZlY3RvcnModGVtcFYyXzEsIHRlbXBWMl8yKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgIHRlbXBWMl80LnN1YlZlY3RvcnModGVtcFYyXzIsIHRlbXBWMl8xKS5hZGQoY2VudGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHZsID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGpvaW5Jc09uTGVmdFNpZGUyKSB7XG4gICAgICAgICAgICAgIHRlbXBWMl8zLnRvQXJyYXkodmVydGljZXMsIHZsIC0gMSAqIDMpO1xuICAgICAgICAgICAgICB0ZW1wVjJfNC50b0FycmF5KHZlcnRpY2VzLCB2bCAtIDIgKiAzKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzQudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSA0ICogMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZW1wVjJfNC50b0FycmF5KHZlcnRpY2VzLCB2bCAtIDIgKiAzKTtcbiAgICAgICAgICAgICAgdGVtcFYyXzMudG9BcnJheSh2ZXJ0aWNlcywgdmwgLSAxICogMyk7XG4gICAgICAgICAgICAgIHRlbXBWMl80LnRvQXJyYXkodmVydGljZXMsIHZsIC0gNCAqIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyhwb2ludHMyKSB7XG4gICAgICBsZXQgZHVwUG9pbnRzID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMSwgbiA9IHBvaW50czIubGVuZ3RoIC0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAocG9pbnRzMltpXS5kaXN0YW5jZVRvKHBvaW50czJbaSArIDFdKSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgZHVwUG9pbnRzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkdXBQb2ludHMpXG4gICAgICAgIHJldHVybiBwb2ludHMyO1xuICAgICAgY29uc3QgbmV3UG9pbnRzID0gW107XG4gICAgICBuZXdQb2ludHMucHVzaChwb2ludHMyWzBdKTtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBuID0gcG9pbnRzMi5sZW5ndGggLSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChwb2ludHMyW2ldLmRpc3RhbmNlVG8ocG9pbnRzMltpICsgMV0pID49IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnRzMltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50czJbcG9pbnRzMi5sZW5ndGggLSAxXSk7XG4gICAgICByZXR1cm4gbmV3UG9pbnRzO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgU1ZHTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/SVGLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz83MDU4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLGtEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBMEI7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLHNCQUFzQixjQUFjO0FBQ3BDLG9CQUFvQiw2REFBVTtBQUM5QixvQkFBb0IsNkRBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQyxtQkFBbUIsbURBQW1EO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWU7QUFDekM7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBLG1DQUFtQyxrREFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQW1CLGlCQUFpQix3REFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFtQjtBQUMxQyx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQU87QUFDekIsa0JBQWtCLDBDQUFPO0FBQ3pCLGtCQUFrQiwwQ0FBTztBQUN6QixxQkFBcUIsMENBQU87QUFDNUIscUJBQXFCLDBDQUFPO0FBQzVCLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FBQzdCLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcz9mN2YyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;