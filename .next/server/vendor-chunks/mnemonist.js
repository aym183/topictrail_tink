/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mnemonist";
exports.ids = ["vendor-chunks/mnemonist"];
exports.modules = {

/***/ "(ssr)/./node_modules/mnemonist/heap.js":
/*!****************************************!*\
  !*** ./node_modules/mnemonist/heap.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = __webpack_require__(/*! obliterator/foreach */ \"(ssr)/./node_modules/obliterator/foreach.js\"),\n    comparators = __webpack_require__(/*! ./utils/comparators.js */ \"(ssr)/./node_modules/mnemonist/utils/comparators.js\"),\n    iterables = __webpack_require__(/*! ./utils/iterables.js */ \"(ssr)/./node_modules/mnemonist/utils/iterables.js\");\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = (i - 1) >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n\n    return item;\n  }\n\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0)\n    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0)\n    siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n\n  var array = new Array(l);\n\n  while (i < l)\n    array[i++] = pop(compare, heap);\n\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var min = Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (min === Infinity || compare(v, min) < 0)\n          min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (min === Infinity || compare(value, min) < 0)\n        min = value;\n    });\n\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(compare);\n\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (reverseCompare(iterable[i], result[0]) > 0)\n        replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(reverseCompare, result);\n\n      if (reverseCompare(value, result[0]) > 0)\n        replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var max = -Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (max === -Infinity || compare(v, max) > 0)\n          max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (max === -Infinity || compare(value, max) > 0)\n        max = value;\n    });\n\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(reverseCompare);\n\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (compare(iterable[i], result[0]) > 0)\n        replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(compare, result);\n\n      if (compare(value, result[0]) > 0)\n        replace(compare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function(item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function() {\n  if (this.size !== 0)\n    this.size--;\n\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function(item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function(item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function() {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function() {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function(iterable, comparator) {\n  var heap = new Heap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\nMaxHeap.from = function(iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\n\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\n\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\n\nmodule.exports = Heap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW5lbW9uaXN0L2hlYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHdFQUFxQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbEQsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQXNCOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9tbmVtb25pc3QvaGVhcC5qcz82YTlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW5lbW9uaXN0IEJpbmFyeSBIZWFwXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQmluYXJ5IGhlYXAgaW1wbGVtZW50YXRpb24uXG4gKi9cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnb2JsaXRlcmF0b3IvZm9yZWFjaCcpLFxuICAgIGNvbXBhcmF0b3JzID0gcmVxdWlyZSgnLi91dGlscy9jb21wYXJhdG9ycy5qcycpLFxuICAgIGl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4vdXRpbHMvaXRlcmFibGVzLmpzJyk7XG5cbnZhciBERUZBVUxUX0NPTVBBUkFUT1IgPSBjb21wYXJhdG9ycy5ERUZBVUxUX0NPTVBBUkFUT1IsXG4gICAgcmV2ZXJzZUNvbXBhcmF0b3IgPSBjb21wYXJhdG9ycy5yZXZlcnNlQ29tcGFyYXRvcjtcblxuLyoqXG4gKiBIZWFwIGhlbHBlciBmdW5jdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHNpZnQgZG93bi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlICAgIC0gQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7YXJyYXl9ICAgIGhlYXAgICAgICAgLSBBcnJheSBzdG9yaW5nIHRoZSBoZWFwJ3MgZGF0YS5cbiAqIEBwYXJhbSB7bnVtYmVyfSAgIHN0YXJ0SW5kZXggLSBTdGFydGluZyBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSAgIGkgICAgICAgICAgLSBJbmRleC5cbiAqL1xuZnVuY3Rpb24gc2lmdERvd24oY29tcGFyZSwgaGVhcCwgc3RhcnRJbmRleCwgaSkge1xuICB2YXIgaXRlbSA9IGhlYXBbaV0sXG4gICAgICBwYXJlbnRJbmRleCxcbiAgICAgIHBhcmVudDtcblxuICB3aGlsZSAoaSA+IHN0YXJ0SW5kZXgpIHtcbiAgICBwYXJlbnRJbmRleCA9IChpIC0gMSkgPj4gMTtcbiAgICBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKGl0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICBoZWFwW2ldID0gcGFyZW50O1xuICAgICAgaSA9IHBhcmVudEluZGV4O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYnJlYWs7XG4gIH1cblxuICBoZWFwW2ldID0gaXRlbTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHNpZnQgdXAuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZSAtIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2FycmF5fSAgICBoZWFwICAgIC0gQXJyYXkgc3RvcmluZyB0aGUgaGVhcCdzIGRhdGEuXG4gKiBAcGFyYW0ge251bWJlcn0gICBpICAgICAgIC0gSW5kZXguXG4gKi9cbmZ1bmN0aW9uIHNpZnRVcChjb21wYXJlLCBoZWFwLCBpKSB7XG4gIHZhciBlbmRJbmRleCA9IGhlYXAubGVuZ3RoLFxuICAgICAgc3RhcnRJbmRleCA9IGksXG4gICAgICBpdGVtID0gaGVhcFtpXSxcbiAgICAgIGNoaWxkSW5kZXggPSAyICogaSArIDEsXG4gICAgICByaWdodEluZGV4O1xuXG4gIHdoaWxlIChjaGlsZEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICByaWdodEluZGV4ID0gY2hpbGRJbmRleCArIDE7XG5cbiAgICBpZiAoXG4gICAgICByaWdodEluZGV4IDwgZW5kSW5kZXggJiZcbiAgICAgIGNvbXBhcmUoaGVhcFtjaGlsZEluZGV4XSwgaGVhcFtyaWdodEluZGV4XSkgPj0gMFxuICAgICkge1xuICAgICAgY2hpbGRJbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfVxuXG4gICAgaGVhcFtpXSA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgaSA9IGNoaWxkSW5kZXg7XG4gICAgY2hpbGRJbmRleCA9IDIgKiBpICsgMTtcbiAgfVxuXG4gIGhlYXBbaV0gPSBpdGVtO1xuICBzaWZ0RG93bihjb21wYXJlLCBoZWFwLCBzdGFydEluZGV4LCBpKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHB1c2ggYW4gaXRlbSBpbnRvIGEgaGVhcCByZXByZXNlbnRlZCBieSBhIHJhdyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlIC0gQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7YXJyYXl9ICAgIGhlYXAgICAgLSBBcnJheSBzdG9yaW5nIHRoZSBoZWFwJ3MgZGF0YS5cbiAqIEBwYXJhbSB7YW55fSAgICAgIGl0ZW0gICAgLSBJdGVtIHRvIHB1c2guXG4gKi9cbmZ1bmN0aW9uIHB1c2goY29tcGFyZSwgaGVhcCwgaXRlbSkge1xuICBoZWFwLnB1c2goaXRlbSk7XG4gIHNpZnREb3duKGNvbXBhcmUsIGhlYXAsIDAsIGhlYXAubGVuZ3RoIC0gMSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBwb3AgYW4gaXRlbSBmcm9tIGEgaGVhcCByZXByZXNlbnRlZCBieSBhIHJhdyBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY29tcGFyZSAtIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHthcnJheX0gICAgaGVhcCAgICAtIEFycmF5IHN0b3JpbmcgdGhlIGhlYXAncyBkYXRhLlxuICogQHJldHVybiB7YW55fVxuICovXG5mdW5jdGlvbiBwb3AoY29tcGFyZSwgaGVhcCkge1xuICB2YXIgbGFzdEl0ZW0gPSBoZWFwLnBvcCgpO1xuXG4gIGlmIChoZWFwLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBpdGVtID0gaGVhcFswXTtcbiAgICBoZWFwWzBdID0gbGFzdEl0ZW07XG4gICAgc2lmdFVwKGNvbXBhcmUsIGhlYXAsIDApO1xuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICByZXR1cm4gbGFzdEl0ZW07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBwb3AgdGhlIGhlYXAgdGhlbiBwdXNoIGEgbmV3IHZhbHVlIGludG8gaXQsIHRodXMgXCJyZXBsYWNpbmdcIlxuICogaXQuXG4gKlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNvbXBhcmUgLSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7YXJyYXl9ICAgIGhlYXAgICAgLSBBcnJheSBzdG9yaW5nIHRoZSBoZWFwJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2FueX0gICAgICBpdGVtICAgIC0gVGhlIGl0ZW0gdG8gcHVzaC5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZShjb21wYXJlLCBoZWFwLCBpdGVtKSB7XG4gIGlmIChoZWFwLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21uZW1vbmlzdC9oZWFwLnJlcGxhY2U6IGNhbm5vdCBwb3AgYW4gZW1wdHkgaGVhcC4nKTtcblxuICB2YXIgcG9wcGVkID0gaGVhcFswXTtcbiAgaGVhcFswXSA9IGl0ZW07XG4gIHNpZnRVcChjb21wYXJlLCBoZWFwLCAwKTtcblxuICByZXR1cm4gcG9wcGVkO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gcHVzaCBhbiBpdGVtIGluIHRoZSBoZWFwIHRoZW4gcG9wIHRoZSBoZWFwIGFuZCByZXR1cm4gdGhlXG4gKiBwb3BwZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNvbXBhcmUgLSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7YXJyYXl9ICAgIGhlYXAgICAgLSBBcnJheSBzdG9yaW5nIHRoZSBoZWFwJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2FueX0gICAgICBpdGVtICAgIC0gVGhlIGl0ZW0gdG8gcHVzaC5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gcHVzaHBvcChjb21wYXJlLCBoZWFwLCBpdGVtKSB7XG4gIHZhciB0bXA7XG5cbiAgaWYgKGhlYXAubGVuZ3RoICE9PSAwICYmIGNvbXBhcmUoaGVhcFswXSwgaXRlbSkgPCAwKSB7XG4gICAgdG1wID0gaGVhcFswXTtcbiAgICBoZWFwWzBdID0gaXRlbTtcbiAgICBpdGVtID0gdG1wO1xuICAgIHNpZnRVcChjb21wYXJlLCBoZWFwLCAwKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuZCBhcnJheSBpbnRvIGFuIGFic3RyYWN0IGhlYXAgaW4gbGluZWFyIHRpbWUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZSAtIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2FycmF5fSAgICBhcnJheSAgIC0gVGFyZ2V0IGFycmF5LlxuICovXG5mdW5jdGlvbiBoZWFwaWZ5KGNvbXBhcmUsIGFycmF5KSB7XG4gIHZhciBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbCA9IG4gPj4gMSxcbiAgICAgIGkgPSBsO1xuXG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBzaWZ0VXAoY29tcGFyZSwgYXJyYXksIGkpO1xufVxuXG4vKipcbiAqIEZ1bGx5IGNvbnN1bWVzIHRoZSBnaXZlbiBoZWFwLlxuICpcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjb21wYXJlIC0gQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge2FycmF5fSAgICBoZWFwICAgIC0gQXJyYXkgc3RvcmluZyB0aGUgaGVhcCdzIGRhdGEuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZShjb21wYXJlLCBoZWFwKSB7XG4gIHZhciBsID0gaGVhcC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobCk7XG5cbiAgd2hpbGUgKGkgPCBsKVxuICAgIGFycmF5W2krK10gPSBwb3AoY29tcGFyZSwgaGVhcCk7XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gcmV0cmlldmUgdGhlIG4gc21hbGxlc3QgaXRlbXMgZnJvbSB0aGUgZ2l2ZW4gaXRlcmFibGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZSAgLSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9ICAgbiAgICAgICAgLSBOdW1iZXIgb2YgdG9wIGl0ZW1zIHRvIHJldHJpZXZlLlxuICogQHBhcmFtIHthbnl9ICAgICAgaXRlcmFibGUgLSBBcmJpdHJhcnkgaXRlcmFibGUuXG4gKiBAcGFyYW0ge2FycmF5fVxuICovXG5mdW5jdGlvbiBuc21hbGxlc3QoY29tcGFyZSwgbiwgaXRlcmFibGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpdGVyYWJsZSA9IG47XG4gICAgbiA9IGNvbXBhcmU7XG4gICAgY29tcGFyZSA9IERFRkFVTFRfQ09NUEFSQVRPUjtcbiAgfVxuXG4gIHZhciByZXZlcnNlQ29tcGFyZSA9IHJldmVyc2VDb21wYXJhdG9yKGNvbXBhcmUpO1xuXG4gIHZhciBpLCBsLCB2O1xuXG4gIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICB2YXIgcmVzdWx0O1xuXG4gIC8vIElmIG4gaXMgZXF1YWwgdG8gMSwgaXQncyBqdXN0IGEgbWF0dGVyIG9mIGZpbmRpbmcgdGhlIG1pbmltdW1cbiAgaWYgKG4gPT09IDEpIHtcbiAgICBpZiAoaXRlcmFibGVzLmlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZXJhYmxlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2ID0gaXRlcmFibGVbaV07XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gSW5maW5pdHkgfHwgY29tcGFyZSh2LCBtaW4pIDwgMClcbiAgICAgICAgICBtaW4gPSB2O1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgaXRlcmFibGUuY29uc3RydWN0b3IoMSk7XG4gICAgICByZXN1bHRbMF0gPSBtaW47XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChtaW4gPT09IEluZmluaXR5IHx8IGNvbXBhcmUodmFsdWUsIG1pbikgPCAwKVxuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBbbWluXTtcbiAgfVxuXG4gIGlmIChpdGVyYWJsZXMuaXNBcnJheUxpa2UoaXRlcmFibGUpKSB7XG5cbiAgICAvLyBJZiBuID4gaXRlcmFibGUgbGVuZ3RoLCB3ZSBqdXN0IGNsb25lIGFuZCBzb3J0XG4gICAgaWYgKG4gPj0gaXRlcmFibGUubGVuZ3RoKVxuICAgICAgcmV0dXJuIGl0ZXJhYmxlLnNsaWNlKCkuc29ydChjb21wYXJlKTtcblxuICAgIHJlc3VsdCA9IGl0ZXJhYmxlLnNsaWNlKDAsIG4pO1xuICAgIGhlYXBpZnkocmV2ZXJzZUNvbXBhcmUsIHJlc3VsdCk7XG5cbiAgICBmb3IgKGkgPSBuLCBsID0gaXRlcmFibGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHJldmVyc2VDb21wYXJlKGl0ZXJhYmxlW2ldLCByZXN1bHRbMF0pID4gMClcbiAgICAgICAgcmVwbGFjZShyZXZlcnNlQ29tcGFyZSwgcmVzdWx0LCBpdGVyYWJsZVtpXSk7XG5cbiAgICAvLyBOT1RFOiBpZiBuIGlzIG92ZXIgc29tZSBudW1iZXIsIGl0IGJlY29tZXMgZmFzdGVyIHRvIGNvbnN1bWUgdGhlIGhlYXBcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY29tcGFyZSk7XG4gIH1cblxuICAvLyBDb3JyZWN0IGZvciBzaXplXG4gIHZhciBzaXplID0gaXRlcmFibGVzLmd1ZXNzTGVuZ3RoKGl0ZXJhYmxlKTtcblxuICBpZiAoc2l6ZSAhPT0gbnVsbCAmJiBzaXplIDwgbilcbiAgICBuID0gc2l6ZTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkobik7XG4gIGkgPSAwO1xuXG4gIGZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGkgPCBuKSB7XG4gICAgICByZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gbilcbiAgICAgICAgaGVhcGlmeShyZXZlcnNlQ29tcGFyZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKHJldmVyc2VDb21wYXJlKHZhbHVlLCByZXN1bHRbMF0pID4gMClcbiAgICAgICAgcmVwbGFjZShyZXZlcnNlQ29tcGFyZSwgcmVzdWx0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9KTtcblxuICBpZiAocmVzdWx0Lmxlbmd0aCA+IGkpXG4gICAgcmVzdWx0Lmxlbmd0aCA9IGk7XG5cbiAgLy8gTk9URTogaWYgbiBpcyBvdmVyIHNvbWUgbnVtYmVyLCBpdCBiZWNvbWVzIGZhc3RlciB0byBjb25zdW1lIHRoZSBoZWFwXG4gIHJldHVybiByZXN1bHQuc29ydChjb21wYXJlKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBuIGxhcmdlc3QgaXRlbXMgZnJvbSB0aGUgZ2l2ZW4gaXRlcmFibGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZSAgLSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9ICAgbiAgICAgICAgLSBOdW1iZXIgb2YgdG9wIGl0ZW1zIHRvIHJldHJpZXZlLlxuICogQHBhcmFtIHthbnl9ICAgICAgaXRlcmFibGUgLSBBcmJpdHJhcnkgaXRlcmFibGUuXG4gKiBAcGFyYW0ge2FycmF5fVxuICovXG5mdW5jdGlvbiBubGFyZ2VzdChjb21wYXJlLCBuLCBpdGVyYWJsZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGl0ZXJhYmxlID0gbjtcbiAgICBuID0gY29tcGFyZTtcbiAgICBjb21wYXJlID0gREVGQVVMVF9DT01QQVJBVE9SO1xuICB9XG5cbiAgdmFyIHJldmVyc2VDb21wYXJlID0gcmV2ZXJzZUNvbXBhcmF0b3IoY29tcGFyZSk7XG5cbiAgdmFyIGksIGwsIHY7XG5cbiAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICB2YXIgcmVzdWx0O1xuXG4gIC8vIElmIG4gaXMgZXF1YWwgdG8gMSwgaXQncyBqdXN0IGEgbWF0dGVyIG9mIGZpbmRpbmcgdGhlIG1heGltdW1cbiAgaWYgKG4gPT09IDEpIHtcbiAgICBpZiAoaXRlcmFibGVzLmlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZXJhYmxlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2ID0gaXRlcmFibGVbaV07XG5cbiAgICAgICAgaWYgKG1heCA9PT0gLUluZmluaXR5IHx8IGNvbXBhcmUodiwgbWF4KSA+IDApXG4gICAgICAgICAgbWF4ID0gdjtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gbmV3IGl0ZXJhYmxlLmNvbnN0cnVjdG9yKDEpO1xuICAgICAgcmVzdWx0WzBdID0gbWF4O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAobWF4ID09PSAtSW5maW5pdHkgfHwgY29tcGFyZSh2YWx1ZSwgbWF4KSA+IDApXG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFttYXhdO1xuICB9XG5cbiAgaWYgKGl0ZXJhYmxlcy5pc0FycmF5TGlrZShpdGVyYWJsZSkpIHtcblxuICAgIC8vIElmIG4gPiBpdGVyYWJsZSBsZW5ndGgsIHdlIGp1c3QgY2xvbmUgYW5kIHNvcnRcbiAgICBpZiAobiA+PSBpdGVyYWJsZS5sZW5ndGgpXG4gICAgICByZXR1cm4gaXRlcmFibGUuc2xpY2UoKS5zb3J0KHJldmVyc2VDb21wYXJlKTtcblxuICAgIHJlc3VsdCA9IGl0ZXJhYmxlLnNsaWNlKDAsIG4pO1xuICAgIGhlYXBpZnkoY29tcGFyZSwgcmVzdWx0KTtcblxuICAgIGZvciAoaSA9IG4sIGwgPSBpdGVyYWJsZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoY29tcGFyZShpdGVyYWJsZVtpXSwgcmVzdWx0WzBdKSA+IDApXG4gICAgICAgIHJlcGxhY2UoY29tcGFyZSwgcmVzdWx0LCBpdGVyYWJsZVtpXSk7XG5cbiAgICAvLyBOT1RFOiBpZiBuIGlzIG92ZXIgc29tZSBudW1iZXIsIGl0IGJlY29tZXMgZmFzdGVyIHRvIGNvbnN1bWUgdGhlIGhlYXBcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQocmV2ZXJzZUNvbXBhcmUpO1xuICB9XG5cbiAgLy8gQ29ycmVjdCBmb3Igc2l6ZVxuICB2YXIgc2l6ZSA9IGl0ZXJhYmxlcy5ndWVzc0xlbmd0aChpdGVyYWJsZSk7XG5cbiAgaWYgKHNpemUgIT09IG51bGwgJiYgc2l6ZSA8IG4pXG4gICAgbiA9IHNpemU7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG4pO1xuICBpID0gMDtcblxuICBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChpIDwgbikge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGkgPT09IG4pXG4gICAgICAgIGhlYXBpZnkoY29tcGFyZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIHJlc3VsdFswXSkgPiAwKVxuICAgICAgICByZXBsYWNlKGNvbXBhcmUsIHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGkrKztcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGggPiBpKVxuICAgIHJlc3VsdC5sZW5ndGggPSBpO1xuXG4gIC8vIE5PVEU6IGlmIG4gaXMgb3ZlciBzb21lIG51bWJlciwgaXQgYmVjb21lcyBmYXN0ZXIgdG8gY29uc3VtZSB0aGUgaGVhcFxuICByZXR1cm4gcmVzdWx0LnNvcnQocmV2ZXJzZUNvbXBhcmUpO1xufVxuXG4vKipcbiAqIEJpbmFyeSBNaW5pbXVtIEhlYXAuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvciBmdW5jdGlvbiB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIEhlYXAoY29tcGFyYXRvcikge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgfHwgREVGQVVMVF9DT01QQVJBVE9SO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5jb21wYXJhdG9yICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignbW5lbW9uaXN0L0hlYXAuY29uc3RydWN0b3I6IGdpdmVuIGNvbXBhcmF0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24uJyk7XG59XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8gY2xlYXIgdGhlIGhlYXAuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5IZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy5pdGVtcyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBwdXNoIGFuIGl0ZW0gaW50byB0aGUgaGVhcC5cbiAqXG4gKiBAcGFyYW0gIHthbnl9ICAgIGl0ZW0gLSBJdGVtIHRvIHB1c2guXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHB1c2godGhpcy5jb21wYXJhdG9yLCB0aGlzLml0ZW1zLCBpdGVtKTtcbiAgcmV0dXJuICsrdGhpcy5zaXplO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSB0aGUgXCJmaXJzdFwiIGl0ZW0gb2YgdGhlIGhlYXAuXG4gKlxuICogQHJldHVybiB7YW55fVxuICovXG5IZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zWzBdO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSAmIHJlbW92ZSB0aGUgXCJmaXJzdFwiIGl0ZW0gb2YgdGhlIGhlYXAuXG4gKlxuICogQHJldHVybiB7YW55fVxuICovXG5IZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSAhPT0gMClcbiAgICB0aGlzLnNpemUtLTtcblxuICByZXR1cm4gcG9wKHRoaXMuY29tcGFyYXRvciwgdGhpcy5pdGVtcyk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIHBvcCB0aGUgaGVhcCwgdGhlbiBwdXNoIGFuIGl0ZW0gYW5kIHJldHVybiB0aGUgcG9wcGVkXG4gKiBpdGVtLlxuICpcbiAqIEBwYXJhbSAge2FueX0gaXRlbSAtIEl0ZW0gdG8gcHVzaCBpbnRvIHRoZSBoZWFwLlxuICogQHJldHVybiB7YW55fVxuICovXG5IZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oaXRlbSkge1xuICByZXR1cm4gcmVwbGFjZSh0aGlzLmNvbXBhcmF0b3IsIHRoaXMuaXRlbXMsIGl0ZW0pO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBwdXNoIHRoZSBoZWFwLCB0aGUgcG9wIGl0IGFuZCByZXR1cm4gdGhlIHBvb3BlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSAge2FueX0gaXRlbSAtIEl0ZW0gdG8gcHVzaCBpbnRvIHRoZSBoZWFwLlxuICogQHJldHVybiB7YW55fVxuICovXG5IZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oaXRlbSkge1xuICByZXR1cm4gcHVzaHBvcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMuaXRlbXMsIGl0ZW0pO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBjb25zdW1lIHRoZSBoZWFwIGZ1bGx5IGFuZCByZXR1cm4gaXRzIGl0ZW1zIGFzIGEgc29ydGVkIGFycmF5LlxuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5IZWFwLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHJldHVybiBjb25zdW1lKHRoaXMuY29tcGFyYXRvciwgdGhpcy5pdGVtcyk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIGNvbnZlcnQgdGhlIGhlYXAgdG8gYW4gYXJyYXkuIE5vdGUgdGhhdCBpdCBiYXNpY2FsbHkgY2xvbmVcbiAqIHRoZSBoZWFwIGFuZCBjb25zdW1lcyBpdCBjb21wbGV0ZWx5LiBUaGlzIGlzIGhhcmRseSBwZXJmb3JtYW50LlxuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5IZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjb25zdW1lKHRoaXMuY29tcGFyYXRvciwgdGhpcy5pdGVtcy5zbGljZSgpKTtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2Uga25vd24gbWV0aG9kcy5cbiAqL1xuSGVhcC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHJveHkgPSB0aGlzLnRvQXJyYXkoKTtcblxuICAvLyBUcmljayBzbyB0aGF0IG5vZGUgZGlzcGxheXMgdGhlIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ2NvbnN0cnVjdG9yJywge1xuICAgIHZhbHVlOiBIZWFwLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuXG4gIHJldHVybiBwcm94eTtcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJylcbiAgSGVhcC5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBIZWFwLnByb3RvdHlwZS5pbnNwZWN0O1xuXG4vKipcbiAqIEJpbmFyeSBNYXhpbXVtIEhlYXAuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvciBmdW5jdGlvbiB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIE1heEhlYXAoY29tcGFyYXRvcikge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgfHwgREVGQVVMVF9DT01QQVJBVE9SO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5jb21wYXJhdG9yICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignbW5lbW9uaXN0L01heEhlYXAuY29uc3RydWN0b3I6IGdpdmVuIGNvbXBhcmF0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24uJyk7XG5cbiAgdGhpcy5jb21wYXJhdG9yID0gcmV2ZXJzZUNvbXBhcmF0b3IodGhpcy5jb21wYXJhdG9yKTtcbn1cblxuTWF4SGVhcC5wcm90b3R5cGUgPSBIZWFwLnByb3RvdHlwZTtcblxuLyoqXG4gKiBTdGF0aWMgQC5mcm9tIGZ1bmN0aW9uIHRha2luZyBhbiBhcmJpdHJhcnkgaXRlcmFibGUgJiBjb252ZXJ0aW5nIGl0IGludG9cbiAqIGEgaGVhcC5cbiAqXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gaXRlcmFibGUgICAtIFRhcmdldCBpdGVyYWJsZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjb21wYXJhdG9yIC0gQ3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIZWFwfVxuICovXG5IZWFwLmZyb20gPSBmdW5jdGlvbihpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICB2YXIgaGVhcCA9IG5ldyBIZWFwKGNvbXBhcmF0b3IpO1xuXG4gIHZhciBpdGVtcztcblxuICAvLyBJZiBpdGVyYWJsZSBpcyBhbiBhcnJheSwgd2UgY2FuIGJlIGNsZXZlciBhYm91dCBpdFxuICBpZiAoaXRlcmFibGVzLmlzQXJyYXlMaWtlKGl0ZXJhYmxlKSlcbiAgICBpdGVtcyA9IGl0ZXJhYmxlLnNsaWNlKCk7XG4gIGVsc2VcbiAgICBpdGVtcyA9IGl0ZXJhYmxlcy50b0FycmF5KGl0ZXJhYmxlKTtcblxuICBoZWFwaWZ5KGhlYXAuY29tcGFyYXRvciwgaXRlbXMpO1xuICBoZWFwLml0ZW1zID0gaXRlbXM7XG4gIGhlYXAuc2l6ZSA9IGl0ZW1zLmxlbmd0aDtcblxuICByZXR1cm4gaGVhcDtcbn07XG5cbk1heEhlYXAuZnJvbSA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBoZWFwID0gbmV3IE1heEhlYXAoY29tcGFyYXRvcik7XG5cbiAgdmFyIGl0ZW1zO1xuXG4gIC8vIElmIGl0ZXJhYmxlIGlzIGFuIGFycmF5LCB3ZSBjYW4gYmUgY2xldmVyIGFib3V0IGl0XG4gIGlmIChpdGVyYWJsZXMuaXNBcnJheUxpa2UoaXRlcmFibGUpKVxuICAgIGl0ZW1zID0gaXRlcmFibGUuc2xpY2UoKTtcbiAgZWxzZVxuICAgIGl0ZW1zID0gaXRlcmFibGVzLnRvQXJyYXkoaXRlcmFibGUpO1xuXG4gIGhlYXBpZnkoaGVhcC5jb21wYXJhdG9yLCBpdGVtcyk7XG4gIGhlYXAuaXRlbXMgPSBpdGVtcztcbiAgaGVhcC5zaXplID0gaXRlbXMubGVuZ3RoO1xuXG4gIHJldHVybiBoZWFwO1xufTtcblxuLyoqXG4gKiBFeHBvcnRpbmcuXG4gKi9cbkhlYXAuc2lmdFVwID0gc2lmdFVwO1xuSGVhcC5zaWZ0RG93biA9IHNpZnREb3duO1xuSGVhcC5wdXNoID0gcHVzaDtcbkhlYXAucG9wID0gcG9wO1xuSGVhcC5yZXBsYWNlID0gcmVwbGFjZTtcbkhlYXAucHVzaHBvcCA9IHB1c2hwb3A7XG5IZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuSGVhcC5jb25zdW1lID0gY29uc3VtZTtcblxuSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5IZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbkhlYXAuTWluSGVhcCA9IEhlYXA7XG5IZWFwLk1heEhlYXAgPSBNYXhIZWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mnemonist/heap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mnemonist/queue.js":
/*!*****************************************!*\
  !*** ./node_modules/mnemonist/queue.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Mnemonist Queue\n * ================\n *\n * Queue implementation based on the ideas of Queue.js that seems to beat\n * a LinkedList one in performance.\n */\nvar Iterator = __webpack_require__(/*! obliterator/iterator */ \"(ssr)/./node_modules/obliterator/iterator.js\"),\n    forEach = __webpack_require__(/*! obliterator/foreach */ \"(ssr)/./node_modules/obliterator/foreach.js\");\n\n/**\n * Queue\n *\n * @constructor\n */\nfunction Queue() {\n  this.clear();\n}\n\n/**\n * Method used to clear the queue.\n *\n * @return {undefined}\n */\nQueue.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.offset = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to add an item to the queue.\n *\n * @param  {any}    item - Item to enqueue.\n * @return {number}\n */\nQueue.prototype.enqueue = function(item) {\n\n  this.items.push(item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve & remove the first item of the queue.\n *\n * @return {any}\n */\nQueue.prototype.dequeue = function() {\n  if (!this.size)\n    return;\n\n  var item = this.items[this.offset];\n\n  if (++this.offset * 2 >= this.items.length) {\n    this.items = this.items.slice(this.offset);\n    this.offset = 0;\n  }\n\n  this.size--;\n\n  return item;\n};\n\n/**\n * Method used to retrieve the first item of the queue.\n *\n * @return {any}\n */\nQueue.prototype.peek = function() {\n  if (!this.size)\n    return;\n\n  return this.items[this.offset];\n};\n\n/**\n * Method used to iterate over the queue.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nQueue.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)\n    callback.call(scope, this.items[i], j, this);\n};\n\n/*\n * Method used to convert the queue to a JavaScript array.\n *\n * @return {array}\n */\nQueue.prototype.toArray = function() {\n  return this.items.slice(this.offset);\n};\n\n/**\n * Method used to create an iterator over a queue's values.\n *\n * @return {Iterator}\n */\nQueue.prototype.values = function() {\n  var items = this.items,\n      i = this.offset;\n\n  return new Iterator(function() {\n    if (i >= items.length)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n    i++;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a queue's entries.\n *\n * @return {Iterator}\n */\nQueue.prototype.entries = function() {\n  var items = this.items,\n      i = this.offset,\n      j = 0;\n\n  return new Iterator(function() {\n    if (i >= items.length)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n    i++;\n\n    return {\n      value: [j++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  Queue.prototype[Symbol.iterator] = Queue.prototype.values;\n\n/**\n * Convenience known methods.\n */\nQueue.prototype.toString = function() {\n  return this.toArray().join(',');\n};\n\nQueue.prototype.toJSON = function() {\n  return this.toArray();\n};\n\nQueue.prototype.inspect = function() {\n  var array = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: Queue,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  Queue.prototype[Symbol.for('nodejs.util.inspect.custom')] = Queue.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a queue.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {Queue}\n */\nQueue.from = function(iterable) {\n  var queue = new Queue();\n\n  forEach(iterable, function(value) {\n    queue.enqueue(value);\n  });\n\n  return queue;\n};\n\n/**\n * Static @.of function taking an arbitrary number of arguments & converting it\n * into a queue.\n *\n * @param  {...any} args\n * @return {Queue}\n */\nQueue.of = function() {\n  return Queue.from(arguments);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Queue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW5lbW9uaXN0L3F1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFzQjtBQUM3QyxjQUFjLG1CQUFPLENBQUMsd0VBQXFCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21uZW1vbmlzdC9xdWV1ZS5qcz9hN2QzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW5lbW9uaXN0IFF1ZXVlXG4gKiA9PT09PT09PT09PT09PT09XG4gKlxuICogUXVldWUgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIGlkZWFzIG9mIFF1ZXVlLmpzIHRoYXQgc2VlbXMgdG8gYmVhdFxuICogYSBMaW5rZWRMaXN0IG9uZSBpbiBwZXJmb3JtYW5jZS5cbiAqL1xudmFyIEl0ZXJhdG9yID0gcmVxdWlyZSgnb2JsaXRlcmF0b3IvaXRlcmF0b3InKSxcbiAgICBmb3JFYWNoID0gcmVxdWlyZSgnb2JsaXRlcmF0b3IvZm9yZWFjaCcpO1xuXG4vKipcbiAqIFF1ZXVlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKCkge1xuICB0aGlzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8gY2xlYXIgdGhlIHF1ZXVlLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLml0ZW1zID0gW107XG4gIHRoaXMub2Zmc2V0ID0gMDtcbiAgdGhpcy5zaXplID0gMDtcbn07XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8gYWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlLlxuICpcbiAqIEBwYXJhbSAge2FueX0gICAgaXRlbSAtIEl0ZW0gdG8gZW5xdWV1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gKyt0aGlzLnNpemU7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlICYgcmVtb3ZlIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cblF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zaXplKVxuICAgIHJldHVybjtcblxuICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbdGhpcy5vZmZzZXRdO1xuXG4gIGlmICgrK3RoaXMub2Zmc2V0ICogMiA+PSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gIH1cblxuICB0aGlzLnNpemUtLTtcblxuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8gcmV0cmlldmUgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHF1ZXVlLlxuICpcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuUXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnNpemUpXG4gICAgcmV0dXJuO1xuXG4gIHJldHVybiB0aGlzLml0ZW1zW3RoaXMub2Zmc2V0XTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtICB7b2JqZWN0fSAgICBzY29wZSAgICAtIE9wdGlvbmFsIHNjb3BlLlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5RdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzY29wZSkge1xuICBzY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2NvcGUgOiB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLm9mZnNldCwgaiA9IDAsIGwgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKywgaisrKVxuICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIHRoaXMuaXRlbXNbaV0sIGosIHRoaXMpO1xufTtcblxuLypcbiAqIE1ldGhvZCB1c2VkIHRvIGNvbnZlcnQgdGhlIHF1ZXVlIHRvIGEgSmF2YVNjcmlwdCBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuUXVldWUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMuc2xpY2UodGhpcy5vZmZzZXQpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBjcmVhdGUgYW4gaXRlcmF0b3Igb3ZlciBhIHF1ZXVlJ3MgdmFsdWVzLlxuICpcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5RdWV1ZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuaXRlbXMsXG4gICAgICBpID0gdGhpcy5vZmZzZXQ7XG5cbiAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIHtcbiAgICBpZiAoaSA+PSBpdGVtcy5sZW5ndGgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuXG4gICAgdmFyIHZhbHVlID0gaXRlbXNbaV07XG4gICAgaSsrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIGNyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIGEgcXVldWUncyBlbnRyaWVzLlxuICpcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5RdWV1ZS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLFxuICAgICAgaSA9IHRoaXMub2Zmc2V0LFxuICAgICAgaiA9IDA7XG5cbiAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIHtcbiAgICBpZiAoaSA+PSBpdGVtcy5sZW5ndGgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuXG4gICAgdmFyIHZhbHVlID0gaXRlbXNbaV07XG4gICAgaSsrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBbaisrLCB2YWx1ZV0sXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBdHRhY2hpbmcgdGhlICMudmFsdWVzIG1ldGhvZCB0byBTeW1ib2wuaXRlcmF0b3IgaWYgcG9zc2libGUuXG4gKi9cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJylcbiAgUXVldWUucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBRdWV1ZS5wcm90b3R5cGUudmFsdWVzO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGtub3duIG1ldGhvZHMuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b0FycmF5KCkuam9pbignLCcpO1xufTtcblxuUXVldWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b0FycmF5KCk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJyYXkgPSB0aGlzLnRvQXJyYXkoKTtcblxuICAvLyBUcmljayBzbyB0aGF0IG5vZGUgZGlzcGxheXMgdGhlIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ2NvbnN0cnVjdG9yJywge1xuICAgIHZhbHVlOiBRdWV1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpXG4gIFF1ZXVlLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFF1ZXVlLnByb3RvdHlwZS5pbnNwZWN0O1xuXG4vKipcbiAqIFN0YXRpYyBALmZyb20gZnVuY3Rpb24gdGFraW5nIGFuIGFyYml0cmFyeSBpdGVyYWJsZSAmIGNvbnZlcnRpbmcgaXQgaW50b1xuICogYSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gaXRlcmFibGUgICAtIFRhcmdldCBpdGVyYWJsZS5cbiAqIEByZXR1cm4ge1F1ZXVlfVxuICovXG5RdWV1ZS5mcm9tID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cbiAgZm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBxdWV1ZS5lbnF1ZXVlKHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHF1ZXVlO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgQC5vZiBmdW5jdGlvbiB0YWtpbmcgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBhcmd1bWVudHMgJiBjb252ZXJ0aW5nIGl0XG4gKiBpbnRvIGEgcXVldWUuXG4gKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gKiBAcmV0dXJuIHtRdWV1ZX1cbiAqL1xuUXVldWUub2YgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFF1ZXVlLmZyb20oYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mnemonist/queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mnemonist/utils/comparators.js":
/*!*****************************************************!*\
  !*** ./node_modules/mnemonist/utils/comparators.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Mnemonist Heap Comparators\n * ===========================\n *\n * Default comparators & functions dealing with comparators reversing etc.\n */\nvar DEFAULT_COMPARATOR = function(a, b) {\n  if (a < b)\n    return -1;\n  if (a > b)\n    return 1;\n\n  return 0;\n};\n\nvar DEFAULT_REVERSE_COMPARATOR = function(a, b) {\n  if (a < b)\n    return 1;\n  if (a > b)\n    return -1;\n\n  return 0;\n};\n\n/**\n * Function used to reverse a comparator.\n */\nfunction reverseComparator(comparator) {\n  return function(a, b) {\n    return comparator(b, a);\n  };\n}\n\n/**\n * Function returning a tuple comparator.\n */\nfunction createTupleComparator(size) {\n  if (size === 2) {\n    return function(a, b) {\n      if (a[0] < b[0])\n        return -1;\n\n      if (a[0] > b[0])\n        return 1;\n\n      if (a[1] < b[1])\n        return -1;\n\n      if (a[1] > b[1])\n        return 1;\n\n      return 0;\n    };\n  }\n\n  return function(a, b) {\n    var i = 0;\n\n    while (i < size) {\n      if (a[i] < b[i])\n        return -1;\n\n      if (a[i] > b[i])\n        return 1;\n\n      i++;\n    }\n\n    return 0;\n  };\n}\n\n/**\n * Exporting.\n */\nexports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;\nexports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;\nexports.reverseComparator = reverseComparator;\nexports.createTupleComparator = createTupleComparator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW5lbW9uaXN0L3V0aWxzL2NvbXBhcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixrQ0FBa0M7QUFDbEMseUJBQXlCO0FBQ3pCLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9tbmVtb25pc3QvdXRpbHMvY29tcGFyYXRvcnMuanM/OWZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1uZW1vbmlzdCBIZWFwIENvbXBhcmF0b3JzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBEZWZhdWx0IGNvbXBhcmF0b3JzICYgZnVuY3Rpb25zIGRlYWxpbmcgd2l0aCBjb21wYXJhdG9ycyByZXZlcnNpbmcgZXRjLlxuICovXG52YXIgREVGQVVMVF9DT01QQVJBVE9SID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAoYSA+IGIpXG4gICAgcmV0dXJuIDE7XG5cbiAgcmV0dXJuIDA7XG59O1xuXG52YXIgREVGQVVMVF9SRVZFUlNFX0NPTVBBUkFUT1IgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYilcbiAgICByZXR1cm4gMTtcbiAgaWYgKGEgPiBiKVxuICAgIHJldHVybiAtMTtcblxuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byByZXZlcnNlIGEgY29tcGFyYXRvci5cbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZUNvbXBhcmF0b3IoY29tcGFyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJhdG9yKGIsIGEpO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhIHR1cGxlIGNvbXBhcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR1cGxlQ29tcGFyYXRvcihzaXplKSB7XG4gIGlmIChzaXplID09PSAyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhWzBdIDwgYlswXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICBpZiAoYVswXSA+IGJbMF0pXG4gICAgICAgIHJldHVybiAxO1xuXG4gICAgICBpZiAoYVsxXSA8IGJbMV0pXG4gICAgICAgIHJldHVybiAtMTtcblxuICAgICAgaWYgKGFbMV0gPiBiWzFdKVxuICAgICAgICByZXR1cm4gMTtcblxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzaXplKSB7XG4gICAgICBpZiAoYVtpXSA8IGJbaV0pXG4gICAgICAgIHJldHVybiAtMTtcblxuICAgICAgaWYgKGFbaV0gPiBiW2ldKVxuICAgICAgICByZXR1cm4gMTtcblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xuZXhwb3J0cy5ERUZBVUxUX0NPTVBBUkFUT1IgPSBERUZBVUxUX0NPTVBBUkFUT1I7XG5leHBvcnRzLkRFRkFVTFRfUkVWRVJTRV9DT01QQVJBVE9SID0gREVGQVVMVF9SRVZFUlNFX0NPTVBBUkFUT1I7XG5leHBvcnRzLnJldmVyc2VDb21wYXJhdG9yID0gcmV2ZXJzZUNvbXBhcmF0b3I7XG5leHBvcnRzLmNyZWF0ZVR1cGxlQ29tcGFyYXRvciA9IGNyZWF0ZVR1cGxlQ29tcGFyYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mnemonist/utils/comparators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mnemonist/utils/iterables.js":
/*!***************************************************!*\
  !*** ./node_modules/mnemonist/utils/iterables.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Mnemonist Iterable Function\n * ============================\n *\n * Harmonized iteration helpers over mixed iterable targets.\n */\nvar forEach = __webpack_require__(/*! obliterator/foreach */ \"(ssr)/./node_modules/obliterator/foreach.js\");\n\nvar typed = __webpack_require__(/*! ./typed-arrays.js */ \"(ssr)/./node_modules/mnemonist/utils/typed-arrays.js\");\n\n/**\n * Function used to determine whether the given object supports array-like\n * random access.\n *\n * @param  {any} target - Target object.\n * @return {boolean}\n */\nfunction isArrayLike(target) {\n  return Array.isArray(target) || typed.isTypedArray(target);\n}\n\n/**\n * Function used to guess the length of the structure over which we are going\n * to iterate.\n *\n * @param  {any} target - Target object.\n * @return {number|undefined}\n */\nfunction guessLength(target) {\n  if (typeof target.length === 'number')\n    return target.length;\n\n  if (typeof target.size === 'number')\n    return target.size;\n\n  return;\n}\n\n/**\n * Function used to convert an iterable to an array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArray(target) {\n  var l = guessLength(target);\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i++] = value;\n  });\n\n  return array;\n}\n\n/**\n * Same as above but returns a supplementary indices array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArrayWithIndices(target) {\n  var l = guessLength(target);\n\n  var IndexArray = typeof l === 'number' ?\n    typed.getPointerArray(l) :\n    Array;\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n  var indices = typeof l === 'number' ? new IndexArray(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i] = value;\n    indices[i] = i++;\n  });\n\n  return [array, indices];\n}\n\n/**\n * Exporting.\n */\nexports.isArrayLike = isArrayLike;\nexports.guessLength = guessLength;\nexports.toArray = toArray;\nexports.toArrayWithIndices = toArrayWithIndices;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW5lbW9uaXN0L3V0aWxzL2l0ZXJhYmxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0VBQXFCOztBQUUzQyxZQUFZLG1CQUFPLENBQUMsK0VBQW1COztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21uZW1vbmlzdC91dGlscy9pdGVyYWJsZXMuanM/ODlhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1uZW1vbmlzdCBJdGVyYWJsZSBGdW5jdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEhhcm1vbml6ZWQgaXRlcmF0aW9uIGhlbHBlcnMgb3ZlciBtaXhlZCBpdGVyYWJsZSB0YXJnZXRzLlxuICovXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ29ibGl0ZXJhdG9yL2ZvcmVhY2gnKTtcblxudmFyIHR5cGVkID0gcmVxdWlyZSgnLi90eXBlZC1hcnJheXMuanMnKTtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3Qgc3VwcG9ydHMgYXJyYXktbGlrZVxuICogcmFuZG9tIGFjY2Vzcy5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh0YXJnZXQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGFyZ2V0KSB8fCB0eXBlZC5pc1R5cGVkQXJyYXkodGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGd1ZXNzIHRoZSBsZW5ndGggb2YgdGhlIHN0cnVjdHVyZSBvdmVyIHdoaWNoIHdlIGFyZSBnb2luZ1xuICogdG8gaXRlcmF0ZS5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBndWVzc0xlbmd0aCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiB0YXJnZXQubGVuZ3RoID09PSAnbnVtYmVyJylcbiAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aDtcblxuICBpZiAodHlwZW9mIHRhcmdldC5zaXplID09PSAnbnVtYmVyJylcbiAgICByZXR1cm4gdGFyZ2V0LnNpemU7XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gY29udmVydCBhbiBpdGVyYWJsZSB0byBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHthbnl9ICAgdGFyZ2V0IC0gSXRlcmF0aW9uIHRhcmdldC5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KHRhcmdldCkge1xuICB2YXIgbCA9IGd1ZXNzTGVuZ3RoKHRhcmdldCk7XG5cbiAgdmFyIGFycmF5ID0gdHlwZW9mIGwgPT09ICdudW1iZXInID8gbmV3IEFycmF5KGwpIDogW107XG5cbiAgdmFyIGkgPSAwO1xuXG4gIC8vIFRPRE86IHdlIGNvdWxkIG9wdGltaXplIHdoZW4gZ2l2ZW4gdGFyZ2V0IGlzIGFycmF5IGxpa2VcbiAgZm9yRWFjaCh0YXJnZXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgYXJyYXlbaSsrXSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogU2FtZSBhcyBhYm92ZSBidXQgcmV0dXJucyBhIHN1cHBsZW1lbnRhcnkgaW5kaWNlcyBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHthbnl9ICAgdGFyZ2V0IC0gSXRlcmF0aW9uIHRhcmdldC5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5V2l0aEluZGljZXModGFyZ2V0KSB7XG4gIHZhciBsID0gZ3Vlc3NMZW5ndGgodGFyZ2V0KTtcblxuICB2YXIgSW5kZXhBcnJheSA9IHR5cGVvZiBsID09PSAnbnVtYmVyJyA/XG4gICAgdHlwZWQuZ2V0UG9pbnRlckFycmF5KGwpIDpcbiAgICBBcnJheTtcblxuICB2YXIgYXJyYXkgPSB0eXBlb2YgbCA9PT0gJ251bWJlcicgPyBuZXcgQXJyYXkobCkgOiBbXTtcbiAgdmFyIGluZGljZXMgPSB0eXBlb2YgbCA9PT0gJ251bWJlcicgPyBuZXcgSW5kZXhBcnJheShsKSA6IFtdO1xuXG4gIHZhciBpID0gMDtcblxuICAvLyBUT0RPOiB3ZSBjb3VsZCBvcHRpbWl6ZSB3aGVuIGdpdmVuIHRhcmdldCBpcyBhcnJheSBsaWtlXG4gIGZvckVhY2godGFyZ2V0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGFycmF5W2ldID0gdmFsdWU7XG4gICAgaW5kaWNlc1tpXSA9IGkrKztcbiAgfSk7XG5cbiAgcmV0dXJuIFthcnJheSwgaW5kaWNlc107XG59XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmd1ZXNzTGVuZ3RoID0gZ3Vlc3NMZW5ndGg7XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuZXhwb3J0cy50b0FycmF5V2l0aEluZGljZXMgPSB0b0FycmF5V2l0aEluZGljZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mnemonist/utils/iterables.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mnemonist/utils/typed-arrays.js":
/*!******************************************************!*\
  !*** ./node_modules/mnemonist/utils/typed-arrays.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW5lbW9uaXN0L3V0aWxzL3R5cGVkLWFycmF5cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7O0FBRUE7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21uZW1vbmlzdC91dGlscy90eXBlZC1hcnJheXMuanM/YTEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1uZW1vbmlzdCBUeXBlZCBBcnJheSBIZWxwZXJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBNaXNjZWxsYW5lb3VzIGhlbHBlcnMgcmVsYXRlZCB0byB0eXBlZCBhcnJheXMuXG4gKi9cblxuLyoqXG4gKiBXaGVuIHVzaW5nIGFuIHVuc2lnbmVkIGludGVnZXIgYXJyYXkgdG8gc3RvcmUgcG9pbnRlcnMsIG9uZSBtaWdodCB3YW50IHRvXG4gKiBjaG9vc2UgdGhlIG9wdGltYWwgd29yZCBzaXplIGluIHJlZ2FyZHMgdG8gdGhlIGFjdHVhbCBudW1iZXJzIG9mIHBvaW50ZXJzXG4gKiB0byBzdG9yZS5cbiAqXG4gKiBUaGlzIGhlbHBlcnMgZG9lcyBqdXN0IHRoYXQuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBzaXplIC0gRXhwZWN0ZWQgc2l6ZSBvZiB0aGUgYXJyYXkgdG8gbWFwLlxuICogQHJldHVybiB7VHlwZWRBcnJheX1cbiAqL1xudmFyIE1BWF84QklUX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA4KSAtIDEsXG4gICAgTUFYXzE2QklUX0lOVEVHRVIgPSBNYXRoLnBvdygyLCAxNikgLSAxLFxuICAgIE1BWF8zMkJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxudmFyIE1BWF9TSUdORURfOEJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgNykgLSAxLFxuICAgIE1BWF9TSUdORURfMTZCSVRfSU5URUdFUiA9IE1hdGgucG93KDIsIDE1KSAtIDEsXG4gICAgTUFYX1NJR05FRF8zMkJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcblxuZXhwb3J0cy5nZXRQb2ludGVyQXJyYXkgPSBmdW5jdGlvbihzaXplKSB7XG4gIHZhciBtYXhJbmRleCA9IHNpemUgLSAxO1xuXG4gIGlmIChtYXhJbmRleCA8PSBNQVhfOEJJVF9JTlRFR0VSKVxuICAgIHJldHVybiBVaW50OEFycmF5O1xuXG4gIGlmIChtYXhJbmRleCA8PSBNQVhfMTZCSVRfSU5URUdFUilcbiAgICByZXR1cm4gVWludDE2QXJyYXk7XG5cbiAgaWYgKG1heEluZGV4IDw9IE1BWF8zMkJJVF9JTlRFR0VSKVxuICAgIHJldHVybiBVaW50MzJBcnJheTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ21uZW1vbmlzdDogUG9pbnRlciBBcnJheSBvZiBzaXplID4gNDI5NDk2NzI5NSBpcyBub3Qgc3VwcG9ydGVkLicpO1xufTtcblxuZXhwb3J0cy5nZXRTaWduZWRQb2ludGVyQXJyYXkgPSBmdW5jdGlvbihzaXplKSB7XG4gIHZhciBtYXhJbmRleCA9IHNpemUgLSAxO1xuXG4gIGlmIChtYXhJbmRleCA8PSBNQVhfU0lHTkVEXzhCSVRfSU5URUdFUilcbiAgICByZXR1cm4gSW50OEFycmF5O1xuXG4gIGlmIChtYXhJbmRleCA8PSBNQVhfU0lHTkVEXzE2QklUX0lOVEVHRVIpXG4gICAgcmV0dXJuIEludDE2QXJyYXk7XG5cbiAgaWYgKG1heEluZGV4IDw9IE1BWF9TSUdORURfMzJCSVRfSU5URUdFUilcbiAgICByZXR1cm4gSW50MzJBcnJheTtcblxuICByZXR1cm4gRmxvYXQ2NEFycmF5O1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIG1pbmltYWwgdHlwZSBhYmxlIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7VHlwZWRBcnJheUNsYXNzfVxuICovXG5leHBvcnRzLmdldE51bWJlclR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gIC8vIDw9IDMyIGJpdHMgaXRudGVnZXI/XG4gIGlmICh2YWx1ZSA9PT0gKHZhbHVlIHwgMCkpIHtcblxuICAgIC8vIE5lZ2F0aXZlXG4gICAgaWYgKE1hdGguc2lnbih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICBpZiAodmFsdWUgPD0gMTI3ICYmIHZhbHVlID49IC0xMjgpXG4gICAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG5cbiAgICAgIGlmICh2YWx1ZSA8PSAzMjc2NyAmJiB2YWx1ZSA+PSAtMzI3NjgpXG4gICAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuXG4gICAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIGlmICh2YWx1ZSA8PSAyNTUpXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuXG4gICAgICBpZiAodmFsdWUgPD0gNjU1MzUpXG4gICAgICAgIHJldHVybiBVaW50MTZBcnJheTtcblxuICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgIH1cbiAgfVxuXG4gIC8vIDUzIGJpdHMgaW50ZWdlciAmIGZsb2F0c1xuICAvLyBOT1RFOiBpdCdzIGtpbmRhIGhhcmQgdG8gdGVsbCB3aGV0aGVyIHdlIGNvdWxkIHVzZSAzMmJpdHMgb3Igbm90Li4uXG4gIHJldHVybiBGbG9hdDY0QXJyYXk7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgbWluaW1hbCB0eXBlIGFibGUgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiBhcnJheVxuICogb2YgSmF2YVNjcmlwdCBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBhcnJheSAgLSBBcnJheSB0byByZXByZXNlbnQuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZ2V0dGVyIC0gT3B0aW9uYWwgZ2V0dGVyLlxuICogQHJldHVybiB7VHlwZWRBcnJheUNsYXNzfVxuICovXG52YXIgVFlQRV9QUklPUklUWSA9IHtcbiAgVWludDhBcnJheTogMSxcbiAgSW50OEFycmF5OiAyLFxuICBVaW50MTZBcnJheTogMyxcbiAgSW50MTZBcnJheTogNCxcbiAgVWludDMyQXJyYXk6IDUsXG4gIEludDMyQXJyYXk6IDYsXG4gIEZsb2F0MzJBcnJheTogNyxcbiAgRmxvYXQ2NEFycmF5OiA4XG59O1xuXG4vLyBUT0RPOiBtYWtlIHRoaXMgYSBvbmUtc2hvdCBmb3Igb25lIHZhbHVlXG5leHBvcnRzLmdldE1pbmltYWxSZXByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uKGFycmF5LCBnZXR0ZXIpIHtcbiAgdmFyIG1heFR5cGUgPSBudWxsLFxuICAgICAgbWF4UHJpb3JpdHkgPSAwLFxuICAgICAgcCxcbiAgICAgIHQsXG4gICAgICB2LFxuICAgICAgaSxcbiAgICAgIGw7XG5cbiAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHYgPSBnZXR0ZXIgPyBnZXR0ZXIoYXJyYXlbaV0pIDogYXJyYXlbaV07XG4gICAgdCA9IGV4cG9ydHMuZ2V0TnVtYmVyVHlwZSh2KTtcbiAgICBwID0gVFlQRV9QUklPUklUWVt0Lm5hbWVdO1xuXG4gICAgaWYgKHAgPiBtYXhQcmlvcml0eSkge1xuICAgICAgbWF4UHJpb3JpdHkgPSBwO1xuICAgICAgbWF4VHlwZSA9IHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heFR5cGU7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSAge2FueX0gdmFsdWUgLSBWYWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGNvbmNhdCBieXRlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0gIHsuLi5CeXRlQXJyYXl9XG4gKiBAcmV0dXJuIHtCeXRlQXJyYXl9XG4gKi9cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGggPSAwLFxuICAgICAgaSxcbiAgICAgIG8sXG4gICAgICBsO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgIGxlbmd0aCArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIHZhciBhcnJheSA9IG5ldyAoYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yKShsZW5ndGgpO1xuXG4gIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJyYXkuc2V0KGFyZ3VtZW50c1tpXSwgbyk7XG4gICAgbyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGluaXRpYWxpemUgYSBieXRlIGFycmF5IG9mIGluZGljZXMuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSAgICBsZW5ndGggLSBMZW5ndGggb2YgdGFyZ2V0LlxuICogQHJldHVybiB7Qnl0ZUFycmF5fVxuICovXG5leHBvcnRzLmluZGljZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgdmFyIFBvaW50ZXJBcnJheSA9IGV4cG9ydHMuZ2V0UG9pbnRlckFycmF5KGxlbmd0aCk7XG5cbiAgdmFyIGFycmF5ID0gbmV3IFBvaW50ZXJBcnJheShsZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgYXJyYXlbaV0gPSBpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mnemonist/utils/typed-arrays.js\n");

/***/ })

};
;